<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Go tour(3)-Concurrency]]></title>
      <url>/2019/06/11/Go-tour-3-Concurrency/</url>
      <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li>gorotine 协程</li>
<li>channel 信道</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> TYPE, BUFFER_SIZE) <span class="comment">// 创建一个信道</span></div><div class="line"><span class="keyword">go</span> FUNC(ch) <span class="comment">// 用协程执行FUNC，并传递一个信道</span></div><div class="line"><span class="keyword">for</span> y := <span class="keyword">range</span> ch <span class="comment">// 用range循环等待</span></div></pre></td></tr></table></figure>
<h3 id="练习：比较二叉树是否存储相同的值"><a href="#练习：比较二叉树是否存储相同的值" class="headerlink" title="练习：比较二叉树是否存储相同的值"></a>练习：比较二叉树是否存储相同的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"golang.org/x/tour/tree"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// Walk walks the tree t sending all values</span></div><div class="line"><span class="comment">// from the tree to the channel ch.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(t *tree.Tree, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	ch &lt;- t.Value</div><div class="line">	Walk(t.Left, ch)</div><div class="line">	Walk(t.Right, ch)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Same determines whether the trees</span></div><div class="line"><span class="comment">// t1 and t2 contain the same values.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Same</span><span class="params">(t1, t2 *tree.Tree)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</div><div class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</div><div class="line">	<span class="keyword">go</span> Walk(t1, ch1)</div><div class="line">	<span class="keyword">go</span> Walk(t2, ch2)</div><div class="line">	values1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</div><div class="line">	values2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</div><div class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++ &#123;</div><div class="line">		<span class="comment">// 阻塞在select</span></div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> v1 := &lt;- ch1:</div><div class="line">			values1 = <span class="built_in">append</span>(values1, v1)</div><div class="line">		<span class="keyword">case</span> v2 := &lt;- ch2:</div><div class="line">			values2 = <span class="built_in">append</span>(values2, v2)</div><div class="line">		<span class="comment">//在其余case没有准备好的时候，default会执行。不会阻塞</span></div><div class="line">			<span class="comment">//default:</span></div><div class="line">			<span class="comment">//fmt.Println("default")</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	fmt.Printf(<span class="string">"values1: %v\n"</span>, values1)</div><div class="line">	fmt.Printf(<span class="string">"values2: %v\n"</span>, values2)</div><div class="line">	</div><div class="line">	same := <span class="literal">false</span></div><div class="line">	<span class="keyword">for</span> v1:=<span class="keyword">range</span> values1 &#123;</div><div class="line">		same = <span class="literal">false</span></div><div class="line">		<span class="keyword">for</span> v2:=<span class="keyword">range</span> values2 &#123;</div><div class="line">			<span class="keyword">if</span> v1 == v2 &#123;</div><div class="line">				same = <span class="literal">true</span></div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> !same &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> same</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</div><div class="line">	<span class="keyword">go</span> Walk(tree.New(<span class="number">1</span>), ch)</div><div class="line">	</div><div class="line">	tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</div><div class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</div><div class="line">		v, ok := &lt;-ch</div><div class="line">		<span class="keyword">if</span> ok &#123;</div><div class="line">			tmp[i] = v</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"tmp: %v\n"</span>, tmp)</div><div class="line">	fmt.Println(<span class="string">"----------"</span>)</div><div class="line">	</div><div class="line">	isSame := Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">2</span>))</div><div class="line">	fmt.Println(<span class="string">"----------"</span>)</div><div class="line">	fmt.Println(isSame)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>基于channel的同步<br>By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">ch &lt;- <span class="number">2</span></div><div class="line">ch &lt;- <span class="number">3</span> <span class="comment">// 会出现死锁</span></div></pre></td></tr></table></figure>
</li>
<li><p>基于sync.Mutex的同步</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mux sync.Mutex</div><div class="line">mux.Lock()</div><div class="line"><span class="comment">// do something</span></div><div class="line">mux.Unlock()</div></pre></td></tr></table></figure>
</li>
<li><p>基于sync.WaitGroup同步<br>主线程等待所有协程返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 在执行协程之前调用Add</span></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">defer</span> wg.Done()</div><div class="line">    <span class="comment">// do something</span></div><div class="line">&#125;()</div><div class="line">wg.Wait()</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在执行协程之前调用Add。文档说明：Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. </p>
<h2 id="练习：并发爬虫"><a href="#练习：并发爬虫" class="headerlink" title="练习：并发爬虫"></a>练习：并发爬虫</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// Fetch returns the body of URL and</span></div><div class="line">	<span class="comment">// a slice of URLs found on that page.</span></div><div class="line">	Fetch(url <span class="keyword">string</span>) (body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Crawl uses fetcher to recursively crawl</span></div><div class="line"><span class="comment">// pages starting with url, to a maximum of depth.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher)</span></span> &#123;</div><div class="line">	<span class="comment">// 用waitgroup实现主线程等待</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> Fetch URLs in parallel.</span></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> Don't fetch the same URL twice.</span></div><div class="line">	<span class="comment">// 判断是否已访问</span></div><div class="line">	<span class="keyword">if</span> safemap.IsVisited(url) &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// This implementation doesn't do either:</span></div><div class="line">	<span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	body, urls, err := fetcher.Fetch(url)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 标记为已访问</span></div><div class="line">	safemap.Visit(url)</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"found: %s %q\n"</span>, url, body)</div><div class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> Crawl(u, depth<span class="number">-1</span>, fetcher)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	wg.Add(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> Crawl(<span class="string">"https://golang.org/"</span>, <span class="number">4</span>, fetcher)</div><div class="line">	wg.Wait()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 访问过的url</span></div><div class="line"><span class="keyword">type</span> SafeMap <span class="keyword">struct</span> &#123;</div><div class="line">	visited <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></div><div class="line">	mux sync.Mutex</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现安全操作map</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m SafeMap)</span> <span class="title">IsVisited</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	m.mux.Lock()</div><div class="line">	_, ok := m.visited[url]</div><div class="line">	<span class="keyword">defer</span> m.mux.Unlock()</div><div class="line">	<span class="keyword">return</span> ok</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现安全操作map</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m SafeMap)</span> <span class="title">Visit</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	m.mux.Lock()</div><div class="line">	m.visited[url] = <span class="literal">true</span></div><div class="line">	m.mux.Unlock()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> safemap = SafeMap&#123;visited: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)&#125;</div><div class="line"><span class="keyword">var</span> wg sync.WaitGroup</div><div class="line"></div><div class="line"><span class="comment">// fakeFetcher is Fetcher that returns canned results.</span></div><div class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</div><div class="line"></div><div class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</div><div class="line">	body <span class="keyword">string</span></div><div class="line">	urls []<span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span> <span class="title">Fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> res, ok := f[url]; ok &#123;</div><div class="line">		<span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// fetcher is a populated fakeFetcher.</span></div><div class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</div><div class="line">	<span class="string">"https://golang.org/"</span>: &amp;fakeResult&#123;</div><div class="line">		<span class="string">"The Go Programming Language"</span>,</div><div class="line">		[]<span class="keyword">string</span>&#123;</div><div class="line">			<span class="string">"https://golang.org/pkg/"</span>,</div><div class="line">			<span class="string">"https://golang.org/cmd/"</span>,</div><div class="line">		&#125;,</div><div class="line">	&#125;,</div><div class="line">	<span class="string">"https://golang.org/pkg/"</span>: &amp;fakeResult&#123;</div><div class="line">		<span class="string">"Packages"</span>,</div><div class="line">		[]<span class="keyword">string</span>&#123;</div><div class="line">			<span class="string">"https://golang.org/"</span>,</div><div class="line">			<span class="string">"https://golang.org/cmd/"</span>,</div><div class="line">			<span class="string">"https://golang.org/pkg/fmt/"</span>,</div><div class="line">			<span class="string">"https://golang.org/pkg/os/"</span>,</div><div class="line">		&#125;,</div><div class="line">	&#125;,</div><div class="line">	<span class="string">"https://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</div><div class="line">		<span class="string">"Package fmt"</span>,</div><div class="line">		[]<span class="keyword">string</span>&#123;</div><div class="line">			<span class="string">"https://golang.org/"</span>,</div><div class="line">			<span class="string">"https://golang.org/pkg/"</span>,</div><div class="line">		&#125;,</div><div class="line">	&#125;,</div><div class="line">	<span class="string">"https://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</div><div class="line">		<span class="string">"Package os"</span>,</div><div class="line">		[]<span class="keyword">string</span>&#123;</div><div class="line">			<span class="string">"https://golang.org/"</span>,</div><div class="line">			<span class="string">"https://golang.org/pkg/"</span>,</div><div class="line">		&#125;,</div><div class="line">	&#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go tour(2)-Methods and Interfaces]]></title>
      <url>/2019/06/11/Go-tour-2-Methods-and-Interfaces/</url>
      <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go没有类，方法跟函数的区别就是多了一个接收器Receiver</p>
<p>指针接收器，接收到的变量是指针形式的，意味着可以修改原变量。pointer receivers比value receivers更加常见。</p>
<p>函数的参数为指针必须显式传入一个指针，但如果是方法，Go解释器会隐式地将对象的指针传入，不需要显式取地址。同样的情况也发生在参数为值value的情况下，方法依然会进行隐式转换。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v Vertex</div><div class="line">ScaleFunc(v, <span class="number">5</span>) <span class="comment">// error</span></div><div class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// ok</span></div><div class="line">v.Scale(<span class="number">5</span>) <span class="comment">// OK</span></div><div class="line">(&amp;v).Scale(<span class="number">5</span>) <span class="comment">// OK</span></div></pre></td></tr></table></figure></p>
<p>指针接收器优点: 1.可以改变原变量；2.避免了传值拷贝</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口也是一种type。没有类，感觉像是在type上去实现方法。可以看成(value, type)的元组。<br>接口内的值就算是nil，也可以调用它的方法，不会报空指针异常。但是如果是nil接口，就会报错。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不会报错</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"><span class="keyword">var</span> t *T</div><div class="line">t.M()</div><div class="line"><span class="comment">// 会报错</span></div><div class="line"><span class="keyword">var</span> i I</div><div class="line">i.M()</div><div class="line"></div><div class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</div><div class="line">    M()</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 这样就实现了接口I</span></div><div class="line"><span class="keyword">var</span> i I = F(<span class="number">1.2</span>) <span class="comment">// 可以给接口赋值</span></div><div class="line">i.M() <span class="comment">// 调用接口实现中的方法</span></div><div class="line"></div><div class="line"><span class="comment">// 空接口可以接收任意类型的值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 判断接口具体的类型，跟map类似</span></div><div class="line">t, ok := i.(T)</div></pre></td></tr></table></figure></p>
<p>Error处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现了error接口的ErrNegativeSqrt</span></div><div class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="keyword">float64</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"cannot Sqrt negative number: %v"</span>, <span class="keyword">float64</span>(e))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</div><div class="line">		z := <span class="number">1.0</span></div><div class="line">		<span class="keyword">for</span> last_z := z; math.Abs(last_z-z) &gt; <span class="number">0.00001</span>; last_z = z &#123;</div><div class="line">			z -= (z*z - x) / (<span class="number">2</span>*z)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> z, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>, ErrNegativeSqrt(x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(Sqrt(<span class="number">2</span>))</div><div class="line">	fmt.Println(Sqrt(<span class="number">-2</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现了从无限流中读取'A'的Read方法</span></div><div class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyReader)</span> <span class="title">Read</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, e error)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(bytes); i++ &#123;</div><div class="line">		bytes[i]=<span class="string">'A'</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(bytes), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在io.Reader上包装，实现rot13算法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> rot13Reader <span class="keyword">struct</span> &#123;</div><div class="line">	r io.Reader</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(b <span class="keyword">byte</span>)</span> <span class="params">(bb <span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> (b &gt;= <span class="number">65</span> &amp;&amp; b &lt; <span class="number">78</span>) || (b &gt;= <span class="number">97</span> &amp;&amp; b &lt; <span class="number">110</span>) &#123;</div><div class="line">		bb = b+<span class="number">13</span></div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="number">78</span> &amp;&amp; b &lt; <span class="number">91</span>) || (b &gt;= <span class="number">110</span> &amp;&amp; b &lt; <span class="number">123</span>) &#123;</div><div class="line">		bb = b<span class="number">-13</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> bb</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rot rot13Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</div><div class="line">	n, e := rot.r.Read(b)</div><div class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</div><div class="line">		b[i] = transform(b[i])</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> n, e</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	s := strings.NewReader(<span class="string">"Lbh penpxrq gur pbqr!"</span>)</div><div class="line">	r := rot13Reader&#123;s&#125;</div><div class="line">	io.Copy(os.Stdout, &amp;r)</div><div class="line">    <span class="comment">// output: Youcrackedthecode</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现Image接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"golang.org/x/tour/pic"</span></div><div class="line">	<span class="string">"image/color"</span></div><div class="line">	<span class="string">"image"</span></div><div class="line">)</div><div class="line"><span class="comment">// 定义了一个Image结构体</span></div><div class="line"><span class="keyword">type</span> Image <span class="keyword">struct</span>&#123;</div><div class="line">	w <span class="keyword">int</span></div><div class="line">	h <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// Image实现Image的接口</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">type Image interface &#123;</span></div><div class="line"><span class="comment">    ColorModel() color.Model</span></div><div class="line"><span class="comment">    Bounds() Rectangle</span></div><div class="line"><span class="comment">    At(x, y int) color.Color</span></div><div class="line"><span class="comment">&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span> <span class="title">ColorModel</span><span class="params">()</span> <span class="title">color</span>.<span class="title">Model</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> color.RGBAModel</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span> <span class="title">Bounds</span><span class="params">()</span> <span class="title">image</span>.<span class="title">Rectangle</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> image.Rect(<span class="number">0</span>, <span class="number">0</span>, img.w, img.h)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span> <span class="title">At</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">color</span>.<span class="title">Color</span></span> &#123;</div><div class="line">	v := <span class="keyword">uint8</span>(x^y)</div><div class="line">	<span class="keyword">return</span> color.RGBA&#123;v, v, <span class="number">255</span>, <span class="number">255</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	m := Image&#123;w:<span class="number">200</span>, h:<span class="number">200</span>&#125;</div><div class="line">	<span class="comment">// 使用实现了Image接口的m</span></div><div class="line">	pic.ShowImage(m)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go tour(1)-Basics]]></title>
      <url>/2019/06/11/Go-tour-1-Basics/</url>
      <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// :=是在函数内部声明变量并赋值，在函数外部不能用</span></div><div class="line"><span class="comment">// 变量用var，常量用const，常量不能用:=</span></div><div class="line">k := <span class="number">3</span></div><div class="line"><span class="keyword">const</span> K <span class="keyword">int</span> = <span class="number">3</span></div><div class="line"><span class="keyword">var</span> k = <span class="number">3</span></div><div class="line"><span class="comment">// 返回值可以命名，可以多个</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	x = sum * <span class="number">4</span> / <span class="number">9</span></div><div class="line">	y = sum - x</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 没有初始值的变量会被赋零值</span></div><div class="line"><span class="comment">/* 基本数据类型</span></div><div class="line"><span class="comment">bool string</span></div><div class="line"><span class="comment">int int8 .... int64</span></div><div class="line"><span class="comment">uint uint8 ...... uint64</span></div><div class="line"><span class="comment">byte // uint8的别名 </span></div><div class="line"><span class="comment">rune // int32的别名</span></div><div class="line"><span class="comment">float32 float64</span></div><div class="line"><span class="comment">complex64 complex128</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<h2 id="分支循环"><a href="#分支循环" class="headerlink" title="分支循环"></a>分支循环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if后面可以跟一句初始语句，整个条件语句作用域可用</span></div><div class="line"><span class="keyword">if</span> a:=b<span class="number">-32</span>; a&gt;<span class="number">0</span> &#123;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">// switch也可以这样，而且不用显示break</span></div><div class="line">	<span class="keyword">switch</span> os := runtime.GOOS; os &#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">"darwin"</span>:</div><div class="line">		fmt.Println(<span class="string">"OS X."</span>)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		fmt.Printf(<span class="string">"%s.\n"</span>, os)</div><div class="line">	&#125;</div><div class="line"><span class="comment">// switch也可以没有条件表达式</span></div><div class="line"><span class="keyword">switch</span> &#123;</div><div class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</div><div class="line">		fmt.Println(<span class="string">"Good morning!"</span>)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		fmt.Println(<span class="string">"Good evening."</span>)</div><div class="line">	&#125;</div><div class="line"><span class="comment">// 只有一种循环for，不用小括号，必须用花括号</span></div><div class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</div><div class="line">    fmt.Println(i)</div><div class="line">&#125;</div><div class="line"><span class="comment">// defer声明的语句会在外部函数返回才调用，这些语句会被压入到栈中</span></div><div class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</div></pre></td></tr></table></figure>
<h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 指针</span></div><div class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = <span class="number">42</span></div><div class="line">i := <span class="number">21</span></div><div class="line">pp = &amp;i</div><div class="line"></div><div class="line"><span class="comment">// 结构体</span></div><div class="line"><span class="keyword">type</span> Vertext <span class="keyword">struct</span> &#123;</div><div class="line">    X <span class="keyword">int</span></div><div class="line">    Y <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line">v := Vertex&#123;X:<span class="number">1</span>, Y:<span class="number">2</span>&#125;</div><div class="line">p := &amp;v</div><div class="line"></div><div class="line"><span class="comment">// 数组</span></div><div class="line"><span class="comment">// 切片传参是传指针</span></div><div class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">string</span></div><div class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// 切片以后是在原数组上操作</span></div><div class="line"><span class="comment">// 切片的长度和容量：len是切片含有多少个元素，capacity是从切片第一个元素到数组最后一个元素含有的元素个数</span></div><div class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line">s = s[:<span class="number">2</span>]</div><div class="line"><span class="built_in">len</span>(s) <span class="comment">// 2</span></div><div class="line"><span class="built_in">cap</span>(s) <span class="comment">// 4</span></div><div class="line">s = s[<span class="number">2</span>:]</div><div class="line"><span class="built_in">len</span>(s) <span class="comment">// 2</span></div><div class="line"><span class="built_in">cap</span>(s) <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="comment">// make创建动态数组</span></div><div class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</div><div class="line"></div><div class="line"><span class="comment">// append进行切片追加的时候，如果元素个数大于了capacity，那么按什么方式将底层数组扩容？2,4,8?</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">// <span class="title">range</span></span></div><div class="line"><span class="function">// <span class="title">v</span>是浅拷贝还是深拷贝？浅拷贝，依然可以通过<span class="title">v</span>操作原数组</span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> pow = [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;</div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</div><div class="line">		v[<span class="number">0</span>] = <span class="number">5</span></div><div class="line">		fmt.Println(v)</div><div class="line">       <span class="comment">// 可以通过pow[i]对原数组进行操作</span></div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"%v"</span>, pow)</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">[5 2]</span></div><div class="line"><span class="comment">[5 4]</span></div><div class="line"><span class="comment">[[5 2] [5 4]]</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<p>实现built-in的append函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(slice []<span class="keyword">int</span>, data ...<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</div><div class="line">	m := <span class="built_in">len</span>(slice)</div><div class="line">	n := m+<span class="built_in">len</span>(data)</div><div class="line">	<span class="keyword">if</span> n &gt; <span class="built_in">cap</span>(slice) &#123;</div><div class="line">		<span class="keyword">var</span> newSlice []<span class="keyword">int</span></div><div class="line">		<span class="keyword">if</span> m == <span class="number">0</span> &#123;</div><div class="line">			newSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			newSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>*m)</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">copy</span>(newSlice, slice)</div><div class="line">		slice = newSlice</div><div class="line">	&#125;</div><div class="line">	slice = slice[<span class="number">0</span>:n]</div><div class="line">	<span class="built_in">copy</span>(slice[m:n], data)</div><div class="line">	<span class="keyword">return</span> slice</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>slice练习<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="keyword">int</span>)</span> [][]<span class="title">uint8</span></span> &#123;</div><div class="line">	ret := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dy)</div><div class="line">	<span class="keyword">for</span> y := <span class="keyword">range</span> ret &#123;</div><div class="line">		ret[y] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dx)</div><div class="line">		<span class="keyword">for</span> x:=<span class="number">0</span>; x &lt; dx; x++ &#123;</div><div class="line">			ret[y][x] = <span class="keyword">uint8</span>(<span class="keyword">float64</span>(x)*math.Log(<span class="keyword">float64</span>(y)))</div><div class="line">            <span class="comment">// 两种方法都可以</span></div><div class="line">			<span class="comment">// ret[y] = append(ret[y], uint8(float64(x)*math.Log(float64(y))))</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// map初始化</span></div><div class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</div><div class="line"><span class="comment">// 操作</span></div><div class="line">a = m[key]</div><div class="line"><span class="built_in">delete</span>(m, key) <span class="comment">// 删除key</span></div><div class="line">item, ok := m[key] <span class="comment">// 判断key是否在m中</span></div><div class="line"></div><div class="line"><span class="comment">// 参数可以是函数，也可以有匿名函数</span></div><div class="line"><span class="comment">// 赋值再调用</span></div><div class="line">fplus := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x + y &#125;</div><div class="line">fplus(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line"><span class="comment">// 直接调用匿名函数</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x + y &#125; (<span class="number">3</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>闭包实现斐波那契数列<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 跟Python不一样的是，不会发生自由变量降级成为局部变量的现象，也不需要nolocal声明。因为go语言需要变量声明，Python不需要变量声明。</span></div><div class="line"></div><div class="line"><span class="comment">// fibonacci is a function that returns</span></div><div class="line"><span class="comment">// a function that returns an int.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	pre2 := <span class="number">-1</span></div><div class="line">	pre1 := <span class="number">1</span></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">		tmp := pre2</div><div class="line">		pre2 = pre1</div><div class="line">		pre1 = tmp + pre1</div><div class="line">		<span class="keyword">return</span> pre1</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	f := fibonacci()</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">		fmt.Println(f())</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CS6.824(1)-mapreduce]]></title>
      <url>/2019/05/15/CS6.824(1)-mapreduce/</url>
      <content type="html"><![CDATA[<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>master: 获取Job信息，决定mapper和reducer个数，并分割文件。同时接收来自worker的注册，根据一定策略调度task给可用的worker，并进行出错处理。</p>
<p>worker: 执行具体的mapper或者reducer。</p>
<p>map阶段: map(k1, v1) -&gt; list(k2, v2)</p>
<p>reduce阶段: reduce(k2, list(v2)) -&gt; list(k2, v3)</p>
<h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><p>Mapper读取master分配给自己的一份小文件，调用用户定义的map函数处理文件内容，map函数会返回一个key-value列表。</p>
<p>对于所有的key，mapper会计算其hash值并跟reducer个数取模，这样就完成了partition的过程，这个过程主要是为了将key分散到不同的reducer中。</p>
<p>对于上面的每一个partition，mapper会生成一个文件，将属于其的key-value对列表写入到该文件中。为了方便，序列化为JSON格式。在reduce阶段，reducer会从多个mapper生成的文件中读取分配给自己的文件。</p>
<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p>Reducer从map阶段生成的文件中读取分配给自己的文件，反序列化为key-value对列表。接下来，Reducer需要完成根据key来分组的过程。</p>
<p>这个过程可以用hashmap来实现，也可以用排序来实现。因为考虑到文件会很大，在内存中保存这样一个hashmap消耗很大。这里使用排序来实现。对于key-value对列表，调用排序函数根据key进行排序。排序完成后，只要发现下一个key跟上一个key不一样，就可以判断在这里是两个组的分割点，上一个分割点到这一个分割点中间的数据就是同一个key的列表。</p>
<p>分组完成后，调用用户定义的reduce函数处理每一个key及其value列表，reduce函数返回一个字符串，代表这个key规约的结果。</p>
<p>最后将key以及key规约的结果序列化成JSON格式，写入到reduce输出的文件中。</p>
<p>之后还会有merge的阶段，将多个reducer生成的文件合并成一个完整文件，作为MapReduce最终的输出结果。</p>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>master启动一个RPC服务器，用来接收worker的注册。worker通过RPC注册到master后，master会将worker的信息发送给registerChan。Scheduler从registerChan中接收注册的worker，加入到idleWorkerChan中。这个过程是在一个go程里循环读取的。</p>
<p>在map阶段或者reduce阶段，对于所有的task，首先将所有task放入到taskChan中，之后循环从这个taskChan中获取一个task，然后启动一个go程，在这个go程里从idleWorkerChan中获取一个worker，把这个task通过rpc的方式交给这个worker去执行。</p>
<p>在这里简化了worker崩溃的判断，只要rpc调用失败就认为worker崩溃，这个时候将task放回到taskChan中。如果rpc调用成功，则将worker放入idleWorkerChan中，使得其可以重新被调度。</p>
<p>当所有task执行完毕后，主线程会收到一个通知，跳出循环，结束该阶段的任务。</p>
<h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><p>因为只有当map阶段的任务完成以后才会开始执行reduce任务，只有当reduce阶段任务全部完成后才会开始执行merge，因此保证了map操作跟reduce操作具有原子性。也就是说，map(reduce)的输出文件要么不可用，要么就是完整的。下一阶段的task不会读取到不一致的数据。</p>
<p>map跟reduce操作都是幂等的，也就是多次重复执行产生的结果一直，这也是上述在worker失败时，schedule可以将task放回到taskChan中重新执行的背后原理。</p>
]]></content>
      
        
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fluent Python(17-18)——并发]]></title>
      <url>/2019/03/11/Fluent%20Python(17-18)%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="17-concurrent处理多进程和多线程"><a href="#17-concurrent处理多进程和多线程" class="headerlink" title="17. concurrent处理多进程和多线程"></a>17. concurrent处理多进程和多线程</h1><h2 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h2><ol>
<li>线程池和进程池：ThreadPoolExecutor和ProcessPoolExecutor</li>
<li>ThreadPoolExecutor.map(func, list_of_param)返回生成器，获取各个函数返回的值。获取返回值时会<strong>阻塞</strong>，返回结果的顺序与调用的顺序一致。</li>
<li>ThreadPoolExecutor.submit(func, param)返回future对象，futures.as_completed(list_of_future)返回迭代器，在任一future运行结束后产出future。之后可以使用future.result()获取结果，这样可以<strong>不阻塞</strong>。</li>
<li>另一种方式是future.add_done_callback(callback)</li>
</ol>
<p>as_completed()内部实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将调用as_completed之前已经完成的future直接yield</span></div><div class="line"><span class="keyword">yield</span> <span class="keyword">from</span> finished</div><div class="line"><span class="comment"># 死循环</span></div><div class="line"><span class="keyword">while</span> pending:</div><div class="line">    <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        wait_timeout = <span class="keyword">None</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        wait_timeout = end_time - time.time()</div><div class="line">        <span class="keyword">if</span> wait_timeout &lt; <span class="number">0</span>:</div><div class="line">            <span class="keyword">raise</span> TimeoutError(</div><div class="line">                    <span class="string">'%d (of %d) futures unfinished'</span> % (</div><div class="line">                    len(pending), len(fs)))</div><div class="line">    <span class="comment"># 阻塞等待有没有future完成</span></div><div class="line">    waiter.event.wait(wait_timeout)</div><div class="line"></div><div class="line">    <span class="keyword">with</span> waiter.lock:</div><div class="line">        finished = waiter.finished_futures</div><div class="line">        waiter.finished_futures = []</div><div class="line">        waiter.event.clear()</div><div class="line">    <span class="comment"># 每当有完成的future时，yield future</span></div><div class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> finished:</div><div class="line">        <span class="keyword">yield</span> future</div><div class="line">        pending.remove(future)</div></pre></td></tr></table></figure></p>
<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><ol>
<li>CPython解释器本身不是线程安全的，因此有GIL，一次只允许一个线程执行Python字节码。</li>
<li>标准库中阻塞性IO操作在等待系统返回结果时会释放GIL，因此IO密集型操作可以用多线程并发；time.sleep()也会释放GIL实现并发。</li>
<li>CPU密集型操作使用多进程并发。</li>
<li>PyPy虽然没有释放GIL，但是因为有JIL，在CPU密集型工作时比CPython快。</li>
</ol>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>注意：with块结束后主程序才会继续往下执行，或者显式地调用executor.shutdown(wait=False)不等待继续执行。</p>
<p>shutdown(wait=True)的含义：</p>
<p>Signal the executor that it should free any resources that it is using when the currently pending futures are done executing.</p>
<p>所以调用shutdown并不会中断当前进程池中的future，只是通知future执行完毕后释放资源。</p>
<h1 id="18-asyncio协程处理并发"><a href="#18-asyncio协程处理并发" class="headerlink" title="18. asyncio协程处理并发"></a>18. asyncio协程处理并发</h1><h2 id="yield-from-await的概念"><a href="#yield-from-await的概念" class="headerlink" title="yield from/await的概念"></a>yield from/await的概念</h2><p>在调用方-委派生成器-子生成器模型中：<br>在gen中使用yield from subgen()时，subgen获得控制权，把产出的值传给gen的调用方。gen会阻塞，等待subgen()产出值。<br>yield from的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送(send)和产出(yield)值。（在Python 3.5以上，可以使用await代替yield from，更容易理解）<br>假设yield from出现在委派生成器中，客户端代码驱动着委派生成器，而委派生成器驱动着子生成器。</p>
<p>asyncio中：<br>可以这样理解，yield from跟普通调用的区别就在于不会阻塞事件循环。类似于epoll。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 不会阻塞事件循环，因为当调用了yield from以后，控制权就回到事件循环手中了。</span></div><div class="line">resp = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.request(<span class="string">'GET'</span>, url)</div><div class="line"><span class="comment"># resp = await aiohttp.request('GET', url) 用await更容易理解</span></div><div class="line"><span class="comment"># 会阻塞主线程</span></div><div class="line">resp = aiohttp.request(<span class="string">'GET'</span>, url)</div></pre></td></tr></table></figure></p>
<p>yield from的用法：</p>
<ol>
<li>在yield from链接的多个协程最终必须由不是协程的调用方驱动，调用方显示或隐式在最外层委派生成器上调用next(…)或.send(…)。</li>
<li>链条中最内层的子生成器必须是简单生成器(yield)或可迭代对象。</li>
</ol>
<p>在asyncio中：<br>我们编写的协程链条始终通过把最外层委派生成器传给asyncio包API中的某个函数(如loop.run_until_complete(…))驱动。也就是说，调用next(…)或者send(…)的操作由asyncio的事件循环完成。</p>
<p>概括起来：使用asyncio包时，使用yield from架起管道，让asyncio的事件循环(通过我们编写的协程)，驱动执行底层异步IO操作的库函数。</p>
<h2 id="使用asyncio的步骤"><a href="#使用asyncio的步骤" class="headerlink" title="使用asyncio的步骤"></a>使用asyncio的步骤</h2><h3 id="1-创建task-可选"><a href="#1-创建task-可选" class="headerlink" title="1. 创建task(可选)"></a>1. 创建task(可选)</h3><p>创建单个task：</p>
<ul>
<li>asyncio.async(…)</li>
<li>BaseEventLoop.create_task(…)</li>
</ul>
<p>创建多个task:</p>
<ul>
<li>asyncio.wait(coros)  全部协程执行完毕后返回结果</li>
<li>asyncio.as_completed(coros)  返回一个生成器，当有协程完成时就迭代</li>
</ul>
<h3 id="2-获取事件循环"><a href="#2-获取事件循环" class="headerlink" title="2. 获取事件循环"></a>2. 获取事件循环</h3><p>loop = asyncio.get_event_loop()</p>
<h3 id="3-将task-s-或者coro加入到事件循环中"><a href="#3-将task-s-或者coro加入到事件循环中" class="headerlink" title="3. 将task(s)或者coro加入到事件循环中"></a>3. 将task(s)或者coro加入到事件循环中</h3><ul>
<li>loop.run_until_complete(coro/task)   普通运行loop</li>
<li>loop.run_in_executor(coro/task)   在ThreadPoolExecutor中运行loop</li>
</ul>
<p><strong>需要注意的是，第1步不是必须的，如果在第3步中传入的是协程而不是task，那么run_until_complete()会将协程包装成task，之所以用第1步，是为了持有task对象，方便对协程进行操作，比如获取完成的task的result、task.cancel()等。</strong></p>
<p>至于协程本身的定义，内部使用yield from关键字，函数使用@asyncio.coroutine装饰。</p>
<p><strong>对于Python 3.5以上，内部使用await代替yield from，函数使用async def func()</strong>，语义更加明确。</p>
<h3 id="异步IO的事件循环示例："><a href="#异步IO的事件循环示例：" class="headerlink" title="异步IO的事件循环示例："></a>异步IO的事件循环示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Hello world! (%s)'</span> % threading.currentThread())</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</div><div class="line">    print(<span class="string">'Hello again! (%s)'</span> % threading.currentThread())</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">tasks = [hello(), hello()]</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line">loop.close()</div></pre></td></tr></table></figure>
<p>执行结果:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Hello world! (<span class="name">&lt;_MainThread</span>(<span class="name">MainThread</span>, started <span class="number">140735195337472</span>)&gt;)</div><div class="line">Hello world! (<span class="name">&lt;_MainThread</span>(<span class="name">MainThread</span>, started <span class="number">140735195337472</span>)&gt;)</div><div class="line">(暂停约<span class="number">1</span>秒)</div><div class="line">Hello again! (<span class="name">&lt;_MainThread</span>(<span class="name">MainThread</span>, started <span class="number">140735195337472</span>)&gt;)</div><div class="line">Hello again! (<span class="name">&lt;_MainThread</span>(<span class="name">MainThread</span>, started <span class="number">140735195337472</span>)&gt;)</div></pre></td></tr></table></figure></p>
<p>可以看到，两个协程并发执行，但是是在同一个线程里完成的，中间并没有发生阻塞。也就是说，当协程运行到await asyncio.sleep(1)时，控制权会交换给事件循环，事件循环会去继续执行其他协程，中间不会阻塞。</p>
<h3 id="基于异步IO的HTTP服务器"><a href="#基于异步IO的HTTP服务器" class="headerlink" title="基于异步IO的HTTP服务器"></a>基于异步IO的HTTP服务器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></div><div class="line">    print(<span class="string">'Receive: &#123;&#125;'</span>.format(request))</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</div><div class="line">    <span class="keyword">return</span> web.Response(content_type=<span class="string">'text/html'</span>, text=<span class="string">'&lt;h1&gt;Index&lt;/h1&gt;'</span>)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></div><div class="line">    print(<span class="string">'Receive: &#123;&#125;'</span>.format(request))</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</div><div class="line">    text = <span class="string">'&lt;h1&gt;hello, %s!&lt;/h1&gt;'</span> % request.match_info[<span class="string">'name'</span>]</div><div class="line">    <span class="keyword">return</span> web.Response(content_type=<span class="string">'text/html'</span>, text=text)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(loop, address, port)</span>:</span></div><div class="line">    app = web.Application(loop=loop)</div><div class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/'</span>, index)</div><div class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/hello/&#123;name&#125;'</span>, hello)</div><div class="line">    srv = <span class="keyword">await</span> loop.create_server(app.make_handler(), address, port)</div><div class="line">    print(<span class="string">'Server started at http://&#123;&#125;:&#123;&#125;...'</span>.format(address, port))</div><div class="line">    <span class="keyword">return</span> srv</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(address=<span class="string">'127.0.0.1'</span>, port=<span class="number">8888</span>)</span>:</span></div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    <span class="comment"># 注意观察这里的srv，其实是协程init结束后的返回值</span></div><div class="line">    srv = loop.run_until_complete(init(loop, address, port))</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        loop.run_forever()</div><div class="line">    <span class="keyword">except</span> KeyboardInterrupt:</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    print(<span class="string">'Server &#123;&#125; shutting down.'</span>.format(srv))</div><div class="line">    loop.close()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main(*sys.argv[<span class="number">1</span>:])</div></pre></td></tr></table></figure>
<h1 id="Python并发总结"><a href="#Python并发总结" class="headerlink" title="Python并发总结"></a>Python并发总结</h1><p>协程的底层还是基于事件循环，类似于IO多路复用这种方式，让单线程可以实现并发。</p>
<p>并发的实现依赖于协程的不阻塞，所以协程最后的操作要使用非阻塞操作(比如asyncio.sleep(0.5)是非阻塞的，或者一些asyncio的网络IO操作)才能发挥作用，否则就跟顺序执行一样了。如果必须要使用阻塞的操作，可以使用<code>loop.run_in_executor</code>在线程池中使用多个loop。</p>
<p>asyncio实现并发的流程：主线程持有一个事件循环loop，会去调度加入到事件循环中的协程并调度执行，当协程进行异步操作的时候，控制权回到事件循环，事件循环再去调度其他协程执行。当暂停的协程返回时，事件循环再去调度其执行。因而实现了并发，跟IO多路复用很像。</p>
<p>协程跟多线程相比优势：</p>
<ol>
<li>没有切换线程的开销</li>
<li>不用处理锁</li>
<li>由用户决定协程的调度（通过send()激活，yield暂停）</li>
</ol>
<p>协程跟多线程相比劣势：</p>
<ol>
<li>执行的操作必须是异步操作，否则就没有调度的意义</li>
<li>无论怎么说，只有一个线程，没法使用到多核CPU。(Go语言好像解决了这个问题)</li>
</ol>
<p>总结来说，并发的实现可以基于三种方式：</p>
<ol>
<li>多进程</li>
<li>多线程</li>
<li>基于事件循环的异步IO</li>
</ol>
<p>而对于3来说，目前主流语言有两种实现方式：1.回调 2.协程。NodeJS里使用的是回调，而Python使用的是协程。</p>
<p>与回调相比，协程的优势在于：</p>
<ol>
<li>不会陷入多层回调嵌套，那样代码是复杂且难以阅读的。</li>
<li>协程可以在中断处保存上下文，下次继续执行时可以恢复，因而不需要再去单独把中间结果保存到全局或者其他地方（回调中必须这样做）。</li>
</ol>
<h2 id="使用场景总结"><a href="#使用场景总结" class="headerlink" title="使用场景总结"></a>使用场景总结</h2><p>计算密集型使用多进程。这样可以用到多核CPU。</p>
<p>异步IO密集型可以使用协程，然后用线程池创建多个event_loop可以辅助提高性能；</p>
<p>同步IO密集型使用多线程。Python因为有GIL锁，其实多线程并不能利用多核CPU实现<strong>并行</strong>。</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fluent Python(14-16)——从迭代器到协程]]></title>
      <url>/2019/03/03/Fluent%20Python(14-16)%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="14-迭代器与生成器"><a href="#14-迭代器与生成器" class="headerlink" title="14. 迭代器与生成器"></a>14. 迭代器与生成器</h1><ol>
<li><p><strong>可迭代的对象</strong>：使用iter内置函数可以获取迭代器的对象。如果对象实现了<code>__iter__</code>方法，能够返回一个迭代器，那么对象就是可迭代的。</p>
</li>
<li><p><strong>迭代器</strong>：对象实现了<code>__next__</code>返回序列中的下一个元素。迭代器还实现了<code>__iter__</code>返回self，因此迭代器也可以迭代。</p>
</li>
<li><p><strong>生成器函数</strong>：函数的定义体中有<code>yield</code>关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p>
</li>
<li><p><strong>关系</strong>：所有的生成器都是迭代器，因为生成器完全实现了迭代器接口。生成器只是另一种实现可迭代对象的方式而已。除了会创建和保存程序状态，当生成器终结时，还会自动抛出StopIteration异常。</p>
</li>
</ol>
<h1 id="15-上下文管理器和with块"><a href="#15-上下文管理器和with块" class="headerlink" title="15. 上下文管理器和with块"></a>15. 上下文管理器和with块</h1><ol>
<li><p>else可以用在for, while, try的后面，循环体正常执行完毕（没有break, 没有except）后退出时执行else的内容。</p>
</li>
<li><p>上下文管理器对象存在的目的是管理with块，简化try/finally模式。</p>
</li>
<li><p>ContextManger实现的两种方式：</p>
<ol>
<li>编写一个类，实现<code>__enter__</code>和<code>__exit__</code>方法</li>
<li>调用<code>@contextlib.contextmanager</code>装饰器，将生成器函数转变为上下文管理器，函数中yield之前的语句对应<code>__enter__</code>内容，yield xxx为返回的对象（对应到with func() as xxx的xxx），yield之后的语句对应<code>__exit__</code>内容。<strong>始终用try语句包裹yield语句</strong></li>
</ol>
</li>
</ol>
<h1 id="16-协程"><a href="#16-协程" class="headerlink" title="16. 协程"></a>16. 协程</h1><h2 id="1-进程、线程、协程"><a href="#1-进程、线程、协程" class="headerlink" title="1. 进程、线程、协程"></a>1. 进程、线程、协程</h2><p>进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。</p>
<p>线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程，而多个线程共享内存（数据共享，共享全局变量),从而极大地提高了程序的运行效率。 </p>
<p>协程: 可以理解一种<strong>用户态的轻量级线程</strong>，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<p>协程与子程序的区别：调用子程序执行到return之后子程序就完全返回到主程序了，而协程会保存现场，下次从中断点继续执行。（中断）</p>
<p>协程与线程优势：1. 没有多线程切换的开销，寄存器和栈都保存在用户态。2. 不需要锁机制，因为是在一个线程中，不存在写变量冲突问题。所以协程是一种协作式多任务，多线程是一种抢占式多任务。</p>
<p>Python里CPU密集型使用多进程，IO密集型使用多线程或协程。</p>
<h2 id="2-协程"><a href="#2-协程" class="headerlink" title="2. 协程"></a>2. 协程</h2><ol>
<li><p><code>b = yield a</code> 表达式左右两边在两次send()执行。</p>
</li>
<li><p>调用方调用<code>next(cor)</code>之后，协程执行到<code>yield a</code>并暂停，调用方收到返回值；调用方调用<code>cor.send(b)</code>，从中断点继续执行，将接收到的b赋值给等号左边的b，继续向下执行。当碰到下一个<code>yield a</code>时再次暂停并产出a。 </p>
</li>
<li><p><code>yield from</code>实现类似于管道的功能，调用方-委派生成器-子生成器。</p>
</li>
<li><p>生成器函数需要初始化也就是<code>f=func()</code>后f才是generator，func是function类型。</p>
</li>
</ol>
<h2 id="3-协程实现生产者消费者模型"><a href="#3-协程实现生产者消费者模型" class="headerlink" title="3. 协程实现生产者消费者模型"></a>3. 协程实现生产者消费者模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(consumer)</span>:</span></div><div class="line">    ret = next(consumer)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        print(<span class="string">'[PRODUCER] produce: %d'</span> % i)</div><div class="line">        ret = consumer.send(i)</div><div class="line">        print(<span class="string">'[PRODUCER] consumer return: %s'</span> % ret)</div><div class="line">    consumer.close()</div><div class="line"></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></div><div class="line">    ret = <span class="string">''</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        i = <span class="keyword">yield</span> ret</div><div class="line">        print(<span class="string">'[CONSUMER] consume: %d'</span> % i)</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        ret = <span class="string">'OK'</span></div><div class="line">        </div><div class="line">c = consumer()</div><div class="line">producer(c)</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker学习笔记(二)-工具及底层实现]]></title>
      <url>/2018/09/14/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h2><p>Compose 中有两个重要的概念：</p>
<ul>
<li>服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li>
</ul>
<p>命令有点类似docker<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 构建项目中的服务容器</span></div><div class="line">docker-compose build [options] [SERVICE...]</div><div class="line"><span class="comment"># 启动一个service</span></div><div class="line">docker-compose run [options] [-p PORT...] [-e KEY=VAL...] &lt;SERVICE&gt; [COMMAND] [ARGS...]</div><div class="line"><span class="comment"># 启动一个project</span></div><div class="line">docker-compose up</div></pre></td></tr></table></figure></p>
<p>然后是模板文件docker-compose.yml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="string">"3"</span></div><div class="line"></div><div class="line"><span class="attr">services:</span></div><div class="line"><span class="attr">  webapp:</span></div><div class="line"><span class="attr">    image:</span> <span class="string">examples/web</span></div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></div><div class="line"><span class="attr">    volumes:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"/data"</span></div></pre></td></tr></table></figure></p>
<h2 id="Docker-machine"><a href="#Docker-machine" class="headerlink" title="Docker machine"></a>Docker machine</h2><p>Docker machine大概是个用来创建管理虚拟机的工具，当然这些虚拟机都装好了Docker Engine。通过这种方式可以方便地创建多个docker节点。</p>
<blockquote>
<p>Docker Machine is a tool that lets you install Docker Engine on virtual hosts, and manage the hosts with docker-machine commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like Azure, AWS, or Digital Ocean.</p>
</blockquote>
<h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h2><p>用于集群管理的一个工具。</p>
<h3 id="1-创建swarm集群"><a href="#1-创建swarm集群" class="headerlink" title="1.创建swarm集群"></a>1.创建swarm集群</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">docker swarm init --advertise-addr 192.168.99.100</div><div class="line"><span class="comment"># 用machine创建一个worker1节点</span></div><div class="line">docker-machine create -d virtualbox worker1</div><div class="line">docker-machine ssh worker1</div><div class="line"><span class="comment"># 加入swarm集群</span></div><div class="line">docker swarm join \</div><div class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</div><div class="line">    192.168.99.100:2377</div><div class="line">docker node ls</div></pre></td></tr></table></figure>
<h3 id="2-部署服务"><a href="#2-部署服务" class="headerlink" title="2.部署服务"></a>2.部署服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建nginx服务</span></div><div class="line">docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</div><div class="line"><span class="comment"># 查看</span></div><div class="line">docker service ps nginx</div><div class="line">docker service logs nginx</div></pre></td></tr></table></figure>
<h3 id="3-在swarm集群中使用compose来快速部署"><a href="#3-在swarm集群中使用compose来快速部署" class="headerlink" title="3.在swarm集群中使用compose来快速部署"></a>3.在swarm集群中使用compose来快速部署</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose.yml wordpress</div><div class="line">docker stack ls</div><div class="line">docker stack down</div></pre></td></tr></table></figure>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="1-命名空间"><a href="#1-命名空间" class="headerlink" title="1. 命名空间"></a>1. 命名空间</h3><p>命名空间是 Linux内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p>
<h3 id="2-控制组"><a href="#2-控制组" class="headerlink" title="2. 控制组"></a>2. 控制组</h3><p>控制组（cgroups）是Linux内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<h3 id="3-联合文件系统"><a href="#3-联合文件系统" class="headerlink" title="3. 联合文件系统"></a>3. 联合文件系统</h3><p>联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<h3 id="4-网络"><a href="#4-网络" class="headerlink" title="4. 网络"></a>4. 网络</h3><p>Docker 创建一个容器的时候，会执行如下操作：</p>
<ul>
<li>创建一对虚拟接口，分别放到本地主机和新容器中；</li>
<li>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</li>
<li>容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</li>
</ul>
<p>参考：<a href="https://www.kancloud.cn/docker_practice/docker_practice/469861" target="_blank" rel="external">Docker 网络实现</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ学习笔记]]></title>
      <url>/2018/09/13/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt <span class="keyword">install</span> rabbitmq-<span class="keyword">server</span></div></pre></td></tr></table></figure>
<h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a>2. 基本原理</h2><p>一篇比较好的原理介绍文章：<a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="external">消息队列之 RabbitMQ</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5015984-367dd717d89ae5db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554" alt="Rabbit架构图"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5015984-7fd73af768f28704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/484" alt="路由过程"></p>
<p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了。</p>
<p>direct：发送到路由键完全匹配的队列<br>fanout: 发送到所有队列<br>topic: 基于模式，比如route key的usa.news, usa.weather都发送到binding key的usa.#</p>
<p>也可以启动集群，用NODE_NAME来区分。内存节点和磁盘节点，必须有一个磁盘节点。</p>
<h2 id="3-工作队列"><a href="#3-工作队列" class="headerlink" title="3. 工作队列"></a>3. 工作队列</h2><p>带ACK的消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// consume的时候发送ack=false</span></div><div class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</div><div class="line">channel.basicConsume(QUEUE_NAME, autoAck, consumer);</div><div class="line"></div><div class="line"><span class="comment">// 当完成任务后发送ACK</span></div><div class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line"># 以下命令查看未ack的消息</div><div class="line">rabbitmqctl list_queues name message_ready message_unacknowledged</div></pre></td></tr></table></figure></p>
<p>持久化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">channel.queueDeclare(QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</div></pre></td></tr></table></figure></p>
<p>公平调度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果work没有发送ACK，则不再发送新消息</span></div><div class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</div><div class="line">channel.basicQos(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<h2 id="4-发布-订阅模式"><a href="#4-发布-订阅模式" class="headerlink" title="4. 发布/订阅模式"></a>4. 发布/订阅模式</h2><p>Exchange<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明一个exchange，有direct、fanout、topic、headers四种模式</span></div><div class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</div><div class="line"><span class="comment">// publish的时候指定exchange name即可</span></div><div class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</div></pre></td></tr></table></figure></p>
<p>Bindings<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取一个临时队列</span></div><div class="line">String queueName = channel.queueDeclare().getQueue();</div><div class="line"><span class="comment">// 绑定队列到exchange上</span></div><div class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</div><div class="line"></div><div class="line"># 以下命令查看绑定</div><div class="line">rabbitmqctl list_bindings</div></pre></td></tr></table></figure></p>
<h2 id="5-路由"><a href="#5-路由" class="headerlink" title="5. 路由"></a>5. 路由</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</div><div class="line"><span class="comment">// 指定routing key和binding key即可</span></div><div class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">"error"</span>, <span class="keyword">null</span>, message.getBytes());</div><div class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"error"</span>);</div></pre></td></tr></table></figure>
<h2 id="6-topic"><a href="#6-topic" class="headerlink" title="6. topic"></a>6. topic</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">* 代表一个word</div><div class="line"># 代表一个或多个word</div><div class="line">使用上面的两个符号来进行匹配，中间用<span class="string">"."</span>隔开。比如<span class="string">"*.kern.error"</span>。</div><div class="line"></div><div class="line">如果bindingKey=<span class="string">"#"</span>，那就跟fanout模式一样；</div><div class="line">如果bindingKey不包含*或#，那就跟direct一样。</div><div class="line"></div><div class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</div><div class="line">channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, message.getBytes());</div><div class="line">channel.queueBind(queueName, EXCHANGE_NAME, bingingKey);</div></pre></td></tr></table></figure>
<h2 id="7-RPC"><a href="#7-RPC" class="headerlink" title="7. RPC"></a>7. RPC</h2><p>用replyTo和correlationId在两者之间建立联系<br><img src="https://www.rabbitmq.com/img/tutorials/python-six.png" alt="RPC"><br>When the Client starts up, it creates an anonymous exclusive callback queue.<br>For an RPC request, the Client sends a message with two properties: replyTo, which is set to the callback queue and correlationId, which is set to a unique value for every request.<br>The request is sent to an rpc_queue queue.<br>The RPC worker (aka: server) is waiting for requests on that queue. When a request appears, it does the job and sends a message with the result back to the Client, using the queue from the  replyTo field.<br>The client waits for data on the callback queue. When a message appears, it checks the correlationId property. If it matches the value from the request it returns the response to the application.</p>
]]></content>
      
        
        <tags>
            
            <tag> rabbitMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kubernetes学习笔记(三)-网络管理]]></title>
      <url>/2018/09/11/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="1-要点"><a href="#1-要点" class="headerlink" title="1. 要点"></a>1. 要点</h2><p>IP以Pod为单位分配，一个Pod内部的所有容器共享一个网络堆栈。</p>
<p>一个Pod内部的应用程序看到的自己的IP地址和端口与集群内其他Pod看到的一样，它们都是Pod从docker0分配的。</p>
<p>一个pod内的容器可以通过localhost访问另一个容器。</p>
<p>Pod从网络角度来看，可以看做一台独立的“虚拟机”或“物理机”。</p>
<p>docker原生网络通过动态端口映射的方式实现多节点访问，访问者看到额IP地址和端口与服务提供者实际绑定的不同。服务自身很难知道自己对外暴露的真实的服务IP和端口，外部应用也无法通过服务所在容器的私有IP地址和端口来访问服务。</p>
<p>Docker一开始没有考虑到多主机互联的网络解决方案。</p>
<p><strong>当前docker的多主机网络解决方案？？？</strong></p>
<h2 id="2-kubernetes的网络实现"><a href="#2-kubernetes的网络实现" class="headerlink" title="2. kubernetes的网络实现"></a>2. kubernetes的网络实现</h2><p>Service就是一个反向代理。</p>
<ol>
<li>同一pod内容器共享网络空间，可以通过localhost访问</li>
<li>同一node上的不同pod之间通信通过docker0网桥</li>
<li>不同node上的不同pod之间通信需要经过宿主机转发</li>
</ol>
<p><strong>不同Node上的Pod之间的通信要解决两个问题：</strong></p>
<ol>
<li>整个kubernetes集群中对pod的IP分配进行规划，不能有冲突；</li>
<li>找到一种办法，将pod的IP和所在node的IP关联起来，通过这个关联让pod可以互相访问。</li>
</ol>
<p>pod和service之间的通信通过kube-proxy的反向代理。</p>
<p>外部访问service通过NodePort或者LoadBalancer。NodePort模式会在集群的每个Node上打开一个主机上的真实端口号。</p>
<h2 id="3-使用网络组件"><a href="#3-使用网络组件" class="headerlink" title="3. 使用网络组件"></a>3. 使用网络组件</h2><ol>
<li><p>Flannel</p>
<ul>
<li>通过etcd分配不冲突的IP</li>
<li>建立叠加网络</li>
</ul>
</li>
<li><p>Open vSwitch</p>
<ul>
<li>docker0网桥的数据会发给ovs网桥</li>
<li>通过GRE/VxLAN隧道在Node之间传输</li>
</ul>
</li>
<li><p>直接路由<br>可以通过在两个Node之间添加静态路由规则来访问</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在Node1(docker0: 10.1.10.0, eth0: 192.168.1.128)上添加规则</span></div><div class="line">route add -net 10.1.20.0 netmask 255.255.255.0 gw 192.168.1.129</div><div class="line"><span class="comment"># 在Node2(docker0: 10.1.120.1, eth0: 192.168.1.129)上添加规则</span></div><div class="line">route add -net 10.1.10.0 netmask 255.255.255.0 gw 192.168.1.128</div></pre></td></tr></table></figure>
<p>也可以通过Quagga、Zebra等配置动态路由规则，但是还是要提前规划好docker0的IP分配。</p>
<p><strong>DNS跟Monitor官网现在已经更新，这本书上的内容有点过时了。</strong> 可以参考下面文章。</p>
<ul>
<li><a href="https://jimmysong.io/posts/configuring-kubernetes-kube-dns/" target="_blank" rel="external">配置Kubernetes DNS服务kube-dns</a></li>
<li><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/" target="_blank" rel="external">Tools for Monitoring Resources</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kubernetes学习笔记(二)-安全控制]]></title>
      <url>/2018/09/11/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="1-端口问题"><a href="#1-端口问题" class="headerlink" title="1. 端口问题"></a>1. 端口问题</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attr">pod:</span></div><div class="line"><span class="attr"> - containerPort:</span> <span class="string">容器端口</span></div><div class="line"><span class="attr">   hostPort:</span> <span class="string">主机端口</span></div><div class="line"></div><div class="line"><span class="attr">service:</span></div><div class="line"><span class="attr"> - port:</span> <span class="string">监听端口</span></div><div class="line"><span class="attr">   targetPort:</span> <span class="string">转发到pod的端口</span></div><div class="line"><span class="attr">   nodePort:</span><span class="string">&gt;30001</span> <span class="string">外部访问的端口</span></div></pre></td></tr></table></figure>
<h2 id="2-容器健康检查探针"><a href="#2-容器健康检查探针" class="headerlink" title="2. 容器健康检查探针"></a>2. 容器健康检查探针</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">livenessProbe:</span></div><div class="line"><span class="attr">    httpGet:</span></div><div class="line"><span class="attr">        path:</span> <span class="string">/</span></div><div class="line"><span class="attr">        port:</span> <span class="number">9090</span></div><div class="line"><span class="attr">    initialDelaySeconds:</span> <span class="number">30</span></div><div class="line"><span class="attr">    timeoutSeconds:</span> <span class="number">30</span></div></pre></td></tr></table></figure>
<h2 id="3-安全控制"><a href="#3-安全控制" class="headerlink" title="3. 安全控制"></a>3. 安全控制</h2><h3 id="Authentication认证"><a href="#Authentication认证" class="headerlink" title="Authentication认证"></a>Authentication认证</h3><ul>
<li>CA</li>
<li>token</li>
<li>http base64</li>
</ul>
<h3 id="Authorization授权"><a href="#Authorization授权" class="headerlink" title="Authorization授权"></a>Authorization授权</h3><p>通过指定<code>--authorization_policay_file=SOME_FILENAME</code>来确定</p>
<h3 id="Admission-Control准入控制"><a href="#Admission-Control准入控制" class="headerlink" title="Admission Control准入控制"></a>Admission Control准入控制</h3><p>调用这些插件拦截通过上面认证和授权的请求。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">KUBE_ADMISSION_CONTROL</span>=<span class="string">"--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota"</span></div></pre></td></tr></table></figure>
<h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><p>私密信息保存到secret中，可以挂载到pod中。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></div><div class="line"><span class="attr">kind:</span> <span class="string">Secret</span></div><div class="line"><span class="attr">metadata:</span> </div><div class="line"><span class="attr">    name:</span> <span class="string">mysecret</span></div><div class="line"><span class="attr">type:</span></div><div class="line">    <span class="string">Opaque</span></div><div class="line"><span class="attr">data:</span></div><div class="line"><span class="attr">    password:</span> <span class="string">ODgyMAo=</span></div><div class="line"><span class="attr">    username:</span> <span class="string">Y2hhY2UK</span></div></pre></td></tr></table></figure>
<p>包含三种类型：</p>
<ul>
<li>Opaque</li>
<li>kubernetes.io/dockercfg</li>
<li>kubernetes.io/service-account-token</li>
</ul>
<p>Secret有三种使用方式：</p>
<ul>
<li>创建pod时，指定Service Account自动使用该secret<ul>
<li>挂载secret到pod使用</li>
<li>创建pod时，指定pod的spc.ImagePullSecrets来引用它</li>
</ul>
</li>
</ul>
<h3 id="Service-Account"><a href="#Service-Account" class="headerlink" title="Service Account"></a>Service Account</h3><p>Service Account是多个secret的集合。</p>
<ul>
<li>普通secret，用于访问API Secret</li>
<li>imagePullSecret，用于下载镜像</li>
</ul>
<p>在<code>--admission-control=ServiceAccount</code>启用。</p>
<p>除了namespace，也可以通过切换上下文的方式来隔离pod。</p>
]]></content>
      
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kubernetes学习笔记(一)-基础入门]]></title>
      <url>/2018/09/11/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="1-基本术语"><a href="#1-基本术语" class="headerlink" title="1. 基本术语"></a>1. 基本术语</h2><p>Service: 唯一名字，拥有唯一虚拟IP和端口号</p>
<p>Pod: 通过label与service绑定，业务容器、基础设施容器</p>
<p>Node：物理机或者虚拟机</p>
<p>Master Node上运行: kube-apiserver、kube-controller-manager和kube-scheduler</p>
<p>Work Node上运行: kubelet、kube-proxy</p>
<h2 id="2-细节"><a href="#2-细节" class="headerlink" title="2. 细节"></a>2. 细节</h2><h3 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h3><ul>
<li>每个Pod对应一个docker网桥的IP</li>
<li>每个service通过endpoint(dockerIp:port)与select的Pod进行绑定</li>
<li>每个service会分配一个Cluster IP(集群内使用的IP)</li>
<li>service可以通过NodePort或者LoadBalancer对外提供服务</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 外部通过30001访问Pod的80端口</span></div><div class="line"><span class="attr">type:</span> <span class="string">NodePort</span></div><div class="line"><span class="attr">ports:</span></div><div class="line"><span class="attr">    - port:</span> <span class="number">80</span></div><div class="line"><span class="attr">      nodePort:</span> <span class="number">30001</span></div></pre></td></tr></table></figure>
<h3 id="存储部分"><a href="#存储部分" class="headerlink" title="存储部分"></a>存储部分</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将主机上/data定义卷</span></div><div class="line"><span class="attr">volumns:</span></div><div class="line"><span class="attr">    - name:</span> <span class="string">"persistent-storage"</span></div><div class="line"><span class="attr">      hostPath:</span></div><div class="line"><span class="attr">        path:</span> <span class="string">"/data"</span></div><div class="line"><span class="comment"># 挂载到容器内部的/data</span></div><div class="line"><span class="attr">containers:</span></div><div class="line"><span class="attr">    volumeMounts:</span></div><div class="line"><span class="attr">        - name:</span> <span class="string">"persistent-storage"</span></div><div class="line"><span class="attr">          mountPath:</span> <span class="string">"/data"</span></div></pre></td></tr></table></figure>
<h2 id="3-架构与组件"><a href="#3-架构与组件" class="headerlink" title="3. 架构与组件"></a>3. 架构与组件</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Kubernetes.png/600px-Kubernetes.png" alt="基本架构"></p>
<p>API Server: 提供资源对象的唯一操作入口</p>
<p>Controller Manager: 管理控制中心</p>
<p>Scheduler: 调度器</p>
<p>Kubelet: 负责本节点上的Pod的创建、修改等管理，向API Server上报状态信息</p>
<p>Proxy: Service的代理及负载均衡</p>
<h2 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">kubectl get &lt;resource_type&gt; &lt;resource_name&gt;</div><div class="line">kubectl describe &lt;resource_type&gt; &lt;resource _name&gt;</div><div class="line">kubectl scale rc &lt;rc_name&gt; --replicas=&lt;num&gt;</div><div class="line">kubectl create/replace -f &lt;file&gt;</div><div class="line">kubectl label pod &lt;pod_name&gt; &lt;label_name=label_value&gt;</div><div class="line">kubectl rolling-update &lt;rc&gt; --image=&lt;new_image&gt;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker学习笔记(一)-基本操作]]></title>
      <url>/2018/08/27/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p><strong>镜像</strong>：Docker镜像是分层存储的。</p>
<p><strong>容器</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p><strong>仓库</strong>：仓库名经常以<em>两段式路径</em>形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。我们可以通过<em>&lt;仓库名&gt;:&lt;标签&gt;</em>的格式来指定具体是这个软件哪个版本的镜像。</p>
<h2 id="2-镜像"><a href="#2-镜像" class="headerlink" title="2. 镜像"></a>2. 镜像</h2><h3 id="2-1-commit-保存当前容器为镜像"><a href="#2-1-commit-保存当前容器为镜像" class="headerlink" title="2.1 commit 保存当前容器为镜像"></a>2.1 commit 保存当前容器为镜像</h3><p>最好不要用commit来在实际应用中保存镜像。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit [选项] &lt;容器ID或容器名&gt; <span class="meta">[&lt;仓库名&gt;[:&lt;标签&gt;]</span>]</div></pre></td></tr></table></figure></p>
<h3 id="2-2-docker-file"><a href="#2-2-docker-file" class="headerlink" title="2.2 docker file"></a>2.2 docker file</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> 基础镜像</div><div class="line"><span class="builtin-name">RUN</span> 运行命令，最好只有一行 \</div><div class="line">    &amp;&amp; 否则每RUN一次都是一次commit \</div><div class="line">    &amp;&amp; 最后记得清理依赖 \</div><div class="line">    &amp;&amp; apt-<span class="builtin-name">get</span> purge -y --auto-<span class="builtin-name">remove</span> <span class="variable">$buildDeps</span></div></pre></td></tr></table></figure>
<h4 id="2-2-1-构建镜像"><a href="#2-2-1-构建镜像" class="headerlink" title="2.2.1 构建镜像"></a>2.2.1 构建镜像</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">docker</span> <span class="keyword">build </span>[选项] &lt;上下文路径/URL/-&gt;</div><div class="line"></div><div class="line"><span class="symbol">Example</span>:</div><div class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t nginx:<span class="built_in">v3</span> -f Dockerfile .</div></pre></td></tr></table></figure>
<h4 id="2-2-2-构建过程"><a href="#2-2-2-构建过程" class="headerlink" title="2.2.2 构建过程"></a>2.2.2 构建过程</h4><p>当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会<strong>将路径下的所有内容打包</strong>，然后上传给 Docker 引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。可以用<code>.dockerignore</code>文件指定忽略哪些文件，否则就是打包所有文件。</p>
<h4 id="2-2-3-其余命令"><a href="#2-2-3-其余命令" class="headerlink" title="2.2.3 其余命令"></a>2.2.3 其余命令</h4><p><strong>COPY</strong><br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">COPY</span><span class="bash"> &lt;源路径&gt;... &lt;目标路径&gt;</span></div><div class="line"><span class="bash">COPY [<span class="string">"&lt;源路径1&gt;"</span>,... <span class="string">"&lt;目标路径&gt;"</span>]</span></div></pre></td></tr></table></figure></p>
<p><strong>CMD</strong><br>用于指定默认的容器主进程的启动命令。比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMD</span><span class="bash"> &lt;命令&gt;</span></div><div class="line"><span class="bash">CMD [<span class="string">"可执行文件"</span>, <span class="string">"参数1"</span>, <span class="string">"参数2"</span>...]</span></div><div class="line"><span class="bash">在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</span></div></pre></td></tr></table></figure></p>
<p><strong>ENV</strong><br>环境变量<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV <span class="tag">&lt;<span class="name">key</span>&gt;</span> <span class="tag">&lt;<span class="name">value</span>&gt;</span></div><div class="line">ENV <span class="tag">&lt;<span class="name">key1</span>&gt;</span>=<span class="tag">&lt;<span class="name">value1</span>&gt;</span> <span class="tag">&lt;<span class="name">key2</span>&gt;</span>=<span class="tag">&lt;<span class="name">value2</span>&gt;</span>...</div></pre></td></tr></table></figure></p>
<p><strong>其他</strong><br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># run时运行这个文件</span></div><div class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [] </span></div><div class="line"><span class="bash"><span class="comment"># 挂载主机卷</span></span></div><div class="line"><span class="bash">VOLUME [<span class="string">"&lt;主机路径&gt;"</span>, <span class="string">"&lt;容器路径&gt;"</span>...]</span></div><div class="line"><span class="bash"><span class="comment"># 工作目录</span></span></div><div class="line"><span class="bash">WORKDIR &lt;工作目录路径&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="2-3-多阶段构建"><a href="#2-3-多阶段构建" class="headerlink" title="2.3 多阶段构建"></a>2.3 多阶段构建</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置阶段构建目标</span></div><div class="line">FROM golang<span class="function">:1.9-alpine</span> as builder</div><div class="line"></div><div class="line"><span class="comment"># build指定构建目标</span></div><div class="line">docker build <span class="params">--target</span> builder -t username/imagename<span class="function">:tag</span> .</div><div class="line"></div><div class="line"><span class="comment"># 从构建目标拷贝文件</span></div><div class="line">COPY <span class="params">--from=builder</span> <span class="string">/etc/nginx/nginx.conf</span> <span class="string">/nginx.conf</span></div></pre></td></tr></table></figure>
<h2 id="3-操作容器"><a href="#3-操作容器" class="headerlink" title="3. 操作容器"></a>3. 操作容器</h2><h3 id="3-1-run"><a href="#3-1-run" class="headerlink" title="3.1 run"></a>3.1 run</h3><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载<br>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 运行docker容器并交互式运行/bin/bash</span></div><div class="line">docker run -ti ubuntu:14.04 /bin/bash</div><div class="line"><span class="meta">#</span><span class="bash"> 进入正在运行的docker容器</span></div><div class="line">docker exec -ti &lt;container id&gt; CMD</div><div class="line"><span class="meta">#</span><span class="bash"> 日志，-f是</span></div><div class="line">docker logs -f &lt;container id&gt;</div><div class="line"><span class="meta">#</span><span class="bash"> 导入/导出</span></div><div class="line">docker export &lt;container id&gt; &gt; xxx.tar.gz</div><div class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</div><div class="line"><span class="meta">#</span><span class="bash"> 保留历史信息</span></div><div class="line">docker load</div><div class="line">docker save</div><div class="line"><span class="meta">#</span><span class="bash"> 删除容器</span></div><div class="line">docker container rm &lt;container id&gt;</div><div class="line"><span class="meta">#</span><span class="bash"> 删除镜像</span></div><div class="line">docker rm &lt;镜像&gt;</div></pre></td></tr></table></figure>
<h2 id="4-操作仓库"><a href="#4-操作仓库" class="headerlink" title="4. 操作仓库"></a>4. 操作仓库</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker search xxx</div><div class="line">docker pull xxx</div><div class="line">docker push docker<span class="selector-class">.domain</span><span class="selector-class">.com</span>/username/ubuntu:<span class="number">18.04</span></div></pre></td></tr></table></figure>
<h3 id="自建仓库"><a href="#自建仓库" class="headerlink" title="自建仓库"></a>自建仓库</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在5000端口启动一个仓库</span></div><div class="line">docker <span class="builtin-name">run</span> -d -p 5000:5000 <span class="attribute">--restart</span>=always --name registry registry</div></pre></td></tr></table></figure>
<h3 id="Nexus3"><a href="#Nexus3" class="headerlink" title="Nexus3"></a>Nexus3</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker <span class="builtin-name">run</span> -d --name nexus3 <span class="attribute">--restart</span>=always \</div><div class="line">    -p 8081:8081 \</div><div class="line">    --mount <span class="attribute">src</span>=nexus-data,target=/nexus-data \</div><div class="line">    sonatype/nexus3</div></pre></td></tr></table></figure>
<h2 id="5-数据存储"><a href="#5-数据存储" class="headerlink" title="5. 数据存储"></a>5. 数据存储</h2><h3 id="5-1-数据卷"><a href="#5-1-数据卷" class="headerlink" title="5.1 数据卷"></a>5.1 数据卷</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录。与容器独立。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 创建一个名为my-vol的数据卷</span></div><div class="line"><span class="meta">$</span><span class="bash"> docker volume create my-vol</span></div><div class="line"><span class="meta">#</span><span class="bash"> 查看所有数据卷</span></div><div class="line"><span class="meta">$</span><span class="bash"> docker volume ls</span></div><div class="line"><span class="meta">#</span><span class="bash"> 启动时加上--mount挂载数据卷</span></div><div class="line">--mount source=my-vol,target=/webapp \</div></pre></td></tr></table></figure></p>
<h3 id="5-2-挂载主机目录"><a href="#5-2-挂载主机目录" class="headerlink" title="5.2 挂载主机目录"></a>5.2 挂载主机目录</h3><p>使用 –mount 标记可以指定挂载一个本地主机的目录到容器中去。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 加载主机的 <span class="regexp">/src/</span>webapp 目录到容器的 <span class="regexp">/opt/</span>webapp目录</div><div class="line">--mount type=bind,<span class="keyword">source</span>=<span class="regexp">/src/</span>webapp,target=<span class="regexp">/opt/</span>webapp</div></pre></td></tr></table></figure></p>
<h3 id="5-3-v和–mount的区别"><a href="#5-3-v和–mount的区别" class="headerlink" title="5.3 -v和–mount的区别"></a>5.3 -v和–mount的区别</h3><p>两者的区别在于，-v将所有选项组合在一个字段中，–mount 则将它们分开。可以参考：<a href="https://deepzz.com/post/the-docker-volumes-basic.html" target="_blank" rel="external">docker volume容器卷的那些事</a></p>
<h2 id="6-容器网络"><a href="#6-容器网络" class="headerlink" title="6. 容器网络"></a>6. 容器网络</h2><h3 id="6-1-原理"><a href="#6-1-原理" class="headerlink" title="6.1 原理"></a>6.1 原理</h3><p>当 Docker 启动时，会自动在主机上创建一个docker0虚拟网桥，实际上是Linux的一个bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0接口。比如典型的172.17.42.1，掩码为255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。</p>
<p><img src="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/_images/network.png" alt="docker网络"></p>
<h3 id="6-2-docker内网"><a href="#6-2-docker内网" class="headerlink" title="6.2 docker内网"></a>6.2 docker内网</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个docker网络</span></div><div class="line">$ docker<span class="built_in"> network </span>create -d<span class="built_in"> bridge </span>my-net</div><div class="line"><span class="comment"># 加入docker网络</span></div><div class="line">$ docker <span class="builtin-name">run</span> -it --rm --name busybox1 --network my-net busybox sh</div></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="external">Docker — 从入门到实践</a><br>上面太慢可以看这个：[Docker — 从入门到实践-看云]<a href="https://www.kancloud.cn/docker_practice/docker_practice" target="_blank" rel="external">https://www.kancloud.cn/docker_practice/docker_practice</a></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现多元线性回归的最小二乘法拟合]]></title>
      <url>/2018/04/15/Python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E6%8B%9F%E5%90%88/</url>
      <content type="html"><![CDATA[<p>最近用到了多元线性回归，因为不能调库，所以手动实现了一下，其实最麻烦的还是在矩阵操作上面。</p>
<h1 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h1><p>多元线性回归定义如下：<br><img src="/img/2018/04/多元线性回归.png" alt="多元线性回归"><br><img src="/img/2018/04/多元线性回归矩阵.png" alt="多元线性回归矩阵"></p>
<p><strong>多元线性回归的拟合一般使用最小二乘法，所谓最小二乘法即是使得残差平方和最小来求参数估计量的一种方法。</strong>如下图所示：<br><img src="/img/2018/04/最小二乘法.png" alt="最小二乘法"></p>
<p><strong>上图和下图说的都是满秩矩阵的情况，也就是说数据条数要大于等于数据特征数。大部分情况下应该都是满秩矩阵，但是在样本少、特征数多的情况下，就会出现奇异矩阵的情况。</strong></p>
<p>推导过程如下：<br><img src="/img/2018/04/最小二乘法矩阵推导.png" alt="最小二乘法的矩阵形式推导"></p>
<h1 id="封装的矩阵操作"><a href="#封装的矩阵操作" class="headerlink" title="封装的矩阵操作"></a>封装的矩阵操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding=utf8</span></div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div><div class="line"><span class="keyword">import</span> copy</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_to_matrix</span><span class="params">(l)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    列表转变为1*n矩阵</span></div><div class="line"><span class="string">    :param l: list</span></div><div class="line"><span class="string">    :return: 矩阵</span></div><div class="line"><span class="string">    """</span></div><div class="line">    m = [l]</div><div class="line">    <span class="keyword">return</span> m</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse</span><span class="params">(matrix)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    矩阵高斯消元法求逆</span></div><div class="line"><span class="string">    :param matrix: </span></div><div class="line"><span class="string">    :return: 逆矩阵</span></div><div class="line"><span class="string">    """</span></div><div class="line">    extend_matrix = copy.deepcopy(matrix)</div><div class="line">    l = len(matrix)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, l):    <span class="comment"># 在矩阵右边补充一个单位矩阵，使用初等变换求逆矩阵</span></div><div class="line">        extend_matrix[i].extend([<span class="number">0</span>]*i)</div><div class="line">        extend_matrix[i].extend([<span class="number">1</span>])</div><div class="line">        extend_matrix[i].extend([<span class="number">0</span>]*(l-i<span class="number">-1</span>))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(extend_matrix)):    <span class="comment"># 判断矩阵对角线上是否有0，有0则置换，如置换不了，则没有逆矩阵</span></div><div class="line">        <span class="keyword">if</span> extend_matrix[i][i] == <span class="number">0</span>:</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(extend_matrix)):</div><div class="line">                <span class="keyword">if</span> extend_matrix[j][i] != <span class="number">0</span>:  <span class="comment"># 进行行交换</span></div><div class="line">                    extend_matrix[i], extend_matrix[j] = extend_matrix[j], extend_matrix[i]</div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> j &gt;= len(extend_matrix)<span class="number">-1</span>:</div><div class="line">                print(<span class="string">'没有逆矩阵'</span>)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span></div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(extend_matrix)):    <span class="comment"># 开始计算逆矩阵</span></div><div class="line">        f = extend_matrix[i][i]</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(extend_matrix[i])):    <span class="comment"># 先把对角元素换为1</span></div><div class="line">            extend_matrix[i][j] /= f</div><div class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>, len(extend_matrix)):</div><div class="line">            <span class="keyword">if</span> m == i:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            b = extend_matrix[m][i]</div><div class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, len(extend_matrix[i])):    <span class="comment"># 再把对角元素所在列的其余元素换为0</span></div><div class="line">                extend_matrix[m][n] -= extend_matrix[i][n] * b</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(extend_matrix)):</div><div class="line">        extend_matrix[i] = extend_matrix[i][l:]</div><div class="line">    <span class="keyword">return</span> extend_matrix</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(matrix)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    矩阵转置</span></div><div class="line"><span class="string">    :param matrix: </span></div><div class="line"><span class="string">    :return: </span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">return</span> list(map(list, zip(*matrix)))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dot</span><span class="params">(A, B)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    矩阵乘法</span></div><div class="line"><span class="string">    :param A: </span></div><div class="line"><span class="string">    :param B: </span></div><div class="line"><span class="string">    :return: </span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">return</span> [[sum(x*y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b)) <span class="keyword">for</span> b <span class="keyword">in</span> zip(*B)] <span class="keyword">for</span> a <span class="keyword">in</span> A]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(matrix)</span>:</span></div><div class="line">    <span class="keyword">return</span> len(matrix), len(matrix[<span class="number">0</span>])</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_intercept</span><span class="params">(matrix)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    在矩阵的第一列插入全为1的一列</span></div><div class="line"><span class="string">    :param matrix: 待插入矩阵</span></div><div class="line"><span class="string">    :return: 新的矩阵</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</div><div class="line">        row.insert(<span class="number">0</span>, <span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> matrix</div></pre></td></tr></table></figure>
<h1 id="最小二乘法实现"><a href="#最小二乘法实现" class="headerlink" title="最小二乘法实现"></a>最小二乘法实现</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line">import matrix</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="comment"># param保存估计参数</span></div><div class="line">        <span class="keyword">self</span>.param = matrix.list_to_matrix([])</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(<span class="keyword">self</span>, X, y)</span></span><span class="symbol">:</span></div><div class="line">        <span class="comment"># 在最后添加一列1</span></div><div class="line">        X = matrix.add_intercept(X)</div><div class="line">        X_T = matrix.transpose(X)</div><div class="line">        <span class="comment"># 最小二乘法估计参数</span></div><div class="line">        <span class="keyword">self</span>.param = matrix.dot(matrix.dot(matrix.inverse(matrix.dot(X_T, X)), X_T), y)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(<span class="keyword">self</span>, X)</span></span><span class="symbol">:</span></div><div class="line">        X = matrix.add_intercept(X)</div><div class="line">        result = matrix.dot(X, <span class="keyword">self</span>.param)</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h1 id="非线性回归"><a href="#非线性回归" class="headerlink" title="非线性回归"></a>非线性回归</h1><p>一些特殊的非线性模型可以线性化，比如“对数线性回归”。</p>
<p>另一类是多项式回归模型，可以通过转变原特征的方式转换为多元线性回归。比如，对于一元多项式回归，就可通过下图所示方式转变为普通的多元线性回归模型，其中X是一个<a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E5%BE%B7%E8%92%99%E7%9F%A9%E9%99%A3" target="_blank" rel="external">范德蒙德矩阵</a>。<br><img src="/img/2018/04/一元多项式回归.png" alt="一元多项式回归"></p>
<p>对于更一般的多元多项式回归，则需要通过将原特征转变为多项式特征的方式。在sklearn中，可以使用<a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html" target="_blank" rel="external">PolynomialFeatures</a>将原特征矩阵转变为多项式特征矩阵。</p>
<p>多项式回归比线性回归具有更好的拟合效果，但是也会带来一些问题。首先是多项式特征矩阵的维度将会随着最高次数的增加急剧上升，从而导致矩阵不可逆。这个时候可以使用<strong>广义逆矩阵</strong>进行求解，解的公式与上文的公式略有不同，详见<strong>参考资料1</strong>。多项式最高次数增加带来的另一个问题是过拟合，这个问题笔者还未做研究，故暂且搁置不提。</p>
<p>另一方面，对于多项式回归问题，因为上述的问题，放弃最小二乘，转而使用<a href="https://en.wikipedia.org/wiki/Tikhonov_regularization" target="_blank" rel="external">岭回归</a>可能效果更好。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><strong>理论</strong></p>
<ol>
<li><a href="http://read.pudn.com/downloads164/ebook/750809/chapter2.pdf" target="_blank" rel="external">一般多元线性回归模型</a></li>
<li><a href="http://www.cnblogs.com/zgw21cn/archive/2008/12/24/1361287.html" target="_blank" rel="external">多元线性回归</a></li>
</ol>
<p><strong>实践</strong></p>
<ol>
<li><a href="https://segmentfault.com/q/1010000006120590/a-1020000006120650" target="_blank" rel="external">Python计算大矩阵的逆的精度问题？</a></li>
<li><a href="http://www.sharejs.com/codes/python/7414" target="_blank" rel="external">Python LU 分解</a></li>
<li><a href="http://www.cnblogs.com/lc1217/p/6829319.html" target="_blank" rel="external">机器学习：scipy和sklearn中普通最小二乘法与多项式回归的使用</a></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Time Series Classification with LSTM in Keras]]></title>
      <url>/2018/03/07/Time%20Series%20Multi-Class%20Classification%20with%20LSTM%20in%20Keras/</url>
      <content type="html"><![CDATA[<p>本文总结一下最近在项目中学到的一些东西。</p>
<p>其实在抽象问题上花了很多时间，抽象出来问题其实也很简单：</p>
<p>已知一个时序序列，序列中的每个元素本身就是一个label。</p>
<ol>
<li>预测序列下一个元素；</li>
<li>取概率最高的元素，如果预测的label与真实的label一致，认为序列正常；否则序列出现异常。</li>
</ol>
<p>这样问题的描述也就很清楚了。1是一个序列预测多分类问题，2是一个序列异常判断二分类问题。</p>
<h1 id="1-序列预测多分类问题"><a href="#1-序列预测多分类问题" class="headerlink" title="1. 序列预测多分类问题"></a>1. 序列预测多分类问题</h1><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>因为LSTM在处理序列问题上有很好效果，所以使用两层LSTM，最后加一个全连接层作为输出层，激活函数选择softmax。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">model = Sequential()</div><div class="line">model.<span class="builtin-name">add</span>(LSTM(64, input_shape=(timesteps, input_dim), <span class="attribute">return_sequences</span>=<span class="literal">True</span>))</div><div class="line">model.<span class="builtin-name">add</span>(LSTM(64))</div><div class="line">model.<span class="builtin-name">add</span>(Dense(output_dim, <span class="attribute">activation</span>=<span class="string">'softmax'</span>))</div></pre></td></tr></table></figure>
<h2 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h2><p>需要对原始数据进行编码处理，首先使用LabelEncoder将label转换为integer，然后使用np_utils.to_categorical()转换为one-hot编码。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 进行one-hot编码</span></div><div class="line">encoder = LabelEncoder()</div><div class="line">encoder.fit(train_Y)</div><div class="line">encoded_Y = encoder.transform(train_Y)</div><div class="line">train_Y = np_utils.to_categorical(encoded_Y)</div></pre></td></tr></table></figure>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用训练数据训练模型</span></div><div class="line">model.compile<span class="params">(<span class="attr">loss</span>='categorical_crossentropy', <span class="attr">optimizer</span>='rmsprop', <span class="attr">metrics</span>=['accuracy'])</span></div><div class="line">model.fit<span class="params">(X, Y, <span class="attr">batch_size</span>=5, <span class="attr">epochs</span>=100, <span class="attr">verbose</span>=1)</span></div></pre></td></tr></table></figure>
<h2 id="评估阶段"><a href="#评估阶段" class="headerlink" title="评估阶段"></a>评估阶段</h2><p>多分类问题使用macro-P/macro-R/macro-F1评估。</p>
<p>本来打算使用KFold进行交叉验证的，但是报错：<code>ValueError: Classification metrics can&#39;t handle a mix of multilabel-indicator and multiclass targets</code>。</p>
<p>确实，对于sample进行了one-hot编码后Classifier认为是multilabel问题，但真正的label只有一个。但是封装的API里面并不能one-hot编码decode回来，所以只好手动划分训练集和验证集。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 预测label</span></div><div class="line"><span class="attr">predict_dummy_y</span> = model.predict(test_x, verbose=<span class="number">0</span>)</div><div class="line"><span class="attr">predict_y</span> = encoder.inverse_transform(numpy.argmax(predict_dummy_y))</div></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 模型效果评估</span></div><div class="line"><span class="attr">precision</span> = precision_score(test_Y, predict_Y, average=<span class="string">'macro'</span>)</div><div class="line"><span class="attr">recall</span> = recall_score(test_Y, predict_Y, average=<span class="string">'macro'</span>)</div><div class="line"><span class="attr">f1</span> = f1_score(test_Y, predict_Y, average=<span class="string">'macro'</span>)</div></pre></td></tr></table></figure>
<h1 id="2-序列异常判断二分类问题（未完善）"><a href="#2-序列异常判断二分类问题（未完善）" class="headerlink" title="2. 序列异常判断二分类问题（未完善）"></a>2. 序列异常判断二分类问题（未完善）</h1><p>因为缺乏标注数据，验证阶段没法进行。当然，如果认为原来的序列是完全正常的，这样可以用recall=TP/(TP+FN)计算recall。</p>
<p>在1中可以得到预测label的概率分布，直接进行评估即可。</p>
<h2 id="评估阶段-1"><a href="#评估阶段-1" class="headerlink" title="评估阶段"></a>评估阶段</h2><p>如前所述，只能计算recall。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在预测时记录TP的情况</span></div><div class="line"><span class="keyword">if</span> <span class="attr">predict_y</span> == test_y:</div><div class="line">    predict_Y.append(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 计算recall</span></div><div class="line"><span class="attr">recall_abnormal</span> = len(predict_Y)/len(test_Y)</div></pre></td></tr></table></figure>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://machinelearningmastery.com/time-series-forecasting-long-short-term-memory-network-python/" target="_blank" rel="external">Time Series Forecasting with the Long Short-Term Memory Network in Python</a></li>
<li><a href="https://machinelearningmastery.com/multi-class-classification-tutorial-keras-deep-learning-library/" target="_blank" rel="external">Multi-Class Classification Tutorial with the Keras Deep Learning Library</a></li>
<li><a href="https://cnbeining.github.io/deep-learning-with-python-cn/3-multi-layer-perceptrons/ch9-use-keras-models-with-scikit-learn-for-general-machine-learning.html" target="_blank" rel="external">使用Scikit-Learn调用Keras的模型</a></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现Trie和AC自动机]]></title>
      <url>/2017/11/12/Python%E5%AE%9E%E7%8E%B0Trie%E5%92%8CAC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>上课的时候，其中一个task需要用前缀结构来降低空间开销，同时为了满足查找的需要，要用到AC自动机，因此接触了这两个数据结构。</p>
<p>本文只是对这两个知识点的Note，并没有太多原创的东西。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>字典树(Trie)是一种前缀结构，每个节点值是一个字符，从根节点到某节点所经过的所有节点值即代表了该节点保存的字符串，因此具有相同前缀的字符串不会重复保存前缀，只会保存一次，因此可以节省空间开销且查找速度极快。<strong>字典树为了保证效率，适合节点值集合较小（如英文的26个字母）且前缀较多的符号集（中英文文章都满足这两个要求）</strong>。我做的task为了满足这两个要求，需要做一些特殊处理。</p>
<p>AC自动机(Aho-Corasick Automaton)其实可以看做状态转移矩阵，主要用于多模式匹配。其在字典树的基础上增加了一个fail指针，指向叶子节点的最长后缀。在匹配的过程中，当匹配到叶子节点的时候，会跳转到叶子节点的最长后缀继续匹配，这样就可以节省一部分回溯的时间。</p>
<p>原理及详细介绍可以阅读本文后的参考文献或者原始论文，本文不再赘述。</p>
<h2 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h2><p>在建立字典树的过程中，我们使用Python中的dict结构来保存节点值和子节点的链接关系，即在节点的children域中保存的是该节点所有的子节点。即node.chidren={child_node_value1: child_node1, child_node_value2:child_node2,…}。</p>
<p>因为dict结构的内部实现使用的是hash表，相对于使用左孩子右兄弟表示树的方式，dict嵌套表示树的方式在查找插入的时候效率更高。当然，hash是用空间换时间，空间开销自然就会上升。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">import copy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.value = None</div><div class="line">        <span class="keyword">self</span>.fail = None  <span class="comment"># fail指针是构造AC自动机的关键</span></div><div class="line">        <span class="keyword">self</span>.children = &#123;&#125;  <span class="comment"># dict &#123;value: node&#125;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.root = Node()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(<span class="keyword">self</span>, data)</span></span><span class="symbol">:</span></div><div class="line">        current = <span class="keyword">self</span>.root</div><div class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="symbol">data:</span></div><div class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> current.<span class="symbol">children:</span></div><div class="line">                child = Node()</div><div class="line">                child.value = s</div><div class="line">                current.children[s] = child</div><div class="line">                current = child</div><div class="line">            <span class="symbol">else:</span></div><div class="line">                current = current.children.get(s)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_ac_automation</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        queue = [<span class="keyword">self</span>.root]</div><div class="line">        <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span><span class="symbol">:</span></div><div class="line">            <span class="comment"># 本质上来说是层次遍历</span></div><div class="line">            temp = queue.pop()</div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> temp.<span class="symbol">children:</span></div><div class="line">                <span class="keyword">if</span> temp == <span class="keyword">self</span>.<span class="symbol">root:</span></div><div class="line">                    <span class="comment"># 第一层节点的fail指向root</span></div><div class="line">                    temp.children[k].fail = <span class="keyword">self</span>.root</div><div class="line">                <span class="symbol">else:</span></div><div class="line">                    p = temp.fail</div><div class="line">                    <span class="keyword">while</span> p is <span class="keyword">not</span> <span class="symbol">None:</span></div><div class="line">                        <span class="comment"># p==None即代表找到了root</span></div><div class="line">                        <span class="keyword">if</span> k <span class="keyword">in</span> p.<span class="symbol">children:</span></div><div class="line">                            <span class="comment"># 如果在当前节点的fail指针指向的节点的子节点中找到了k</span></div><div class="line">                            temp.children[k].fail = p.children[k]</div><div class="line">                            <span class="keyword">break</span></div><div class="line">                        <span class="comment"># 没有找到则继续沿着fail指针回溯找</span></div><div class="line">                        p = p.fail</div><div class="line">                    <span class="keyword">if</span> p is <span class="symbol">None:</span></div><div class="line">                        <span class="comment"># 将k的fail指针指向root</span></div><div class="line">                        temp.children[k].fail = <span class="keyword">self</span>.root</div><div class="line">                <span class="comment"># 将子节点加进队列</span></div><div class="line">                queue.append(temp.children[k])</div></pre></td></tr></table></figure>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://www.cnblogs.com/en-heng/p/5247903.html" target="_blank" rel="external">【模式匹配】Aho-Corasick自动机</a></li>
<li><a href="http://chuxiuhong.com/2016/12/14/%E5%9F%BA%E4%BA%8Etrie%E6%A0%91%E5%81%9A%E4%B8%80%E4%B8%AAac%E8%87%AA%E5%8A%A8%E6%9C%BA/" target="_blank" rel="external">基于trie树做一个ac自动机</a></li>
<li><a href="https://www.ctolib.com/topics-106266.html" target="_blank" rel="external">Python3实现AC自动机</a></li>
<li>Aho, Alfred V., and Margaret J. Corasick. “Efficient string matching: an aid to bibliographic search.” Communications of the ACM 18.6 (1975): 333-340.</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Shadowsocks install&config]]></title>
      <url>/2017/11/04/shadowsocks_config/</url>
      <content type="html"><![CDATA[<p>Please install Python at first.</p>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p><code>pip install shadowsocks</code></p>
<h2 id="write-config-file"><a href="#write-config-file" class="headerlink" title="write config file:"></a>write config file:</h2><p>(I am in <code>~/shadowsocks/config.json</code>)<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</div><div class="line"> <span class="attr">"server_port"</span>:<span class="number">8388</span>,</div><div class="line"> <span class="attr">"local_port"</span>:<span class="number">1080</span>,</div><div class="line"> <span class="attr">"password"</span>:<span class="string">"shadowsocks"</span>,</div><div class="line"> <span class="attr">"timeout"</span>:<span class="number">600</span>,</div><div class="line"> <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="start"><a href="#start" class="headerlink" title="start:"></a>start:</h2><p><code>ssserver -c ~/shadowsocks/config.json</code></p>
<h2 id="start-in-background"><a href="#start-in-background" class="headerlink" title="start in background:"></a>start in background:</h2><p><code>ssserver -c ~/config.json -d</code></p>
]]></content>
      
        
        <tags>
            
            <tag> tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fluent Python(5)——函数装饰器和闭包]]></title>
      <url>/2017/10/13/Fluent%20Python(5)%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>这一章主要介绍的是Python中的装饰器，装饰器有两大特性：</p>
<ol>
<li>把被装饰的函数替换成其他函数；</li>
<li><strong>装饰器在加载模块时立即执行</strong></li>
</ol>
<p>即函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。</p>
<p>Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量，所以这一点必须要小心。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数能访问定义体之外定义的非全局变量。</p>
<p>另一个术语是自由变量(free variable)。<a href="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables" target="_blank" rel="external">wiki的定义</a>是这样的：</p>
<blockquote>
<p>In computer programming, the term free variable refers to variables used in a function that are neither local variables nor parameters of that function. The term non-local variable is often a synonym in this context.</p>
</blockquote>
<p>通俗来说，也就是未在本地作用域中绑定的变量。</p>
<p>自由变量可以隐式定义，也可以使用<code>nolocal</code>关键字显示定义，避免出现上面说的因为在函数定义体中赋值导致变量成为局部变量的情况。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器从本质上就是返回一个装饰后的新的函数。</p>
<p>标准库中的<code>functools.lru_cache(maxsize=128, typed=True)</code>实现缓存经常被调用的函数返回结果，在递归中使用地会比较多。</p>
<p>另外，<code>functools.singledispatch</code>可以实现泛函数。</p>
<p>如果是带有参数的装饰器，要设计到三层的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># clock是参数化装饰器工厂函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(*deco_args)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*func_args)</span>:</span></div><div class="line">            result = func(*func_args)</div><div class="line">            <span class="keyword">return</span> result <span class="comment"># 返回原本func运行的结果</span></div><div class="line">        <span class="keyword">return</span> clocked <span class="comment"># 返回func被装饰后的函数clocked</span></div><div class="line">    <span class="keyword">return</span> decorate <span class="comment"># 返回真正的装饰函数</span></div></pre></td></tr></table></figure></p>
<p>这个比较复杂，有些是用class而不是function来实现的，参见拓展阅读。有时间再看一下。</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul>
<li><a href="http://effbot.org/zone/closure.html" target="_blank" rel="external">Closures in Python</a></li>
<li><a href="https://github.com/GrahamDumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md" target="_blank" rel="external">How you implemented your Python decorator is wrong</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python生成随机字符串]]></title>
      <url>/2017/10/07/Python%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>写这篇文章的起因是在看微信JS接口demo的Python版本时，看到了一种生成随机字符串的方式，于是在V2EX上写了一个讨论：<a href="https://www.v2ex.com/t/394944#reply16" target="_blank" rel="external">Python生成一段随机字符串的两种写法</a>。这里是对那个讨论的小结。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 方法1</span></div><div class="line">s1 = <span class="string">''</span>.join(<span class="built_in">random</span>.choice(<span class="built_in">string</span>.ascii_letters + <span class="built_in">string</span>.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>))</div><div class="line"></div><div class="line"><span class="meta"># 方法2</span></div><div class="line">s2 = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    s2 += <span class="built_in">random</span>.choice(<span class="built_in">string</span>.ascii_letters + <span class="built_in">string</span>.digits)</div><div class="line"></div><div class="line"><span class="meta"># 方法3</span></div><div class="line">s3 = <span class="string">''</span>.join(<span class="built_in">random</span>.choices(<span class="built_in">string</span>.ascii_letters + <span class="built_in">string</span>.digits, k=<span class="number">10</span>))</div><div class="line"></div><div class="line"><span class="meta"># 方法4</span></div><div class="line">s4 = binascii.hexlify(os.urandom(<span class="number">5</span>)).decode()</div><div class="line"></div><div class="line"><span class="meta"># 方法5</span></div><div class="line">s5 = secrets.token_urlsafe(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>下面是对这几种方法的对比：</p>
<p><strong>速度上来讲，方法4是最快的</strong></p>
<p>random.choice()和random.choices()底层都是C语言实现。但是因为choice每次只是生成一个随机字符，如果要生成长字符串，需要反复调用Python的函数，导致速度很慢，而choices是一次生成一个k长度的随机字符串，Python代码调用的少，所以速度要快。详情参考附录2。</p>
<p>然而os.random()内部实现是直接调用的syscall(such as /dev/urandom on Unix or CryptGenRandom on Windows)，所以速度最快。详情参考附录3。</p>
<p><strong>方便程度来讲，方法5是最好的</strong></p>
<p>secrets模块从Python 3.6引入，目的是为了实现生成用于加密的随机字符串。</p>
<p>对于secrets模块和原理的random模块，官方文档的说明是这样的：In particularly, secrets should be used in preference to the default pseudo-random number generator in the random module, which is designed for modelling and simulation, not security or cryptography.详情参见附录4.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.v2ex.com/t/394944#reply16" target="_blank" rel="external">Python生成一段随机字符串的两种写法</a></li>
<li><a href="https://hg.python.org/cpython/file/tip/Lib/random.py#l252" target="_blank" rel="external">random模块源码</a></li>
<li><a href="https://docs.python.org/3/library/os.html?highlight=os%20urandom#os.urandom" target="_blank" rel="external">os.urandom文档</a></li>
<li><a href="https://docs.python.org/3/library/secrets.html" target="_blank" rel="external">secrets模块文档</a></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fluent Python(4)——一等函数]]></title>
      <url>/2017/09/28/Fluent%20Python(4)%E2%80%94%E2%80%94%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>可调用对象：在自定义的类Cls中实现<strong>call</strong>()方法即可直接使用cls()调用。</p>
<p>获取关于函数参数的信息：sig=inspect.signature(func)可以查看函数参数的一些信息，还可以使用sig.bind(**args)绑定参数。</p>
<p>函数可以添加注解，虽然并不会被用到，但是可以增加函数的可读性。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> func(<span class="string">parm:</span>str, <span class="string">len:</span> <span class="string">'int &gt; 0'</span>=<span class="number">80</span>) -&gt; <span class="string">str:</span></div><div class="line">    <span class="keyword">return</span> parm</div></pre></td></tr></table></figure></p>
<h3 id="operator模块的函数支持函数式编程"><a href="#operator模块的函数支持函数式编程" class="headerlink" title="operator模块的函数支持函数式编程"></a>operator模块的函数支持函数式编程</h3><p>itemgetter 获取元素<br>attrgetter 获取对象的属性<br>methodcaller(‘replace’,’ ‘, ‘_’) 在对象上调用参数指定的方法<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from operator import itemgetter</div><div class="line">odd=itemgetter<span class="comment">(0,2,4)</span></div><div class="line">odd<span class="comment">(range(10)</span>)</div><div class="line"><span class="attr"># Out[10</span>]: <span class="comment">(0, 2, 4)</span></div></pre></td></tr></table></figure></p>
<h3 id="functools-partial可以绑定一些参数。"><a href="#functools-partial可以绑定一些参数。" class="headerlink" title="functools.partial可以绑定一些参数。"></a>functools.partial可以绑定一些参数。</h3><p>以下就是定义了一个nfc函数，不用每次都输入NFC这个参数了。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> unicodedata, functools</div><div class="line"><span class="built_in">nfc</span> = functools.partial(unicodedata.normalize, <span class="string">'NFC'</span>)</div><div class="line">s=<span class="string">'你好'</span></div><div class="line"><span class="built_in">nfc</span>(s)</div><div class="line"># Out[<span class="number">15</span>]: <span class="string">'你好'</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fluent Python(3)——文本和字节序列]]></title>
      <url>/2017/09/25/Fluent%20Python(3)%E2%80%94%E2%80%94%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="1-处理文本文件"><a href="#1-处理文本文件" class="headerlink" title="1.处理文本文件"></a>1.处理文本文件</h2><p><strong>unicode三明治</strong>：bytes-&gt;str-&gt;bytes，中间的文本处理只涉及到str。</p>
<p><strong>chardet</strong>：检测文本编码的模块。</p>
<p>不要依赖系统的默认编码，一定要设置编码。</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用文本方式打开文本文件</span></div><div class="line"><span class="keyword">open</span>(<span class="string">'a.txt'</span>, <span class="string">'r'</span>, <span class="keyword">encoding</span>=<span class="string">'utf-8'</span>)</div><div class="line"><span class="comment"># 使用二进制模式打开二进制文件</span></div><div class="line"><span class="keyword">open</span>(<span class="string">'a.gif'</span>, <span class="string">'rb'</span>)</div></pre></td></tr></table></figure>
<h2 id="2-规范化Unicode字符串"><a href="#2-规范化Unicode字符串" class="headerlink" title="2.规范化Unicode字符串"></a>2.规范化Unicode字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nfc_equal</span><span class="params">(str1, str2)</span>:</span></div><div class="line">    <span class="keyword">return</span> normalize(<span class="string">'NFC'</span>, str1)==normalize(<span class="string">'NFC'</span>, str2)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold_equal</span><span class="params">(str1, str2)</span>:</span></div><div class="line">    <span class="keyword">return</span> (normalize(<span class="string">'NFC'</span>, str1).casefold() ==</div><div class="line">        normalize(<span class="string">'NFC'</span>, str2).casefold())</div></pre></td></tr></table></figure>
<h2 id="3-正则表达式对str和bytes的匹配"><a href="#3-正则表达式对str和bytes的匹配" class="headerlink" title="3.正则表达式对str和bytes的匹配"></a>3.正则表达式对str和bytes的匹配</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 按str形式进行匹配，可以匹配到中文</span></div><div class="line">re.compile(<span class="string">r'\w'</span>)</div><div class="line"><span class="comment"># 按bytes形式进行匹配，只匹配ascii</span></div><div class="line">re.compile(r<span class="string">b'\w'</span>)</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fluent Python(2)——字典和集合]]></title>
      <url>/2017/09/13/Fluent%20Python(2)%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h2 id="1-字典"><a href="#1-字典" class="headerlink" title="1. 字典"></a>1. 字典</h2><p>只有可散列类型可用作键，可散列类型：str、bytes、数值、frozenset。</p>
<p>通过查找来插入新值的时候优化，使用setdefault函数：<br><code>my_dict.setdefault(key, []).append(new_value)</code></p>
<p>查找取值的时候优化，使用defaultdict：<br><code>my_dict = collections.defaultdict(list)</code></p>
<p>collections.Counter：给每个键准备一个整数计数器<br>继承UserDict去自定义dict类型<br>types.MappingProxyType：创建一个视图，只可读不可写</p>
<h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h2><p>求两个集合相同的元素个数：<code>found = len(needles &amp; haystack)</code><br>用{…}比用构造方法set([…])速度要快</p>
<hr>
<ol>
<li>dict和set内部都是用hash表来实现快速查询，也就是空间换时间。</li>
<li>不可在迭代dict的同时添加新值，因为可能导致散列表发生变化，某些键在迭代时被跳过。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fluent Python(1)——序列构成的数组]]></title>
      <url>/2017/09/13/Fluent%20Python(1)%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>这一章在讲Python中的序列类型，其中关于切片、元组还有+=的谜题值得一读。</p>
<h2 id="1-序列类型"><a href="#1-序列类型" class="headerlink" title="1. 序列类型"></a>1. 序列类型</h2><p>容器序列：list,tuple,collections.deque</p>
<p>扁平序列：str,bytes,bytearray,memoryview,array.array</p>
<p>可变序列：list, bytearray,array.array,collections.deque,memoryview</p>
<p>不可变序列：tuple,str,bytes</p>
<h2 id="2-生成器表达式与列表推导"><a href="#2-生成器表达式与列表推导" class="headerlink" title="2. 生成器表达式与列表推导"></a>2. 生成器表达式与列表推导</h2><p>生成器表达式可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数中。因此<strong>使用生成器表达式(generator expression)相比列表推导(list comprehension)更能够节省内存</strong>。</p>
<h2 id="3-更多"><a href="#3-更多" class="headerlink" title="3. 更多"></a>3. 更多</h2><p><img src="/img/序列构成的数组.jpeg" alt=""></p>
<hr>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://docs.python.org/3/library/string.html#format-string-syntax" target="_blank" rel="external">string format语法格式</a></p>
<p><a href="http://blog.csdn.net/handsomekang/article/details/9183303" target="_blank" rel="external">string format</a></p>
<p><a href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" target="_blank" rel="external">为什么数组要从零开始编号 and 为什么是2 ≤ i &lt; 13？</a></p>
<p><a href="http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/" target="_blank" rel="external">memoryview教程减少buffer的复制</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令行大全(4)——shell编程]]></title>
      <url>/2017/08/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8(4)%E2%80%94%E2%80%94shell%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="1-数据类型及操作"><a href="#1-数据类型及操作" class="headerlink" title="1. 数据类型及操作"></a>1. 数据类型及操作</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><ol>
<li>=赋值，但是=前后不能加空格</li>
<li><strong>双引号内字符会扩展，单引号内的是纯文本</strong></li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">unset <span class="built_in">variable</span> <span class="comment"># 取消变量</span></div><div class="line">declare -i <span class="built_in">variable</span> <span class="comment"># 定义为整数</span></div><div class="line"><span class="comment"># 这两个都是定义为环境变量</span></div><div class="line">decalre -x <span class="built_in">variable</span></div><div class="line">export <span class="built_in">variable</span></div></pre></td></tr></table></figure>
<p><strong>数值：</strong> 默认的bash程序中只支持整数运算，使用<code>bc</code>命令可用于浮点运算：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 数值运算需要在(())中</div><div class="line">echo $((<span class="number">1</span>+<span class="number">3</span><span class="number">-2</span>/<span class="number">5</span>*<span class="number">3</span>)) # 输出<span class="string">"4"</span></div><div class="line">echo $((<span class="number">2</span>**<span class="number">3</span>)) # 输出<span class="string">"8"</span></div><div class="line">bc &lt;&lt;&lt; '<span class="number">2.5</span>+<span class="number">4.9</span>*<span class="number">4.7</span>' # 输出<span class="string">"25.5"</span></div></pre></td></tr></table></figure></p>
<p><strong>字符串：</strong> 字符串的操作比较多：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foo="Hello world"</div><div class="line">echo $&#123;#foo&#125; # 统计字符数，输出"11"</div><div class="line">echo $&#123;foo/world/World&#125; # 替换第一个匹配的字符串，输出"Hello World"</div><div class="line">echo $&#123;foo#*l&#125; # 从前往后，删除符合的最短数据，输出"lo World"</div><div class="line">echo $&#123;foo##l&#125; # 从前往后，删除符合的最长数据，输出"d"</div><div class="line">echo $&#123;foo%rld&#125; # 从后往前，删除符合的最短数据，输出"Hello wo"</div><div class="line">var=$&#123;str:-expr&#125; # str==null或者str==""时设置为expr</div><div class="line">var=$&#123;str:?expr&#125; # str==null或者str==""时expr输出到stderr</div></pre></td></tr></table></figure></p>
<p><strong>数组</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">declare -a a # 创建一个数值</div><div class="line">arr=("1" "2" "abc" "4" 5) # 数组赋值</div><div class="line">arr[0]=8 # 数组赋值</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 以下是*和@输出的区别，*是扩展成一串，而@分开了</span></div><div class="line">for i in "$&#123;arr[*]&#125;"; do echo $i; done</div><div class="line">8 2 abc 4 5</div><div class="line">for i in "$&#123;arr[@]&#125;"; do echo $i; done</div><div class="line">8</div><div class="line">2</div><div class="line">abc</div><div class="line">4</div><div class="line">5</div></pre></td></tr></table></figure></p>
<h2 id="2-分支、循环"><a href="#2-分支、循环" class="headerlink" title="2. 分支、循环"></a>2. 分支、循环</h2><p>跟类C语言大同小异，需要注意的是条件分支的test命令</p>
<p><strong>中括号内部前后必须加一个空格</strong></p>
<p><strong>分支：</strong> test命令判断是否符合条件，其中传统的test命令形式为<code>[ express ]</code>，更为现代的形式为用于字符串和普通变量的<code>[[ express ]]</code>和用于数值的<code>(( express ))</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">string=20</div><div class="line"><span class="keyword">if</span> [ -z string ]; <span class="keyword">then</span> <span class="comment"># 判断字符串是否为空</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"string is empty"</span></div><div class="line"><span class="keyword">elif</span> [[ <span class="variable">$string</span> =~ ^h.+o$ ]]; <span class="keyword">then</span> <span class="comment"># 匹配正则表达式</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"string is right"</span></div><div class="line"><span class="keyword">elif</span> (( string&gt;10 )); <span class="keyword">then</span> <span class="comment"># 数值比较</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"string is greater than 10"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"string is not be matched"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="comment"># 输出"string is greater than 10"</span></div></pre></td></tr></table></figure></p>
<p><strong>case分支</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="variable">$i</span> <span class="keyword">in</span></div><div class="line">    <span class="string">"1"</span>)</div><div class="line">    <span class="built_in">echo</span> <span class="string">"input is 1"</span></div><div class="line">    ;;</div><div class="line">    <span class="string">"2"</span>)</div><div class="line">    <span class="built_in">echo</span> <span class="string">"input is 2"</span></div><div class="line">    ;;</div><div class="line">    *)</div><div class="line">    <span class="built_in">echo</span> <span class="string">"input is <span class="variable">$i</span>"</span></div><div class="line">    ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure></p>
<p><strong>循环：</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">while</span>型</span></div><div class="line"><span class="meta">#</span><span class="bash"> 当条件成立时继续循环</span></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]; do</div><div class="line">    printf "%d " $((count++))</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> until型</span></div><div class="line"><span class="meta">#</span><span class="bash"> 当条件成立时，就终止循环。也是先判断条件。</span></div><div class="line">until [ $count -gt 10 ]; do</div><div class="line">    printf "%d " $((count++))</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span>-loop型</span></div><div class="line"><span class="meta">#</span><span class="bash"> 或者用<span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 10)</span></div><div class="line">for i in &#123;1..10&#125;</div><div class="line">do</div><div class="line">    printf "%d " $i</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span>-loop型</span></div><div class="line">for (( i=1; i&lt;=10; i++))</div><div class="line">do</div><div class="line">    printf "%d " $i</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 输出<span class="string">"1 2 3 4 5 6 7 8 9 10"</span></span></div></pre></td></tr></table></figure></p>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><p>shell中的函数定义如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[function] foo [()] &#123;</div><div class="line">    # action</div><div class="line">    [return int]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 定义其实是两种形式:</span></div><div class="line">function foo &#123;...&#125;</div><div class="line">foo () &#123;...&#125;</div><div class="line"></div><div class="line">foo # 函数调用</div></pre></td></tr></table></figure>
<p>不像类C语言在函数括号中传递参数，shell中使用<strong>位置参数</strong>来进行参数传递。shell中的返回值通过<code>$?</code>接收。<br>如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo () &#123;</div><div class="line">    echo $0 # 输出的永远是运行脚本的命令本身</div><div class="line">    echo $($1+$2) # 输出58</div><div class="line">    return (($1+$2+2)) # 返回60，返回值范围是0~255整数</div><div class="line">&#125;</div><div class="line">foo 13 45 # 函数调用</div><div class="line">echo $? # 输出的是最后一次调用foo的返回值60</div></pre></td></tr></table></figure>
<p>一些特殊的参数如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">echo $@ # 输出的是"$1""$2""$3"</div><div class="line">echo $$ # 输出当前进程pid</div><div class="line">echo $# # 输出命令参数个数</div><div class="line">echo $? # 输出上个函数的返回值</div><div class="line">echo $! # 输出后台中最后一次运行的进程pid</div></pre></td></tr></table></figure></p>
<h2 id="4-执行与调试"><a href="#4-执行与调试" class="headerlink" title="4. 执行与调试"></a>4. 执行与调试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> +x 可以显示执行的命令，加号开头的都是命令串</span></div><div class="line"><span class="meta">#</span><span class="bash"> +n 是检测语法</span></div><div class="line"><span class="meta">#</span><span class="bash"> -x和-n是不执行命令，+x和+n是同时执行命令</span></div><div class="line">bash -n &lt;script&gt; </div><div class="line"><span class="meta">#</span><span class="bash"> 使用<span class="built_in">source</span>是在当前进程中执行.sh，否则是新开一个子进程执行</span></div><div class="line">source &lt;script&gt;</div></pre></td></tr></table></figure>
<h2 id="5-实现quicksort"><a href="#5-实现quicksort" class="headerlink" title="5. 实现quicksort"></a>5. 实现quicksort</h2><p>拿个quicksort来作为练习倒是一个不错的选择</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">!/bin/bash -x</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> a quicksort algorithm implement <span class="keyword">in</span> shell</span></div><div class="line"></div><div class="line">arr=(3 23 4 1 45 56 34 78 79 89)</div><div class="line"></div><div class="line">get_pos() &#123;</div><div class="line">    local low=$1</div><div class="line">    local high=$2</div><div class="line">    local value=$&#123;arr[$low]&#125; # 数组取值</div><div class="line"></div><div class="line">    while (( $low&lt;$high )); do</div><div class="line">        while (( $low&lt;$high &amp;&amp; $value&lt;=$&#123;arr[$high]&#125; )); do</div><div class="line">            high=$(($high-1))</div><div class="line">        done</div><div class="line">        if (( $low&lt;$high )); then</div><div class="line">            arr[$low]=$&#123;arr[$high]&#125;</div><div class="line">            ((++low)) # 整数运算只能在(())中</div><div class="line">        fi</div><div class="line">        while (( $low&lt;$high &amp;&amp; $value&gt;=$&#123;arr[$low]&#125; )); do</div><div class="line">            low=$(($low+1))</div><div class="line">        done</div><div class="line">        if (( $low&lt;$high )); then</div><div class="line">            arr[$high]=$&#123;arr[$low]&#125;</div><div class="line">            ((--high)) # 整数运算只能在(())中</div><div class="line">        fi</div><div class="line">    done</div><div class="line"></div><div class="line">    arr[$low]=$value</div><div class="line">    return $low</div><div class="line">&#125;</div><div class="line"></div><div class="line">quicksort() &#123;</div><div class="line">    local low=$1</div><div class="line">    local high=$2</div><div class="line">    local pos=0</div><div class="line">    local tempLow=0</div><div class="line">    local tempHigh=0</div><div class="line">    if (( $low&lt;$high )); then</div><div class="line">        get_pos $low $high</div><div class="line">        pos=$? # 获得返回值</div><div class="line">        tempLow=$(($pos-1))</div><div class="line">        tempHigh=$(($pos+1))</div><div class="line">        quicksort $low $tempLow</div><div class="line">        quicksort $tempHigh $high</div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">quicksort 0 9 # 调用函数</div><div class="line"></div><div class="line">echo $&#123;arr[@]&#125; # 另一种形式是$&#123;arr[*]&#125;，两者区别在前者扩展数组单个元素，后者将数组扩展成一个长串</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令行大全(3)——常见任务和工具]]></title>
      <url>/2017/08/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8(3)%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h2 id="1-软件包管理"><a href="#1-软件包管理" class="headerlink" title="1. 软件包管理"></a>1. 软件包管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-cache search pkg_name # 查找软件包</div><div class="line">apt-cache show pgk_name # 显示软件包信息</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dpkg -i pkg_file # 用.deb安装软件包</div><div class="line">dpkg --list # 列出已安装的软件包列表</div><div class="line">dpkg --status pkg_name # 判断软件包是否已安装</div><div class="line">dpkg --search file_name # 查看某文件由哪个软件包安装得到</div></pre></td></tr></table></figure>
<h2 id="2-存储"><a href="#2-存储" class="headerlink" title="2. 存储"></a>2. 存储</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mount</div><div class="line">umount /dev/hdc</div><div class="line">fdisk # 磁盘分区</div><div class="line">mkfs -t vfat /dev/sdb1 # 创建文件系统</div><div class="line">dd if=/dev/sdb of=/dev/sdc # 完全复制数据块</div><div class="line">md5sum /dev/cdrom</div></pre></td></tr></table></figure>
<h2 id="3-网络"><a href="#3-网络" class="headerlink" title="3. 网络"></a>3. 网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget scp ssh</div><div class="line">netstat -ie # 显示网络状态 ifconfig</div><div class="line">netstat -r # 显示路由表</div><div class="line">sftp # 此命令尤其好使，因为sftp使用的是ssh的22端口，所以不需要服务器单独再开服务</div></pre></td></tr></table></figure>
<h2 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4. 文件搜索"></a>4. 文件搜索</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">find ~ -type f -name '*.bak' -delete # 查找用户目录下.bak文件并删除</div><div class="line">find ~ -type f | wc -l # 统计用户目录下文件个数</div><div class="line">find的两个选项：test和action</div></pre></td></tr></table></figure>
<h2 id="5-文件归档和压缩"><a href="#5-文件归档和压缩" class="headerlink" title="5. 文件归档和压缩"></a>5. 文件归档和压缩</h2><p>文件归档和压缩是两个概念，zip命令同时包括两种功能</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync -av <span class="params">&lt;dir1&gt;</span> <span class="params">&lt;dir2&gt;</span> <span class="meta"># 同步dir1和dir2</span></div></pre></td></tr></table></figure>
<p><strong>压缩</strong></p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip gunzip bzip2 bunzip2</div></pre></td></tr></table></figure>
<p><strong>归档</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar xzvf &lt;file_name&gt; -C &lt;dir&gt; # 解压到&lt;dir&gt;文件夹下</div><div class="line">tar czvf &lt;file_name&gt; &lt;dir&gt; # 打包dir到file_name</div><div class="line">zip -r &lt;dir&gt; # 压缩dir</div></pre></td></tr></table></figure></p>
<p><strong>将远程系统中某目录转移到本地系统</strong></p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh remote-sys 'tar cf - &lt;dir&gt;' <span class="string">| tar xf -</span></div></pre></td></tr></table></figure>
<h2 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6. 正则表达式"></a>6. 正则表达式</h2><p>BRE POSIX基本正则表达式 <code>grep &#39;...&#39;</code></p>
<p>ERE 扩展正则表达式 <code>grep -E &#39;...&#39;</code></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">find</span> <span class="symbol">&lt;dir&gt;</span> -regex <span class="string">'&lt;regex&gt;'</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">? * + &#123;&#125; . <span class="selector-attr">[]</span> # 元字符</div></pre></td></tr></table></figure>
<h2 id="7-文本处理"><a href="#7-文本处理" class="headerlink" title="7. 文本处理"></a>7. 文本处理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cut -f &lt;字段编号&gt; &lt;file_name&gt; # 切片某字段</div><div class="line">cat -n # 显示行号</div><div class="line">aspell # 拼写检查</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 比较两文件的不同产生一个patch，并且还原文件</span></div><div class="line">diff -Naur &lt;old_file&gt; &lt;new_file&gt; &gt; file_patch</div><div class="line">patch &lt; file_patch</div><div class="line"></div><div class="line">diff -c/-u &lt;file_1&gt; &lt;file_2&gt; # 将file_1与file_2进行比较</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> cut以逗号为分隔符，1-5字段的内容</span></div><div class="line">cut -d "," -f "1,2-4,5" &lt;file&gt;</div></pre></td></tr></table></figure>
<h2 id="8-格式化输出"><a href="#8-格式化输出" class="headerlink" title="8. 格式化输出"></a>8. 格式化输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">printf "format" arguments # 格式化输出</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 输出manual到PDF文件</span></div><div class="line">zcat /usr/share/man/man1/ls.1.gz | groff -mandoc &gt; ~/foo.ps</div><div class="line">ps2pdf foo.ps ls.pdf</div><div class="line"></div><div class="line">a2ps -o ~/ls.ps # ASCII-&gt;PostScript</div><div class="line">lpstat -s # 查看打印机状态</div></pre></td></tr></table></figure>
<h2 id="9-编译程序"><a href="#9-编译程序" class="headerlink" title="9. 编译程序"></a>9. 编译程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">make # 编译程序</div><div class="line">./configure # 分析生成环境</div><div class="line">make install # 默认安装到/usr/local/bin</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令行大全(2)——配置与环境]]></title>
      <url>/2017/08/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8(2)%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">printenv | less # 查看本机的各种环境变量</div><div class="line">alias ll=“ls -laF” # 为命令起别名</div></pre></td></tr></table></figure>
<h2 id="2-vi的使用"><a href="#2-vi的使用" class="headerlink" title="2.vi的使用"></a>2.vi的使用</h2><p>这本书里只是简单地讲了一遍，这篇文章讲得更多一些：<a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/" target="_blank" rel="external">Learn Vim Progressively</a>。另外就是阅读<code>:help usr_02.txt</code></p>
<p>拓展阅读：<a href="https://vim.rtorr.com/" target="_blank" rel="external">Vim命令</a></p>
<p>移动光标、删除、复制粘贴对比来记忆就很容易了，都一样。</p>
<p><strong>移动光标</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">键</th>
<th style="text-align:left">动作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数字0</td>
<td style="text-align:left">至本行开头</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">至本行末尾</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td style="text-align:left">至文件末尾</td>
</tr>
<tr>
<td style="text-align:left">gg</td>
<td style="text-align:left">至文件开头</td>
</tr>
<tr>
<td style="text-align:left">ctrl+F</td>
<td style="text-align:left">下翻一页</td>
</tr>
<tr>
<td style="text-align:left">ctrl+B</td>
<td style="text-align:left">上翻一页</td>
</tr>
<tr>
<td style="text-align:left">number+G</td>
<td style="text-align:left">至第number行</td>
</tr>
</tbody>
</table>
<p><strong>删除文本</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">键</th>
<th style="text-align:left">动作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">dd</td>
<td style="text-align:left">删除一行</td>
</tr>
<tr>
<td style="text-align:left">d$</td>
<td style="text-align:left">删除光标到行末尾</td>
</tr>
<tr>
<td style="text-align:left">d0</td>
<td style="text-align:left">删除光标到行开头</td>
</tr>
<tr>
<td style="text-align:left">d7</td>
<td style="text-align:left">删除光标后的7行</td>
</tr>
</tbody>
</table>
<p><strong>复制粘贴</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">键</th>
<th style="text-align:left">动作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">粘贴文本</td>
</tr>
<tr>
<td style="text-align:left">yy</td>
<td style="text-align:left">复制一行</td>
</tr>
<tr>
<td style="text-align:left">y$</td>
<td style="text-align:left">复制到行末尾</td>
</tr>
<tr>
<td style="text-align:left">y0</td>
<td style="text-align:left">复制到行开头</td>
</tr>
<tr>
<td style="text-align:left">y7</td>
<td style="text-align:left">复制光标后的7行</td>
</tr>
</tbody>
</table>
<p><strong>搜索</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/pattern # 按n查找下一个</div><div class="line">:%s/pattern_old/pattern_new/g # 全局替换</div></pre></td></tr></table></figure>
<p><strong>多文件</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">:n # 切换下一个</div><div class="line">:N # 切换上一个</div><div class="line">:buffers # 正在编辑的文件</div><div class="line">:buffer 2 # 切换到第2个文件</div><div class="line"></div><div class="line">:e &lt;filename&gt; # 打开一个新的文件</div><div class="line">:r &lt;filename&gt; # 将filename的内容整个复制到当前文件中，光标前</div><div class="line"></div><div class="line">:w &lt;filename&gt; # 另存为新文件</div><div class="line">ZZ # 相当于:wq，智障操作</div></pre></td></tr></table></figure>
<h2 id="3-提示符"><a href="#3-提示符" class="headerlink" title="3.提示符"></a>3.提示符</h2><p>环境变量<code>PS1</code>中保存的是提示符信息，喜欢可以自己随便改。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令行大全(1)——shell入门]]></title>
      <url>/2017/08/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8(1)%E2%80%94%E2%80%94shell%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>虽然一直在用Linux，也折腾过很多命令，但是因为缺乏系统的学习，所以常用到的命令也就那么些，对于Linux更多的命令，自己是缺乏了解的。</p>
<p>趁着暑假的时间，自己学完了这本《Linux命令行大全》，总体而言这本书讲的还是比较浅，缺乏深入，但是我本身就只是抱着学习命令的态度，所以一路看下来，倒也不至于失望。</p>
<p>如果只是想学习Linux命令入门，这本书挺好的；但是如果想深入学习Linux的使用，甚至内核开发，那还是另请高明吧！</p>
<p>以下四篇，是我在看这本书的过程中记录的笔记，有所整理，尽量涵盖主要命令，同时去除掉书中一些冗余的地方。</p>
<p>补充：<a href="https://github.com/LeCoupa/awesome-cheatsheets/blob/master/languages/bash.sh" target="_blank" rel="external">Bash快速参考表</a></p>
<h2 id="1-导航类"><a href="#1-导航类" class="headerlink" title="1. 导航类"></a>1. 导航类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cd - # 返回上一次位置</div><div class="line">ls -la # 显示隐藏文件和长格式</div><div class="line">ls -d # 显示文件夹本身的详细信息，而不是文件夹内的文件信息</div><div class="line">/bin # 系统可执行文件</div><div class="line">/etc # 配置文件</div><div class="line">/usr # 普通用户使用的所有文件和程序</div><div class="line">/usr/include # C语言系统头文件</div><div class="line">/usr/bin # 用户大部分可执行文件</div></pre></td></tr></table></figure>
<h2 id="2-操作文件与目录"><a href="#2-操作文件与目录" class="headerlink" title="2. 操作文件与目录"></a>2. 操作文件与目录</h2><p><code>-r</code> 一般用于文件夹目录树的递归操作，复制、删除等</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir    cp    mv</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -r &lt;dir&gt;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 建立硬链接和软链接</span></div><div class="line">ln &lt;file&gt; &lt;file_hard&gt;</div><div class="line">ln -s &lt;file&gt; &lt;file_soft&gt;</div></pre></td></tr></table></figure>
<h2 id="3-查看命令的属性"><a href="#3-查看命令的属性" class="headerlink" title="3. 查看命令的属性"></a>3. 查看命令的属性</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span>    <span class="type">which    </span>whatis</div></pre></td></tr></table></figure>
<p>最重要的命令：man、info、help<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man -k &lt;search_string&gt; # 查找哪些命令可用</div></pre></td></tr></table></figure></p>
<h2 id="4-重定向"><a href="#4-重定向" class="headerlink" title="4. 重定向"></a>4. 重定向</h2><p>重定向符和管道符的区别：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">重定向符将stdout重定向到&gt;后接的文件中；</div><div class="line">管道<span class="keyword">A</span>|B将程序<span class="keyword">A</span>的标准输出重定向到程序B的标准输入中。</div></pre></td></tr></table></figure></p>
<p>重定向：<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;  标准输出重定向</div><div class="line"><span class="meta">2&gt; </span> 标准错误重定向</div><div class="line">&amp;&gt; 标准输出+标准错误重定向</div><div class="line">&gt;&amp;<span class="number">2</span> 标准输出重定向到标准错误中 （可用于shell脚本输出错误信息）</div><div class="line">nohup &lt;program&gt; &amp;&gt; xxx.out &amp;  # 在后台执行命令，并将标准输出+标准错误重新向到xxx.out中</div></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wc -l # 统计行数  </div><div class="line">wc -w # 统计字数</div><div class="line">head/tail -n &lt;num&gt;</div><div class="line">tee # 读取标准输入，同时输出到标准输出和文件中，相当于可以在中途截取掉信息。</div></pre></td></tr></table></figure>
<h2 id="5-快捷键"><a href="#5-快捷键" class="headerlink" title="5. 快捷键"></a>5. 快捷键</h2><table>
<thead>
<tr>
<th style="text-align:left">键</th>
<th style="text-align:left">动作</th>
<th style="text-align:left">键</th>
<th style="text-align:left">动作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl+A</td>
<td style="text-align:left">移动到行首</td>
<td style="text-align:left">Ctrl+E</td>
<td style="text-align:left">移动到行尾</td>
</tr>
<tr>
<td style="text-align:left">Alt+F</td>
<td style="text-align:left">往前一个字</td>
<td style="text-align:left">Alt+B</td>
<td style="text-align:left">往后一个字</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Y</td>
<td style="text-align:left">粘贴</td>
<td style="text-align:left">Ctrl+L</td>
<td style="text-align:left">清屏</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K</td>
<td style="text-align:left">向后剪切到行尾</td>
<td style="text-align:left">Ctrl+U</td>
<td style="text-align:left">向前剪切到行头</td>
</tr>
</tbody>
</table>
<h2 id="6-权限"><a href="#6-权限" class="headerlink" title="6. 权限"></a>6. 权限</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">su    passwd</div><div class="line">sudo gpasswd -a $USER &lt;group&gt; # 添加当前用户到指定组</div><div class="line">chmod xxx &lt;file&gt;</div><div class="line">chown [ower][:[group]] &lt;file&gt;</div></pre></td></tr></table></figure>
<h2 id="7-进程"><a href="#7-进程" class="headerlink" title="7. 进程"></a>7. 进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ps    top    pstree</div><div class="line">kill -9 &lt;pid/jobspec&gt; # 杀死进程</div><div class="line">kill -l # 查看所有信号格式</div><div class="line">killall -9 &lt;name&gt; # 杀死指定程序的所有进程</div></pre></td></tr></table></figure>
<p>前后台进程切换：</p>
<p><img src="process-switch.png" alt="前后台进程切换"></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android开发的一种架构方式]]></title>
      <url>/2016/01/04/Android%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E7%A7%8D%E6%9E%B6%E6%9E%84%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>本文谈谈博主在实际项目开发的过程中，对代码组织的一种方式。</p>
<h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>Android系统本身已经给了我们一个MVC。</p>
<p>其中model是业务逻辑，应该是纯Java实现，与平台无关。view一般指xml和自定义view。但是最后的controller应该归于activity，可是写过一段时间代码后我们就会发现，activity承担的责任很多，既要负责网络请求、缓存处理、数据显示，又要处理来自view的事件，代码杂乱不堪，大量的代码积累在activity里面，无论是易读性还是可维护性都大打折扣。</p>
<p>想到这里，controller是不是可以继续分层呢？</p>
<h2 id="IO层和UI层"><a href="#IO层和UI层" class="headerlink" title="IO层和UI层"></a>IO层和UI层</h2><p>博主经过一番思考以及比较后，将原本的controller分成了UI层和IO层，IO层负责网络请求，UI层负责数据展示，两者通过接口回调实现数据传递。</p>
<p>这样做的好处是不言自明的。首先，activity的代码行数可以大幅度减少，代码变得整齐有序。其次，网络请求分出来后实现了数据展示的解耦，事实上，UI层可以完全不管IO层是怎么实现的，符合面向对象的开放-封闭原则。博主在开发中使用xUtils作为网络请求库，UI/IO解耦后，IO层换一种网络请求库对UI层没有任何影响。</p>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p><img src="/img/2016/01/IO和UI工程结构.jpeg" alt="IO和UI工程结构"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><em>Talking is cheap, show me the code.</em></p>
<p>接下来以一个显示用户信息的页面为例，说明IO/UI具体是怎么实现的。</p>
<p><img src="/img/2016/01/Main.jpg" alt="UML图"></p>
<p>IOCallback接口定义了网络请求不同阶段和结果处理的方法，其中重载的onSuccess是为了区分返回的List数据和Object数据，使用泛型提高可扩展性，也可以使用Map类型。</p>
<p>IOHandler作为一个handler(处理器，不要理解为Android传递信息的Handler类)父类，在构造函数中初始化ACache，ACache是一个开源库，用来实现缓存。</p>
<p>UserHandler继承自IOHandler，实现具体的handle功能，此处是实现userDetail的处理。</p>
<p>SettingActivity属于UI层，调用UserHandler获取userDetail。其中的getUserDetail方法里面完成调用UserHandler的getUserDetail方法，同时实现IOCallback接口，在回调里拿到数据并显示。</p>
<p>说了那么多，最后上代码吧。</p>
<p>IOCallback：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 实现获取数据的回调接口，包括从缓存获取和从服务器获取</span></div><div class="line"><span class="comment"> * <span class="doctag">@link</span> IOHandler</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开始获取数据</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 成功获取数据，数据为list形式</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(List&lt;T&gt; result)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 成功获取数据，数据为object形式</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T result)</span> <span class="keyword">throws</span> UnsupportedEncodingException</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取数据失败，一般为网络错误</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(String <span class="keyword">error</span>)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IOHandler：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * IOHandler用于处理数据的获取，在内部调用IOCallback将数据返回给UI层</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IOHandler</span> &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Acache对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> ACache cache;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 构造函数，初始化Acache</span></div><div class="line"><span class="comment">     * @param context</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOHandler</span>(<span class="params">Context context</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.cache = ACache.<span class="keyword">get</span>(context);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体的UserHandler：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHandler</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserDetail</span><span class="params">(RequestParams params, IOCallback ioCallback)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> IOCallback callback = ioCallback;</div><div class="line">        String userDetailJson = cache.getAsString(CacheConfig.Key.USER_DETAIL);</div><div class="line">        <span class="comment">//优先从缓存中读取</span></div><div class="line">        <span class="keyword">if</span>(userDetailJson!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                callback.onSuccess(GsonUtil.getMap(userDetailJson));</div><div class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HttpUtils http = <span class="keyword">new</span> HttpUtils();</div><div class="line">        http.send(HttpRequest.HttpMethod.GET,</div><div class="line">                Api.Users.getUserDetail,</div><div class="line">                params,</div><div class="line">                <span class="keyword">new</span> RequestCallBack&lt;String&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">                        callback.onStart();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ResponseInfo&lt;String&gt; responseInfo)</span> </span>&#123;</div><div class="line">                        Map&lt;String, Object&gt; map = GsonUtil.getMap(responseInfo.result);</div><div class="line">                        <span class="keyword">if</span>(!map.containsKey(<span class="string">"code"</span>))&#123;</div><div class="line">                            cache.put(CacheConfig.Key.USER_DETAIL,responseInfo.result, CacheConfig.Time.USER_DETAIL);</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            callback.onSuccess(map);</div><div class="line">                        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(HttpException e, String s)</span> </span>&#123;</div><div class="line">                        callback.onFailure(s);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后是UI层SettingActivity的调用：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> LoadingDialog dialog;</div><div class="line">    <span class="keyword">private</span> UserHandler userHandler;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TextView unameText;</div><div class="line">    <span class="keyword">private</span> TextView accountText;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        unameText = (TextView) findViewById(R.id.unameText);</div><div class="line">        accountText = (TextView) findViewById(R.id.accountText);</div><div class="line">        getUserDetail();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">getUserDetail</span><span class="params">()</span></span>&#123;</div><div class="line">        RequestParams params = <span class="keyword">new</span> RequestParams();</div><div class="line">        params.addQueryStringParameter(<span class="string">"token"</span>, Constants.token);</div><div class="line">        userHandler.getUserDetail(params, <span class="keyword">new</span> IOCallback&lt;Map&lt;String, Object&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(List&lt;Map&lt;String, Object&gt;&gt; result)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Map&lt;String, Object&gt; result)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (result.containsKey(<span class="string">"code"</span>)) &#123;</div><div class="line">                    Toast.makeText(SettingActivity.<span class="keyword">this</span>, <span class="string">"getUserDetail error"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    String username = result.get(<span class="string">"username"</span>).toString();</div><div class="line">                    String remark = result.get(<span class="string">"remark"</span>).toString();</div><div class="line">                    unameText.setText(username);</div><div class="line">                    accountText.setText(remark);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(String <span class="keyword">error</span>)</span> </span>&#123;</div><div class="line">                Toast.makeText(SettingActivity.<span class="keyword">this</span>, <span class="string">"Internet error"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FBReaderJ学习笔记]]></title>
      <url>/2015/02/08/FBReaderJ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>懒得整理了，直接贴博客园的原文链接。</p>
<p><a href="http://www.cnblogs.com/chace/p/4279890.html" target="_blank" rel="external">FBReaderJ学习笔记（一）：编译</a>  </p>
<p><a href="http://www.cnblogs.com/chace/p/4279841.html" target="_blank" rel="external">FBReaderJ学习笔记（二）：PopWindow实现自定义阅读页菜单</a></p>
<p><a href="http://www.cnblogs.com/chace/p/4280356.html" target="_blank" rel="external">FBReaderJ学习笔记（三）：Footer底部状态栏更改</a>  </p>
<p><a href="http://www.cnblogs.com/chace/p/4280358.html" target="_blank" rel="external">FBReaderJ学习笔记（四）：SelectionPopup样式更改</a>  </p>
<p><a href="http://www.cnblogs.com/chace/p/4280377.html" target="_blank" rel="external">FBReaderJ学习笔记（五）：附录</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[舌尖上的程序员]]></title>
      <url>/2014/05/25/%E8%88%8C%E5%B0%96%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/</url>
      <content type="html"><![CDATA[<p><img src="/img/2014/05/a-bite-of-coder.png" alt="舌尖上的程序员"></p>
<blockquote>
<p>码完代码，他起身关上电脑，用滚烫的开水为自己泡制一碗腾着热气的老坛酸菜面。中国的程序员更偏爱拉上窗帘，在黑暗中享受这独特的美食。这是现代工业给一天辛苦劳作的人最好的馈赠。江浙一带生长的程序员虽然在京城多年，但仍口味清淡，他们往往不加料包，由脸颊自然淌下的热泪补充恰当的盐分。他们相信，用这种方式，能够抹平思考着现在是不是过去想要的未来而带来的大部分忧伤。</p>
<p>小刘的父亲在年轻的时候也是从爷爷手里接收了祖传的代码，不过令人惊讶的是，到了小刘这一代，很多东西都遗失了，但是程序员苦逼的味道保存的是如此的完整。</p>
<p>就在24小时之前，最新的需求从PM处传来，为了得到这份自然的馈赠，码农们开机、写码、调试、重构，四季轮回的等待换来这难得的丰收时刻。码农知道，需求的保鲜期只有短短的两天，码农们要以最快的速度对代码进行精致的加工，任何一个需求都可能在24小时之后失去原本的活力，变成一文不值的垃圾创意。</p>
</blockquote>
<p>原文：<a href="http://www.cocoachina.com/bbs/read.php?tid=202001&amp;page=1" target="_blank" rel="external">舌尖上的程序员</a></p>
<p>图：自己P的</p>
]]></content>
      
        
        <tags>
            
            <tag> 段子 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
