<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chace</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chace.in/"/>
  <updated>2019-12-12T14:44:09.920Z</updated>
  <id>http://chace.in/</id>
  
  <author>
    <name>chace</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>漫谈容器与容器云</title>
    <link href="http://chace.in/2019/12/05/%E6%BC%AB%E8%B0%88%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%91/"/>
    <id>http://chace.in/2019/12/05/漫谈容器与容器云/</id>
    <published>2019-12-05T03:50:12.000Z</published>
    <updated>2019-12-12T14:44:09.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础设施与软件架构"><a href="#基础设施与软件架构" class="headerlink" title="基础设施与软件架构"></a>基础设施与软件架构</h1><p>从经典三层架构到容器云</p><p>从单体架构到微服务架构</p><h1 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h1><h2 id="服务编排与部署"><a href="#服务编排与部署" class="headerlink" title="服务编排与部署"></a>服务编排与部署</h2><p>随着业务的增加，从单体架构到微服务架构似乎是一种必然的趋势。容器带来了新的服务发布方式——以容器镜像作为服务从开发到运维的交付产物——但是并不能解决服务拆分带来的庞大服务数量问题。此外，对于一个大型系统来说，无论是服务之间存在的依赖关系，还是服务与外部系统的依赖关系都是非常复杂的，依靠人工来记录和配置这些依赖显然费力不讨好，而且容易出错。因此，我们的容器云平台迫切需要对容器进行编排与部署的工具。</p><p>在展开进一步讨论前，首先明确“编排”和“部署”的定义：</p><blockquote><p>编排(orchestration)：一个系统由多个服务组成，编排的作用就是明确这些服务之间的耦合关系，以及被部署对象对环境的依赖，制定部署流程中各个动作的执行顺序。编排的作用是将多个服务组合成一个完整的，可以运行的系统。</p><p>部署(deployment)：部署是将系统在实际环境中运行起来。在这一过程中，将根据编排指定的服务耦合关系以及部署动作的执行顺序，启动指定的服务，包括获取加载配置、初始化环境、启动服务等。部署完成后，系统得到正常运行。</p></blockquote><p>明确定义以后，是不是可以尝试自己来设计一个编排部署工具呢？</p><p>先想一想编排这个阶段。看起来是要定义一份配置文件，在这份配置文件中，由运维人员负责编写系统需要使用的服务以及服务之间的耦合关系和执行流程，编写完成后，交付给部署阶段来使用。在引入容器以后，配置文件中服务项的各个字段基本可以参考Docker容器的启动参数来设计，比如容器使用的镜像、容器进程的启动命令、环境变量、暴露的端口等；而服务之间的依赖耦合关系其实可以用DAG(有向无环图)来定义，服务项可以加一个字段来表示某个服务依赖于另一个服务。</p><p>假设我们已经得到了这么一份“编排配置文件“，那么应该如何使用它来部署呢？</p><p>手动是不可能手动的，这辈子都不可能手动的。既然要自动化部署，那么首先肯定要解析这份配置文件，所谓解析，就是将这份配置文件翻译成Docker容器的启动命令，这个实现起来不难。现在我们得到了系统所有服务的容器启动命令，那么问题来了，如何确定这些启动命令的执行先后顺序呢？这个也不难，前面说的DAG已经解决了这个问题，剩下的就是将DAG排序成可执行序列。接下来，只需要向Docker daemon发送这些启动命令就可以完成部署的过程，如果部署过程中发生了错误，那就中断部署过程，根据策略杀死已经部署的服务或者干脆忽略。</p><p>到这里，我们已经设计出了一套<strong>自动化容器编排部署工具（单机版）</strong>。只要写一份配置文件，执行一条命令，系统就启动起来了，再也不用<strong>一个一个敲命令启服务了~</strong></p><p>听上去很不错，我们的<strong>自动化容器编排部署工具（单机版）</strong>简单又好用。但是——遗憾的在于上述过程只能适用于单机系统，因为Docker daemon显然是单机的。如果是集群化部署，应该如何设计编排和部署方案呢？因为集群化部署涉及到多宿主机的调度问题，这是下一节的内容，这里先按下不表。</p><blockquote><p>聪明的你是不是已经想到了，既然Docker daemon是单机的，那么有没有可能设计一套API管理一组宿主机的Docker daemon呢？</p></blockquote><p>讲了那么多自己的构想，最后还是回到业界，来看看成熟产品都是怎么做编排部署的吧？</p><h3 id="Compose编排小神器"><a href="#Compose编排小神器" class="headerlink" title="Compose编排小神器"></a>Compose编排小神器</h3><p>Docker compose素有容器编排小神器的美名，主要原因就在于它够简单。只需要编写一份配置文件，然后执行一条<code>docker-compose up -d &lt;your-config&gt;.yaml</code>就完成了编排部署的过程。</p><p>以下配置文件是一个依赖MySQL的web服务，可以看到服务的最小粒度是service(其实也就是容器)，其中挂载卷、环境变量、端口映射、重启策略都有涉及到。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">examples/web</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/data"</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">mysql</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mysql:5.6</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_ROOT_PASSWORD=&lt;password&gt;</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_ROOT_HOST=%</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">3306</span><span class="string">:3306</span></span><br></pre></td></tr></table></figure><p>但是讲道理，我们20分钟设计出来的<strong>自动化容器编排部署工具（单机版）</strong>不也具备这些功能吗？那compose还有哪些额外功能呢？</p><ul><li>首先是自动build镜像功能，如果service指定build字段，那么会根据build字段下的配置信息去寻找Dockerfile来进行镜像构建；</li><li>其次，Compose是支持集群部署的，但是得依赖于我们后面会提到的Swarm。</li></ul><p>最后，考虑一种情况，在系统中有一个容器包含volume，这个volume还可能被其他容器引用。如果容器更新时只是简单地删除旧容器创建新容器，那么新建的这个容器将会丢失旧容器的存储卷内容；而先创建新容器再删除旧容器又可能会发生端口冲突。Compose的处理策略是引入一个中间容器引用旧容器的volume，然后删除旧容器，再新建容器，引用这个中间容器的volume，最后删除中间容器。</p><h3 id="K8s以Pod为单位的编排"><a href="#K8s以Pod为单位的编排" class="headerlink" title="K8s以Pod为单位的编排"></a>K8s以Pod为单位的编排</h3><h3 id="Fleet基于systemd的编排"><a href="#Fleet基于systemd的编排" class="headerlink" title="Fleet基于systemd的编排"></a>Fleet基于systemd的编排</h3><h2 id="服务的调度"><a href="#服务的调度" class="headerlink" title="服务的调度"></a>服务的调度</h2><p>scheduler</p><h2 id="服务高可用"><a href="#服务高可用" class="headerlink" title="服务高可用"></a>服务高可用</h2><p>健康检查、故障恢复</p><p>kubelet</p><p>rc的重启</p><h2 id="服务迁移"><a href="#服务迁移" class="headerlink" title="服务迁移"></a>服务迁移</h2><p>冷迁移</p><h3 id="服务缩扩容"><a href="#服务缩扩容" class="headerlink" title="服务缩扩容"></a>服务缩扩容</h3><p>hpa, rc</p><h3 id="服务发现与注册"><a href="#服务发现与注册" class="headerlink" title="服务发现与注册"></a>服务发现与注册</h3><p>service, endpoints</p><h3 id="服务负载均衡"><a href="#服务负载均衡" class="headerlink" title="服务负载均衡"></a>服务负载均衡</h3><p>ingress, service</p><h3 id="服务运行监控（监控、日志）"><a href="#服务运行监控（监控、日志）" class="headerlink" title="服务运行监控（监控、日志）"></a>服务运行监控（监控、日志）</h3><p>prometheus, fluentd</p><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p>计算</p><p>request， limits, resourceQuota</p><p>网络</p><p>二层网络 flannel</p><p>存储</p><p>pv, pvc, stroageclass</p><p>资源隔离</p><p>namespace</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础设施与软件架构&quot;&gt;&lt;a href=&quot;#基础设施与软件架构&quot; class=&quot;headerlink&quot; title=&quot;基础设施与软件架构&quot;&gt;&lt;/a&gt;基础设施与软件架构&lt;/h1&gt;&lt;p&gt;从经典三层架构到容器云&lt;/p&gt;
&lt;p&gt;从单体架构到微服务架构&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://chace.in/tags/Docker/"/>
    
      <category term="容器云" scheme="http://chace.in/tags/%E5%AE%B9%E5%99%A8%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境编程(4)-进程生命周期</title>
    <link href="http://chace.in/2019/10/11/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-4-%E8%BF%9B%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://chace.in/2019/10/11/Linux环境编程-4-进程生命周期/</id>
    <published>2019-10-11T14:06:48.000Z</published>
    <updated>2019-10-11T14:10:20.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程的层次关系"><a href="#进程的层次关系" class="headerlink" title="进程的层次关系"></a>进程的层次关系</h1><p>pid是进程ID，pgid是进程组ID，sid是会话ID。默认情况下，新创建的进程会继承父进程的进程组ID和会话ID。 </p><p>比喻：会话是公司，进程组是部门，进程是员工。 </p><p>进程组方便管理一组进程，比如发送信号可以发给一个进程组。 </p><p>对于shell会话来说，登录时的进程为会话首进程。之后启动的进程分为前台进程组和后台进程组的概念。只有一个前台进程组，可以有多个后台进程组。前台进程组的进程在控制终端读取输入，比如ctrl+c </p><h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><p>fork以后会用写时复制技术复制父进程的数据段、代码段、栈、堆。 </p><p>写实复制技术利用了Linux的多级页表机制，在fork时拷贝的是父进程的页表，而不是物理内存页。在父子进程对页表进程修改时，才真正触发拷贝物理内存页。 </p><p>实现上将页表设置成写保护，父子进程在尝试修改写保护的页面时，会引发缺页中断，内核会负责创建副本，也就是真正的拷贝。 </p><p>文件描述符在fork的时候也发生了复制，但是复制的只是fdtable里保存的fd指针，因此父子进程还是共享fd。 </p><p>复制过程略复杂，会设计到子进程初始化files_struct以及重新alloc_fdtable，最后将父进程的<strong>struct file类型指针</strong>拷贝到子进程对应的数据结构中。 </p><p>为了避免暴露fd给子进程，Linux引入了close on exec机制。只要设置了FD_CLOSEXEC标志位的文件，在子进程调用exec时会将文件关闭。可以在open时设置这个flag，也可以在open后调用fcntl修改这个flag。建议在open时设置，因为可能在修改flag之前子进程已经被fork出来了。 </p><p><strong>vfork父子进程共享内存</strong>。一般不要用vfork。 </p><p>vfork创建的子进程不要用return退出，会有奇怪的bug。 </p><p>daemon进程创建一般使用两次fork </p><ol><li><p>fork子进程，父进程退出 </p></li><li><p>子进程修改workdir, setsid, umask(0) </p></li><li><p>再次fork子进程，父进程退出。让daemon进程不是会话组的首进程，因为首进程可能打开终端设备 </p></li><li><p>关闭stderr, stdout, stdin </p></li></ol><h1 id="exit和wait"><a href="#exit和wait" class="headerlink" title="exit和wait"></a>exit和wait</h1><p>退出有三种方式：_exit n,exit n, return n </p><p>exit会处理用户定义的回调以及flush IO缓冲区，最后调用_exit </p><p>return等于exit </p><p>子进程退出后，pid和状态信息并不会立即释放掉。这样设计是为了记录一些进程运行过程中的状态。这样的进程就成为了<strong>僵尸进程</strong>。 </p><p>当父进程调用wait给子进程收尸后，僵尸进程的资源才会释放掉。另外在子进程死掉的时候，会给父进程发送SIGCHLD信号，如果父进程回应一个SIG_IGN，那么子进程的pid和状态信息也会立即释放掉。 </p><p>wait族函数有三个： </p><ul><li><p>wait阻塞父进程，获取任意一个退出的子进程的状态信息 </p></li><li><p>waitpid可以精确控制给哪一个pid/pgid的进程收尸，还可以设置为非阻塞，还可以获取子进程的暂停和继续的状态 </p></li><li><p>waitid是加强版waitpid，特色功能是可以只获取子进程的状态信息，而不会释放子进程的状态信息。wait和waitpid在获取后内核都会释放子进程的资源。 </p></li></ul><h2 id="exit和wait的内核实现"><a href="#exit和wait的内核实现" class="headerlink" title="exit和wait的内核实现"></a>exit和wait的内核实现</h2><p>在进程退出以后，还有两件事情要做： </p><ol><li><p>作为父进程，需要为子进程寻找新的父进程 </p></li><li><p>作为子进程，需要通知父进程为自己收尸 </p></li></ol><p>对于1来说，首先是寻找同一线程组中的其他线程作为新的父进程（假设是多线程下某个线程退出了），如果没找到，就交给init进程。父进程这时候也可以发送信号给子进程。 </p><p>对于2来说，多线程下只有线程组主线程会通知父进程（或者主线程先退出了，线程组中最后一个线程也会通知父进程）。通知方式有两种：1.子进程可以发送SIGCHILD信号给父进程处理，父进程在信号处理函数中调用waitpid处理。2.父进程调用wait主动等待，将一个结构体加入到wait_childexit等待队列中。子进程在退出时会调用_wake_up_parent唤醒等待队列中的父进程。 </p><h1 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h1><p>OS提供的系统调用是execve，原型是<code>int execve(cons char *path, char *const argv[], char *const envp[])</code> </p><p>path是可执行文件路径，argv[]是参数数组。argv[0]一般设为可执行文件名，在获取参数时会跳过。evp是环境变量表。 </p><p>glibc封装了6个函数，<strong>execl execle execlp execv execve execvp</strong> </p><p>区别在于l代表参数是列表list(char *arg…)，v代表参数是数组vector(char *argv[])，p代表会自动解析PATH变量，e代表需要手动传入环境变量。 </p><p>在内核实现上，首先会打开文件，然后把参数和环境变量复制到bprm中，然后在linux_bfmt链表中寻找可以执行该文件的解释器，如果找不到任何一个可用的解释器且没有动态加载的解释器，那么就报错。 </p><p>常见的解释器有Linux的二进制文件ELF，脚本文件SCRIPT，用户自定义的MISC </p><p>脚本开头的sheba标识也是在SCRIPT的解释器下寻找到真正的解释器，比如#!/usr/bin/env python </p><p>可以自己在MISC下面注册新的解释器给OS，用magic number或者扩展名标识 </p><p>exec后跟不会设置pid相关的值，但是信号处理会重置为SIG_DLF(除了SIG_IGN在Linux会保留) </p><h1 id="system"><a href="#system" class="headerlink" title="system"></a>system</h1><p>可以使用system函数运行一条shell命令。过程是创建一个shell进程，然后在创建一个或多个命令进程。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程的层次关系&quot;&gt;&lt;a href=&quot;#进程的层次关系&quot; class=&quot;headerlink&quot; title=&quot;进程的层次关系&quot;&gt;&lt;/a&gt;进程的层次关系&lt;/h1&gt;&lt;p&gt;pid是进程ID，pgid是进程组ID，sid是会话ID。默认情况下，新创建的进程会继承父进程的进程
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://chace.in/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境编程(0)-从应用到内核</title>
    <link href="http://chace.in/2019/10/11/Linux%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B-0-%E4%BB%8E%E5%BA%94%E7%94%A8%E5%88%B0%E5%86%85%E6%A0%B8/"/>
    <id>http://chace.in/2019/10/11/Linux环境编程-0-从应用到内核/</id>
    <published>2019-10-11T14:06:27.000Z</published>
    <updated>2019-10-12T01:57:03.845Z</updated>
    
    <content type="html"><![CDATA[<p>编译的过程： </p><p>预处理：替换宏 </p><p>编译：将源代码编译成汇编 </p><p>汇编：将汇编代码编译成二进制 </p><p>链接：地址，so </p><hr><p>编译成的ELF文件内容： </p><p>header信息 magic数 </p><p>代码段 数据段 bss零值数据段 </p><hr><p>运行时：strace可以追踪程序的系统调用 </p><p>加载ld.so </p><p>加载glibc.so </p><p>mmap将二进制映射到内存 </p><p>执行main函数 </p><hr><p>glibc封装了系统调用，实现上基本是宏定义的汇编代码。因此用户并不需要关心自己写的代码是用户态还是内核态。系统调用的名字和参数通过寄存器传递。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编译的过程： &lt;/p&gt;
&lt;p&gt;预处理：替换宏 &lt;/p&gt;
&lt;p&gt;编译：将源代码编译成汇编 &lt;/p&gt;
&lt;p&gt;汇编：将汇编代码编译成二进制 &lt;/p&gt;
&lt;p&gt;链接：地址，so &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;编译成的ELF文件内容： &lt;/p&gt;
&lt;p&gt;header信息 magic数 &lt;/p
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://chace.in/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程编程实战指南(8)-线程管理</title>
    <link href="http://chace.in/2019/10/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97-8-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://chace.in/2019/10/11/Java多线程编程实战指南-8-线程管理/</id>
    <published>2019-10-11T13:23:17.000Z</published>
    <updated>2019-10-12T01:56:01.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><p>ThreadGroup是个隐含的概念，通常情况下不用管。</p><p>uncaughtExceptionHandler可以用来处理线程的异常退出状态，比如实现线程退出重启。uncaughtExceptionHandler实例选择的优先级：本线程设置的handler &gt; 线程池handler &gt; 默认的handler。</p><p>ThreadFactory用工厂模式来生产一组统一格式的线程，比如统一的线程名前缀、统一的uncaughtExceptionHandler。</p><p>可以用condition的wait、signalAll实现已经被废弃的Thread.suspend()和Thread.resume()方法。</p><p>线程池可以减少线程创建销毁的次数从而减少开销，同时更有效利用CPU资源。向线程池中提交Callable任务返回Future对象，future对象可以获取任务的执行结果、取消任务、判断任务是否执行。future对象还可以捕获线程池中线程的uncaughtException。<strong>如果线程池不再使用，记得调用shutdown/shutdownNow</strong>。executor对象有一些获取线程池状态的方法，据此可以监控线程池，也有beforeExecute和afterExecute回调可以在任务执行前后进行一些操作。对于线程池中线程的uncaughtExceptionHandler，只对通过executor.execute()方法提交的任务有效。<strong>同一线程池中不要提交有相互依赖关系的任务，会导致死锁。</strong></p><h1 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maxPoolSize, BlockingQueue&lt;Runnable&gt; bq, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span>;</span><br></pre></td></tr></table></figure><p>线程池在启动后，根据参数的prestartAllCoreThreads或者prestartCoreThread启动corePoolSize的线程或者启动一个线程。如果这两者都没有设定，那么就会新来一个task就创建一个线程，线程是由参数里的ThreadFactory创建的。</p><p>当线程数量达到corePoolSize以后，新的task将会加入到参数中的BlockingQueue中，线程池中任务在执行完当前任务后，会尝试去BlockingQueue中取新的task(空闲线程回收也是在这一步完成的，具体见下面)。</p><p>当BlockingQueue满了以后，线程池会继续创建新的线程直到maxPoolSize。如果线程数量达到maxPoolSize并且BlockingQueue也满了，线程池会执行拒绝策略，具体的拒绝策略依然由用户传入的参数决定，默认是直接丢弃。</p><h1 id="线程池的空闲线程回收的细节"><a href="#线程池的空闲线程回收的细节" class="headerlink" title="线程池的空闲线程回收的细节"></a>线程池的空闲线程回收的细节</h1><p>空闲线程回收实际上在worker去getTask的时候实现的。如果是allowCoreThreadTimeOut或者当前线程数大于corePoolSize的情况下，会去尝试调用workQueue.poll(keepAliveTime)，否则调用workQueue.take()。poll在队列为空时会等待超时返回null，take会无限等待。poll或者take返回null时，会回收当前线程，这样就达到了等待keepAliveTime回收空闲线程的效果(也就是队列中没有新的task)。</p><p>所以，<strong>只有在allowCoreThreadTimeOut或者当前线程数大于corePoolSize的情况下，才会回收空闲线程</strong>。也就是说，只有在设置allowCoreThreadTimeOut=true的情况下，才会回收corePoolSize的线程。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://objcoding.com/2019/04/14/threadpool-some-settings/" target="_blank" rel="noopener">关于初始化线程和核心线程是否会被回收</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程管理&quot;&gt;&lt;a href=&quot;#线程管理&quot; class=&quot;headerlink&quot; title=&quot;线程管理&quot;&gt;&lt;/a&gt;线程管理&lt;/h1&gt;&lt;p&gt;ThreadGroup是个隐含的概念，通常情况下不用管。&lt;/p&gt;
&lt;p&gt;uncaughtExceptionHandler可以
      
    
    </summary>
    
    
      <category term="Java" scheme="http://chace.in/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Airflow源码分析(4)-scheduler分析</title>
    <link href="http://chace.in/2019/09/15/Airflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-scheduler%E5%88%86%E6%9E%90/"/>
    <id>http://chace.in/2019/09/15/Airflow源码分析-4-scheduler分析/</id>
    <published>2019-09-15T09:54:15.000Z</published>
    <updated>2019-09-16T09:40:39.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scheduler的主循环"><a href="#scheduler的主循环" class="headerlink" title="scheduler的主循环"></a>scheduler的主循环</h2><p>scheduler的逻辑：</p><ol><li>遍历DAG路径下的所有dag文件</li><li>启动一定数量的进程（进程池），并且给每个进程指派一个dag文件。每个进程解析分配给它的dag文件，并根据解析结果在DB中创建DagRun和TaskInstance。对于满足执行条件的TaskInstance，将状态修改为SCHEDULED</li><li>在scheduler的主循环中，查询状态为SCHEDULED的TaskInstance，并将这个TI发送给executor异步执行。至于怎么执行scheduler就不管了，只需要从executor同步状态信息。</li><li>在进程池中如果有进程完成了，则创建新的进程处理下一个dag文件，并且保证这个进程池的进程数量不会超过配置的数量。</li><li>一旦所有的dag处理完毕后，就会进行下一轮循环处理。这里还有一个细节就是上一轮的某个dag的处理时间可能很长，导致到下一轮处理的时候这个dag还没有处理完成。Airflow的处理逻辑是在这一轮不为这个dag创建进程，这样不会阻塞进程去处理其余dag。</li></ol><p><img src="/img/2019/09/scheduler_loop.jpg" alt="scheduler loop"><br>scheduler的主循环(_execute_helper)：</p><ol><li>收集从DagFileProcessorAgent得到的DAG解析结果</li><li>查找并且将可执行的task放入executor的队列<ol><li>改变task instance在DB中的状态</li><li>将task加入到executor的队列中</li></ol></li><li>发送心跳给executor<ol><li>executor在收到心跳后会异步执行队列中的task</li><li>同步task的状态</li></ol></li></ol><p>DagFileProcessorManager的主循环(start_in_async)：</p><ol><li>判断是否需要刷新当前的dag列表</li><li>从维护的进程池中取得DAG解析结果，并加入到result_queue中。result_queue中的数据会被agent在主循环中拿走</li></ol><p>原文：<br>The actual scheduler loop. The main steps in the loop are:</p><ol><li>Harvest DAG parsing results through DagFileProcessorAgent</li><li>Find and queue executable tasks<ol><li>Change task instance state in DB</li><li>Queue tasks in executor</li></ol></li><li>Heartbeat executor<ol><li>Execute queued tasks in executor asynchronously</li><li>Sync on the states of running tasks</li></ol></li></ol><p>The logic for scheduling is as follows:</p><ol><li>Enumerate the all the files in the DAG directory.</li><li>Start a configurable number of processes and for each one, assign a DAG file to process.<br>In each child process, parse the DAG file, create the necessary DagRuns given the state of the DAG’s task instances, and for all the task instances that should run, create a TaskInstance (with the <code>SCHEDULED</code> state) in the ORM.</li><li>Back in the main scheduler process, query the ORM for task instances in the <code>SCHEDULED</code> state. If any are found, send them to the executor and set the task instance state to <code>QUEUED</code>.</li><li>If any of the child processes have finished, create another process to work on the next file in the series, provided that the number of running processes is less than the configured limit. </li><li>Once a process has been launched for all of the files in the DAG directory, the cycle is repeated. If the process to parse a particular DAG file is still running when the file’s turn comes up in the next cycle, a new process is not launched and a process for the next file in the series is launched instead. This way, a DAG file that takes a long time to parse does not necessarily block the processing of other DAGs.</li></ol><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>DagFileProcessor在子进程中解析DAG定义文件。对于发现的DAG，检查DagRun和TaskInstance的状态。如果有TaskInstance可以运行，将状态标记为<code>SCHEDULED</code>。</p><p>DagFileProcessorManager控制DagFileProcessors如何启动。它追踪哪些文件应该被处理并且确保一旦一个DagFileProcessor完成解析，下一个dag文件应该得到处理。并且控制DagFileProcessors的数量。</p><p>SchedulerJob通过agent获取manager的DAG定义文件解析结果，并且将<code>SCHEDULED</code>状态的TI发送给executor执行。</p><p>DagFileProcessorAgent作为一个采集代理，scheduler可以借助agent获取manager获取到的dag解析结果，并且可以控制manager的行为。</p><p>PS: DagFileProcessor中的process_file部分逻辑写在SchedulerJob中，当时也是让我对代码困惑的一点。</p><p>原文：<br>The DagFileProcessor launches a child process to parse a DAG definition file. For the DAGs found in the file, it examines DAG runs and the state of the task instances. If there are task instances that should run, it creates them in the <code>SCHEDULED</code> state.</p><p>The DagFileProcessorManager coordinates how DagFileProcessors are launched. It keeps track of which files need to be processed and ensures that once a DagFileProcessor is done, the next file in the series is processed accordingly. It also controls the number of simultaneous DagFileProcessors and ensures that the number if simultaneous instances do not exceed the configured limit.</p><p>The SchedulerJob coordinates parsing of the DAG definition files using the DagFileProcessorManager and sends task instances in the <code>SCHEDULED</code> state to the executor.</p><h2 id="常见问题分析"><a href="#常见问题分析" class="headerlink" title="常见问题分析"></a>常见问题分析</h2><ol><li><p>DAG是如何被解析的？哪个进程中实现？</p><ul><li>在将py代码load_source时即被解析，对于每个task对象，保存有它的上下游task，后面统一进行Dep检测。</li><li>Dep检测是一级一级串联的，除了上下游依赖关系，还有时间关系、多种触发规则的判断。</li><li>DAG加载解析是在DagFileProcessor进程中完成的，同时也是在DagFileProcessor中标记哪些task是scheduled的状态，而在主进程中只需要查找得到这些状态的task即可。</li></ul></li><li><p>DagFileProcessor的作用？</p><ul><li>解析特定的dag文件，调用process_file</li><li>根据dag文件创建合适的DagRun和TaskInstance</li><li>解析依赖关系将可以调度的TaskInstance标记为scheduled</li></ul></li><li><p>SimpleDag和SimpleDagBag发挥了什么作用？<br>用于调度，保存有调度需要的字段而不包含执行需要的字段</p></li><li><p>为什么scheduler需要agent的返回result_queue，不是直接在DB中查找scheduled的TaskInstance吗？<br>scheduler只调度simple_dagbag中的任务</p></li><li><p>scheduler支持水平扩容吗？如何做到高可用？<br>不支持。但是可以高可用部署，一个scheduler挂了以后立即启动另一个scheduler。同时因为元数据保存在DB中，可以从DB中恢复。</p></li><li><p>scheduler是如何解决可能调度同一DAG两次的问题的？<br>每个DAG分配一个进程，在DagFileProcessorManager中保存有dag和processor的映射表。在dag没有被任何processor处理的时候，才会给它创建新的处理进程。</p></li><li><p>手动触发的DAG有何不同？<br>手动触发的DAG直接创建DR和TI，因此不需要经过DagFileProcessor创建。但是在创建以后，仍然是DagFileProcessor将TI的状态更改为SCHEDULED。</p></li></ol><h2 id="并发控制分析"><a href="#并发控制分析" class="headerlink" title="并发控制分析"></a>并发控制分析</h2><h3 id="1-DagFileProcessor的进程个数控制"><a href="#1-DagFileProcessor的进程个数控制" class="headerlink" title="1. DagFileProcessor的进程个数控制"></a>1. DagFileProcessor的进程个数控制</h3><p>配置项：max_threads<br>实现：在Manager的heartbeat()中会比较当前processor数和这个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start more processors if we have enough slots and files to process</span></span><br><span class="line"><span class="keyword">while</span> (self._parallelism - len(self._processors) &gt; <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">        len(self._file_path_queue) &gt; <span class="number">0</span>):</span><br><span class="line">    file_path = self._file_path_queue.pop(<span class="number">0</span>)</span><br><span class="line">    processor = self._processor_factory(file_path, zombies)</span><br><span class="line"></span><br><span class="line">    processor.start()</span><br><span class="line">    self.log.debug(</span><br><span class="line">        <span class="string">"Started a process (PID: %s) to generate tasks for %s"</span>,</span><br><span class="line">        processor.pid, file_path</span><br><span class="line">    )</span><br><span class="line">    self._processors[file_path] = processor</span><br></pre></td></tr></table></figure><h3 id="2-同时运行的最大TaskInstance数量"><a href="#2-同时运行的最大TaskInstance数量" class="headerlink" title="2. 同时运行的最大TaskInstance数量"></a>2. 同时运行的最大TaskInstance数量</h3><p>配置项：parallelism<br>实现：在Executor的heartbeat()中会根据parallelism得出当前可用的slots数量，决定execute_async多少task</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Triggering new jobs</span></span><br><span class="line"><span class="comment"># 计算open_slots数量</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.parallelism:</span><br><span class="line">    open_slots = len(self.queued_tasks)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    open_slots = self.parallelism - len(self.running)</span><br><span class="line"><span class="comment"># 将open_slots数量的task执行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(min((open_slots, len(self.queued_tasks)))):</span><br><span class="line">    key, (command, _, queue, simple_ti) = sorted_queue.pop(<span class="number">0</span>)</span><br><span class="line">    self.queued_tasks.pop(key)</span><br><span class="line">    self.running[key] = command</span><br><span class="line">    self.execute_async(key=key,</span><br><span class="line">                        command=command,</span><br><span class="line">                        queue=queue,</span><br><span class="line">                        executor_config=simple_ti.executor_config)</span><br></pre></td></tr></table></figure><h3 id="3-scheduler控制一次加入到queue中的TI个数"><a href="#3-scheduler控制一次加入到queue中的TI个数" class="headerlink" title="3. scheduler控制一次加入到queue中的TI个数"></a>3. scheduler控制一次加入到queue中的TI个数</h3><p>配置项：max_tis_per_query<br>实现：scheduler的主循环中找出那些ti可以被执行后，reduce_in_chunk时选的chunk_size就是这个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_execute_task_instances</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                                simple_dag_bag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                states,</span></span></span><br><span class="line"><span class="function"><span class="params">                                session=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Attempts to execute TaskInstances that should be executed by the scheduler.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        There are three steps:</span></span><br><span class="line"><span class="string">        1. Pick TIs by priority with the constraint that they are in the expected states</span></span><br><span class="line"><span class="string">        and that we do exceed max_active_runs or pool limits.</span></span><br><span class="line"><span class="string">        2. Change the state for the TIs above atomically.</span></span><br><span class="line"><span class="string">        3. Enqueue the TIs in the executor.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        executable_tis = self._find_executable_task_instances(simple_dag_bag, states,</span><br><span class="line">                                                              session=session)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(result, items)</span>:</span></span><br><span class="line">            simple_tis_with_state_changed = \</span><br><span class="line">                self._change_state_for_executable_task_instances(items,</span><br><span class="line">                                                                 states,</span><br><span class="line">                                                                 session=session)</span><br><span class="line">            self._enqueue_task_instances_with_queued_state(</span><br><span class="line">                simple_dag_bag,</span><br><span class="line">                simple_tis_with_state_changed)</span><br><span class="line">            session.commit()</span><br><span class="line">            <span class="keyword">return</span> result + len(simple_tis_with_state_changed)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helpers.reduce_in_chunks(query, executable_tis, <span class="number">0</span>, self.max_tis_per_query)</span><br></pre></td></tr></table></figure><h3 id="4-扫描文件夹获取新的dag的时间间隔"><a href="#4-扫描文件夹获取新的dag的时间间隔" class="headerlink" title="4. 扫描文件夹获取新的dag的时间间隔"></a>4. 扫描文件夹获取新的dag的时间间隔</h3><p>配置项：dag_dir_list_interval<br>实现：在Manager的主循环(start_in_async)中每次循环都会调用_refresh_dag_dir()去判断是否满足刷新list_py_file_paths得到新加入的dag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">elapsed_time_since_refresh = (timezone.utcnow() -</span><br><span class="line">                                      self.last_dag_dir_refresh_time).total_seconds()</span><br><span class="line"><span class="keyword">if</span> elapsed_time_since_refresh &gt; self.dag_dir_list_interval:</span><br><span class="line">    <span class="comment"># Build up a list of Python files that could contain DAGs</span></span><br><span class="line">    self.log.info(<span class="string">"Searching for files in %s"</span>, self._dag_directory)</span><br><span class="line">    self._file_paths = list_py_file_paths(self._dag_directory)</span><br><span class="line">    self.last_dag_dir_refresh_time = timezone.utcnow()</span><br></pre></td></tr></table></figure><h3 id="5-控制DagFileProcessor解析DAG的速度"><a href="#5-控制DagFileProcessor解析DAG的速度" class="headerlink" title="5. 控制DagFileProcessor解析DAG的速度"></a>5. 控制DagFileProcessor解析DAG的速度</h3><p>配置项：min_file_process_interval<br>在Manager的主循环的heartbeat()中会上一次解析完成时间到现在的时间间隔，如果小于min_file_process_interval，则跳过这个dag的解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now = timezone.utcnow()</span><br><span class="line">file_paths_recently_processed = []</span><br><span class="line"><span class="keyword">for</span> file_path <span class="keyword">in</span> self._file_paths:</span><br><span class="line">    last_finish_time = self.get_last_finish_time(file_path)</span><br><span class="line">    <span class="keyword">if</span> (last_finish_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span></span><br><span class="line">        (now - last_finish_time).total_seconds() &lt;</span><br><span class="line">            self._file_process_interval):</span><br><span class="line">        file_paths_recently_processed.append(file_path)</span><br></pre></td></tr></table></figure><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>很多地方用到了chunk_reduce，用来进行小的分批处理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chunks</span><span class="params">(items, chunk_size)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Yield successive chunks of a given size from a list of items</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> chunk_size &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Chunk size must be a positive integer'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(items), chunk_size):</span><br><span class="line">        <span class="keyword">yield</span> items[i:i + chunk_size]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce_in_chunks</span><span class="params">(fn, iterable, initializer, chunk_size=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Reduce the given list of items by splitting it into chunks</span></span><br><span class="line"><span class="string">    of the given size and passing each chunk through the reducer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(iterable) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> initializer</span><br><span class="line">    <span class="keyword">if</span> chunk_size == <span class="number">0</span>:</span><br><span class="line">        chunk_size = len(iterable)</span><br><span class="line">    <span class="keyword">return</span> reduce(fn, chunks(iterable, chunk_size), initializer)</span><br></pre></td></tr></table></figure></p><p>dagbag在解析dag文件时，只会对最近修改过的文件进行解析<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file_last_changed_on_disk = datetime.fromtimestamp(os.path.getmtime(filepath))</span><br><span class="line"><span class="keyword">if</span> only_if_updated \</span><br><span class="line">        <span class="keyword">and</span> filepath <span class="keyword">in</span> self.file_last_changed \</span><br><span class="line">        <span class="keyword">and</span> file_last_changed_on_disk == self.file_last_changed[filepath]:</span><br><span class="line">    <span class="keyword">return</span> found_dags</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>scheduler毫无疑问是整个Airflow的核心模块，逻辑复杂，从中可以一瞥典型scheduler的典型逻辑。</p><p>本文从scheduler的主要逻辑入手，分析了控制循环和代码结构，重点分析了物理实现上的并发控制和性能优化。</p><p>但是<strong>DAG的并发控制其实不止于此，还有同一Dag的DagRun并发执行数量控制、Dag的TaskInstance并发执行数量控制、TaskInstance运行在特定大小的Pool中进行数量控制</strong>。这些并发控制由Airflow的使用者在定义DAG时指定，在实现上是在scheduler的主循环中实现，也就是在将taskinstance加入到executor的队列前进行这些限制条件的判断。不满足条件的TI，即使是<code>SCHEDULED</code>的状态，也不会加入到executor的队列，也就不会变为<code>QUEUED</code>状态。这块的逻辑在<code>SchedulerJob#_find_executable_task_instances</code>方法中，就不展开讲了。</p><p>另外本部分代码也是Python多进程编程的一个典型案例，比如manager维护的进程池、agent与manager使用Pipe和Queue进行通信、scheduler借助agent维护manager的生命周期。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://cwiki.apache.org/confluence/display/AIRFLOW/Scheduler+Basics" target="_blank" rel="noopener">Airflow Scheduler Basics</a></li><li><a href="https://hieast.github.io/2018/03/26/Airflow%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Airflow工作原理</a></li><li><a href="https://blog.csdn.net/ggz631047367/article/details/83507305" target="_blank" rel="noopener">Airflow整体架构</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scheduler的主循环&quot;&gt;&lt;a href=&quot;#scheduler的主循环&quot; class=&quot;headerlink&quot; title=&quot;scheduler的主循环&quot;&gt;&lt;/a&gt;scheduler的主循环&lt;/h2&gt;&lt;p&gt;scheduler的逻辑：&lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Airflow" scheme="http://chace.in/tags/Airflow/"/>
    
      <category term="任务编排调度" scheme="http://chace.in/tags/%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-Best Time to Buy and Sell Stock</title>
    <link href="http://chace.in/2019/09/09/leetcode%E9%A2%98%E8%A7%A3-Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>http://chace.in/2019/09/09/leetcode题解-Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2019-09-09T11:46:04.000Z</published>
    <updated>2019-09-09T12:27:02.685Z</updated>
    
    <content type="html"><![CDATA[<p>对LeetCode上遇到的股票问题做一个总结，涉及到6道题：121, 122, 123, 188, 309, 714</p><p>题目地址：<a href="https://leetcode.com/problemset/all/?search=Best%20Time%20to%20Buy%20and%20Sell%20Stock" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a></p><p>这些题的总体要求都是<strong>根据每天的股价涨跌来决定买卖股票，使得总体的利润最大</strong>，但是对于不同题有不同的限定条件，难度也是越来越大，其中4道题都是DP求解。</p><h2 id="121-Easy"><a href="#121-Easy" class="headerlink" title="121(Easy)"></a>121(Easy)</h2><p>题目：最多进行一次买卖。求最大利润。</p><p>这个就很简单了，直接找到最低价格买入，再在最高价格卖出就OK了。<br>可以用暴力的方法去进行两层遍历，先在外层循环找波谷再在内层循环找波峰，复杂度O(N^2)；<br>另一种方法是<strong>记录波谷的价格和最大利润，在遍历过程中更新波谷和最大利润就OK了</strong>，复杂度O(N)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: prices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; minprice)</span><br><span class="line">                minprice = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = p - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="122-Easy"><a href="#122-Easy" class="headerlink" title="122(Easy)"></a>122(Easy)</h2><p>题目：可以进行任意次买卖。求最大利润。</p><p>这题的思路就是<strong>每次波谷买入，每次波峰卖出就可以</strong>。PS：在188题还会用到这种解法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 寻找波谷和波峰，每次都在波谷买入，波峰卖出就可以让利润最大</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valley = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> peak = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; prices.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 寻找波谷买入</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; prices.length-<span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            valley = prices[i];</span><br><span class="line">            <span class="comment">// 寻找波峰卖出</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; prices.length-<span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            peak = prices[i];</span><br><span class="line">            maxprofit += peak - valley;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="comment">// 这种方法是只要能赚钱就计算利润，也就是类比于：在这一天卖出再买入就可以得到利润</span></span><br><span class="line"><span class="comment">// 跟上面的方法的结果是一样的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public int maxProfit(int[] prices) &#123;</span></span><br><span class="line"><span class="comment">        int maxprofit = 0;</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt; prices.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (prices[i] &gt; prices[i - 1])</span></span><br><span class="line"><span class="comment">                maxprofit += prices[i] - prices[i - 1];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return maxprofit;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="123-Hard"><a href="#123-Hard" class="headerlink" title="123(Hard)"></a>123(Hard)</h2><p>题目：最多进行两次买卖。求最大利润。</p><p>看起来题目跟121差不多，但是难度却大了很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sell1 = <span class="number">0</span>, sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy1 = Integer.MIN_VALUE, buy2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            <span class="comment">// 第一次买，让借的钱尽可能少。因为是负数，所以也用Math.max</span></span><br><span class="line">            <span class="comment">// 这里可以看成Math.max(buy1, 0-p)，这样跟下面的buy2就统一了</span></span><br><span class="line">            buy1 = Math.max(buy1, -p);</span><br><span class="line">            <span class="comment">// 第一次卖，让利润尽量多，因为buy1是负数，所以还是取p+buy1</span></span><br><span class="line">            sell1 = Math.max(sell1, buy1+p);</span><br><span class="line">            <span class="comment">// 第二次买，让第一次卖的利润跟当前价格之差最大，即让买完以后利润依然最大</span></span><br><span class="line">            buy2 = Math.max(buy2, sell1-p);</span><br><span class="line">            <span class="comment">// 第二次卖，让利润最大</span></span><br><span class="line">            sell2 = Math.max(sell2, buy2+p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="188-Hard"><a href="#188-Hard" class="headerlink" title="188(Hard)"></a>188(Hard)</h2><p>题目：最多进行k次买卖。求最大利润。</p><p>在123题基础上又加大难度了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (prices.length/<span class="number">2</span> &lt;= k) &#123;</span><br><span class="line">            <span class="comment">// 可以随便交易，所以变成了122题</span></span><br><span class="line">            simpleProfit(prices)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] sell = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][prices.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> buy = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 仔细看会发现这里每一次交易的解法跟123题是一样的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 这里buy可以用一个临时变量替换，只对当前这次i有用</span></span><br><span class="line">                <span class="comment">// 但是sell不能弄成一维的，因为会引用到sell[i-1][j-1]</span></span><br><span class="line">                <span class="comment">// 如果只用一维的，那么每次的sell[i-1]都只能是这次i的</span></span><br><span class="line">                buy = Math.max(buy, sell[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">                sell[i][j] = Math.max(sell[i][j - <span class="number">1</span>], buy + prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k][prices.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的解法就是122题的解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">simpleProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                result += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="309-Medium"><a href="#309-Medium" class="headerlink" title="309(Medium)"></a>309(Medium)</h2><p>题目：在卖出以后必须冷却1天才能再次买入。求最大利润。</p><p>有了前面和buy和sell，这道题要解决起来也比较容易。<br><strong>冷却1天可以用<code>buy[i]=sell[i-2]-prices[i]</code>来表达</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了节省空间，没有用数组，而是直接用的buy和sell</span></span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>, prev_sell = <span class="number">0</span>, buy = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 今天没有买；或者今天买了，注意buy[i]=sell[i-2]-prices[i]</span></span><br><span class="line">            buy = Math.max(buy, prev_sell-prices[i]);</span><br><span class="line">            <span class="comment">// 只有赋值放在这里prev_cash才是cash[i-2]</span></span><br><span class="line">            prev_sell = sell;</span><br><span class="line">            <span class="comment">// 今天没有卖；或者今天卖了</span></span><br><span class="line">            sell = Math.max(sell, buy+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="714-Medium"><a href="#714-Medium" class="headerlink" title="714(Medium)"></a>714(Medium)</h2><p>题目：卖出的时候有手续费。求最大利润。</p><p><strong>计算的时候把手续费考虑进来：<code>sell[i]=buy[i-1]+prices[i]-fee</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>, buy = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 今天没有买；或者今天买了</span></span><br><span class="line">            buy = Math.max(buy, sell - prices[i]);</span><br><span class="line">            <span class="comment">// 今天没有卖；或者今天卖了，注意有手续费</span></span><br><span class="line">            sell = Math.max(sell, buy + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对LeetCode上遇到的股票问题做一个总结，涉及到6道题：121, 122, 123, 188, 309, 714&lt;/p&gt;
&lt;p&gt;题目地址：&lt;a href=&quot;https://leetcode.com/problemset/all/?search=Best%20Time%2
      
    
    </summary>
    
    
      <category term="算法" scheme="http://chace.in/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>k8s核心组件分析-scheduler</title>
    <link href="http://chace.in/2019/09/02/k8s%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90-scheduler/"/>
    <id>http://chace.in/2019/09/02/k8s核心组件分析-scheduler/</id>
    <published>2019-09-02T07:36:10.000Z</published>
    <updated>2019-12-12T12:30:21.963Z</updated>
    
    <content type="html"><![CDATA[<p>k8s中的scheduler负责资源调度，具体来说，是将某个pod绑定到某个node上。scheduler的输入是待调度的pod和可调度的node，输出是pod和node的bind对象。</p><p><img src="../img/2019/09/k8s-scheduler.png" alt="scheduler的输入输出"></p><h2 id="k8s采集数据"><a href="#k8s采集数据" class="headerlink" title="k8s采集数据"></a>k8s采集数据</h2><p>要进行调度首先得知道哪些需要调度，哪些node可以调度，调度策略需要很多信息来进行决策。k8s中并不会有消息队列来进行组件之间的通信，scheduler是直接访问APIServer来获取集群信息的。但是如果是暴力轮询肯定会给APIServer带来很大负担。所以scheduler在本地做了cache。</p><p>本地cache主要有两种，一种是对于有序资源信息，比如待调度的pod，使用Queue来保存；另一种是无序资源信息，比如可调度的node，使用链表保存。</p><h2 id="k8s的调度算法"><a href="#k8s的调度算法" class="headerlink" title="k8s的调度算法"></a>k8s的调度算法</h2><p>k8s的调度算法是可插拔的，由算法provider提供，一个provider即提供一个调度策略集合，而这个调度策略集合下会包括很多的计算方法。</p><p>这些具体的计算方法包括两类：predicates和priorities。</p><p>predicates解决pod能不能被调度到某个node上去，而priorities是在可调度的node中排优先级。</p><h3 id="predicates"><a href="#predicates" class="headerlink" title="predicates"></a>predicates</h3><p>有判断会不会HostPort冲突的，也有判断NodeSelector的。所有predicates都满足，则该pod和该node是可以绑定的。</p><h3 id="priorities"><a href="#priorities" class="headerlink" title="priorities"></a>priorities</h3><p>这里是采用计算score的方式。每个priority算法返回一个0~10的score，然后计算<code>sum = priorities · weights</code>(这里是点乘的意思)。调度pod到得分最高的pod上去。</p><p>一般就根据资源分配情况，selector的分配情况来计算。</p><h2 id="k8s的启动与运行"><a href="#k8s的启动与运行" class="headerlink" title="k8s的启动与运行"></a>k8s的启动与运行</h2><ol><li>收集scheduler产生的事件信息，发送给APIServer</li><li>创建一个http server，端口默认是10250</li><li>根据配置创建启动scheduler</li><li>注册metrics规则，检测scheduler的性能</li></ol><p>k8s在完成绑定以后，其实是创建了一个Binding对象，发送给APIServer。（最后由Controller Manager通知绑定的node的kubelet创建绑定的pod）</p><h2 id="multi-scheduler的问题"><a href="#multi-scheduler的问题" class="headerlink" title="multi-scheduler的问题"></a>multi-scheduler的问题</h2><p>如果需要多个调度器，目前的解决办法是使用annotations的方式给pod指定由某个scheduler调度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;k8s中的scheduler负责资源调度，具体来说，是将某个pod绑定到某个node上。scheduler的输入是待调度的pod和可调度的node，输出是pod和node的bind对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/2019/09/k8s-schedul
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://chace.in/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Docker架构分析</title>
    <link href="http://chace.in/2019/09/01/Docker%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://chace.in/2019/09/01/Docker架构分析/</id>
    <published>2019-09-01T11:34:33.000Z</published>
    <updated>2019-09-02T02:05:45.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker架构概览"><a href="#Docker架构概览" class="headerlink" title="Docker架构概览"></a>Docker架构概览</h2><p><strong>网上很多架构图中都有Docker Engine和Job，但是1.7版本其实不再用这种方式。</strong></p><p>Docker使用C/S架构。用户通过Docker client与Docker daemon通信，Docker daemon中有个API Server处理具体请求。而具体到后端的实际操作，Docker则分了很多模块，其中对容器运行时、volume、镜像以及网络方面的具体实现已经放在daemon以外的模块中。</p><p><img src="/img/2019/09/docker.png" alt="Docker架构"></p><p>其中execdriver是容器执行驱动，volumedriver是volume存储驱动，graphdriver是镜像存储驱动。</p><p>网络部分现在已经分离成一个libnetwork库独立维护。</p><h2 id="client和daemon"><a href="#client和daemon" class="headerlink" title="client和daemon"></a>client和daemon</h2><p>client模式的命令基本就是执行对应方法，向daemon发起请求，之后读取docker daemon的返回结果。</p><p>daemon首先要启动一个API server，然后创建各种容器配置和环境(/var/lib/docker/)以及网络，最后一个daemon对象诞生。</p><p>启动容器再执行下去就是去调用execdriver了，这一块再交由底层模块处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker架构概览&quot;&gt;&lt;a href=&quot;#Docker架构概览&quot; class=&quot;headerlink&quot; title=&quot;Docker架构概览&quot;&gt;&lt;/a&gt;Docker架构概览&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;网上很多架构图中都有Docker Engine和Job，但是
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://chace.in/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Airflow源码分析(3)-jinja渲染部分</title>
    <link href="http://chace.in/2019/09/01/Airflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(3)-jinja%E6%B8%B2%E6%9F%93%E9%83%A8%E5%88%86/"/>
    <id>http://chace.in/2019/09/01/Airflow源码分析(3)-jinja渲染部分/</id>
    <published>2019-09-01T04:07:37.000Z</published>
    <updated>2019-09-01T04:20:58.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Jinja渲染在Airflow用于参数跟字段的渲染，这里做一个简单的实现分析。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>模板渲染的流程是在TaskInstance()._run_raw_task()中进行的。</p><h3 id="run-raw-task"><a href="#run-raw-task" class="headerlink" title="_run_raw_task"></a>_run_raw_task</h3><p>_run_raw_task大致的逻辑如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_raw_task</span><span class="params">(...)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 渲染模板主要在这两个函数里面</span></span><br><span class="line">context = self.get_template_context()</span><br><span class="line">self.render_templates()</span><br><span class="line"><span class="comment"># 真正地执行</span></span><br><span class="line">task_copy.pre_execute(context=context)</span><br><span class="line">result = task_copy.execute(context=context)</span><br><span class="line">task_copy.post_execute(context=context, result=result)</span><br><span class="line"><span class="keyword">except</span> AirflowSkipException:</span><br><span class="line">    self.state = State.SKIPPED</span><br><span class="line"><span class="keyword">except</span> AirflowRescheduleException：</span><br><span class="line">self._handle_reschedule()</span><br><span class="line"><span class="keyword">except</span> Error:</span><br><span class="line"><span class="comment"># 会处理retry的情况以及on_failure_callback()</span></span><br><span class="line">self.handle_failure()</span><br><span class="line"><span class="comment"># 执行成功时的回调函数</span></span><br><span class="line"><span class="keyword">if</span> task.on_success_callback:</span><br><span class="line">                task.on_success_callback(context)</span><br></pre></td></tr></table></figure></p><h3 id="get-template-context"><a href="#get-template-context" class="headerlink" title="get_template_context"></a>get_template_context</h3><p>get_template_context中实际就是获取各种值，从返回值我们可以看到那些字段是可以通过context[‘variable’]拿到的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">get_template_context</span><span class="params">(self, session=None)</span>:</span></span><br><span class="line"> ...</span><br><span class="line">   <span class="comment"># 这里会发现trigger_dag中依然可以通过传递conf的方式覆盖参数值。conf是dict或者序列化的dict。</span></span><br><span class="line"><span class="comment"># 如果在airflow.cfg中，dag_run_conf_overrides_params=True的话</span></span><br><span class="line"><span class="comment"># 在pre_execute之前，会有params.update(dag_run.conf)的操作</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> configuration.getboolean(<span class="string">'core'</span>, <span class="string">'dag_run_conf_overrides_params'</span>):</span><br><span class="line">          self.overwrite_params_with_dag_run_conf(params=params, dag_run=dag_run)</span><br><span class="line">         </span><br><span class="line">         <span class="comment"># 这个类也是对应&#123;var.value.your_variable_name&#125;这种方式的实现</span></span><br><span class="line">         <span class="class"><span class="keyword">class</span> <span class="title">VariableAccessor</span>:</span></span><br><span class="line">         <span class="string">"""</span></span><br><span class="line"><span class="string">         Wrapper around Variable. This way you can get variables in templates by using</span></span><br><span class="line"><span class="string">         &#123;var.value.your_variable_name&#125;.</span></span><br><span class="line"><span class="string">         """</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">             self.var = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">             self.var = Variable.get(item)</span><br><span class="line">             <span class="keyword">return</span> self.var</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">             <span class="keyword">return</span> str(self.var)</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="string">'dag'</span>: task.dag,</span><br><span class="line">         <span class="string">'ds'</span>: ds,</span><br><span class="line">         <span class="string">'next_ds'</span>: next_ds,</span><br><span class="line">         <span class="string">'next_ds_nodash'</span>: next_ds_nodash,</span><br><span class="line">         <span class="string">'prev_ds'</span>: prev_ds,</span><br><span class="line">         <span class="string">'prev_ds_nodash'</span>: prev_ds_nodash,</span><br><span class="line">         <span class="string">'ds_nodash'</span>: ds_nodash,</span><br><span class="line">         <span class="string">'ts'</span>: ts,</span><br><span class="line">         <span class="string">'ts_nodash'</span>: ts_nodash,</span><br><span class="line">         <span class="string">'ts_nodash_with_tz'</span>: ts_nodash_with_tz,</span><br><span class="line">         <span class="string">'yesterday_ds'</span>: yesterday_ds,</span><br><span class="line">         <span class="string">'yesterday_ds_nodash'</span>: yesterday_ds_nodash,</span><br><span class="line">         <span class="string">'tomorrow_ds'</span>: tomorrow_ds,</span><br><span class="line">         <span class="string">'tomorrow_ds_nodash'</span>: tomorrow_ds_nodash,</span><br><span class="line">         <span class="string">'END_DATE'</span>: ds,</span><br><span class="line">         <span class="string">'end_date'</span>: ds,</span><br><span class="line">         <span class="string">'dag_run'</span>: dag_run,</span><br><span class="line">         <span class="string">'run_id'</span>: run_id,</span><br><span class="line">         <span class="string">'execution_date'</span>: self.execution_date,</span><br><span class="line">         <span class="string">'prev_execution_date'</span>: prev_execution_date,</span><br><span class="line">         <span class="string">'prev_execution_date_success'</span>: lazy_object_proxy.Proxy(</span><br><span class="line">             <span class="keyword">lambda</span>: self.previous_execution_date_success),</span><br><span class="line">         <span class="string">'prev_start_date_success'</span>: lazy_object_proxy.Proxy(<span class="keyword">lambda</span>: self.previous_start_date_success),</span><br><span class="line">         <span class="string">'next_execution_date'</span>: next_execution_date,</span><br><span class="line">         <span class="string">'latest_date'</span>: ds,</span><br><span class="line">         <span class="string">'macros'</span>: macros,</span><br><span class="line">         <span class="string">'params'</span>: params,</span><br><span class="line">         <span class="string">'tables'</span>: tables,</span><br><span class="line">         <span class="string">'task'</span>: task,</span><br><span class="line">         <span class="string">'task_instance'</span>: self,</span><br><span class="line">         <span class="string">'ti'</span>: self,</span><br><span class="line">         <span class="string">'task_instance_key_str'</span>: ti_key_str,</span><br><span class="line">         <span class="string">'conf'</span>: configuration,</span><br><span class="line">         <span class="string">'test_mode'</span>: self.test_mode,</span><br><span class="line">         <span class="string">'var'</span>: &#123;</span><br><span class="line">             <span class="string">'value'</span>: VariableAccessor(), <span class="comment"># NOTICE</span></span><br><span class="line">             <span class="string">'json'</span>: VariableJsonAccessor()</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">'inlets'</span>: task.inlets,</span><br><span class="line">         <span class="string">'outlets'</span>: task.outlets,</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><h3 id="render-templates"><a href="#render-templates" class="headerlink" title="render_templates"></a>render_templates</h3><p>render_templates方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_templates</span><span class="params">(self)</span>:</span></span><br><span class="line">    task = self.task</span><br><span class="line">    <span class="comment"># 这里又调用了一次get_template_context，因为有dry_run的情况</span></span><br><span class="line">    <span class="comment"># dry_run中不会调用get_template_context</span></span><br><span class="line">    jinja_context = self.get_template_context()</span><br><span class="line">    <span class="keyword">if</span> hasattr(self, <span class="string">'task'</span>) <span class="keyword">and</span> hasattr(self.task, <span class="string">'dag'</span>):</span><br><span class="line">     <span class="comment"># 这里也是user_defined_macros的实际处理</span></span><br><span class="line">     <span class="comment"># 比如user_defined_macros=dict(foo='bar')，那么可以使用&#123;&#123; foo &#125;&#125;拿到</span></span><br><span class="line">        <span class="keyword">if</span> self.task.dag.user_defined_macros:</span><br><span class="line">            jinja_context.update(</span><br><span class="line">                self.task.dag.user_defined_macros)</span><br><span class="line"></span><br><span class="line">    rt = self.task.render_template  <span class="comment"># shortcut to method</span></span><br><span class="line">    <span class="comment"># 这里可以发现Operator中定义的template_fields的作用，只有这里面的字段才会被渲染</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> task.__class__.template_fields:</span><br><span class="line">        content = getattr(task, attr)</span><br><span class="line">        <span class="keyword">if</span> content:</span><br><span class="line">            <span class="comment"># 真正的渲染逻辑在task.render_template中</span></span><br><span class="line">            <span class="comment"># 参数为(属性名，内容，上下文)</span></span><br><span class="line">            rendered_content = rt(attr, content, jinja_context)</span><br><span class="line">            <span class="comment"># 修改task的属性值为渲染后的内容</span></span><br><span class="line">            setattr(task, attr, rendered_content)</span><br></pre></td></tr></table></figure></p><h3 id="BaseOperator中的渲染"><a href="#BaseOperator中的渲染" class="headerlink" title="BaseOperator中的渲染"></a>BaseOperator中的渲染</h3><p>接下来我们进入到BaseOperator中，来看一下到底是怎么渲染的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_template</span><span class="params">(self, attr, content, context)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Renders a template either from a file or directly in a field, and returns</span></span><br><span class="line"><span class="string">    the rendered result.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 首先，初始化jinja对象</span></span><br><span class="line">    jinja_env = self.get_template_env()</span><br><span class="line"></span><br><span class="line">    exts = self.__class__.template_ext</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">            isinstance(content, six.string_types) <span class="keyword">and</span></span><br><span class="line">            any([content.endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> exts])):</span><br><span class="line">        <span class="comment"># 对于在template_ext=[]中定义的文件后缀，直接去读取文件内容渲染</span></span><br><span class="line">        <span class="comment"># 比如bash_command='test.sh', template_ext=['.sh']，那么会直接去将test.sh中的内容渲染出来</span></span><br><span class="line">        <span class="keyword">return</span> jinja_env.get_template(content).render(**context)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">     <span class="comment"># 这里继续调用自身方法</span></span><br><span class="line">        <span class="keyword">return</span> self.render_template_from_field(attr, content, context, jinja_env)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_template_env</span><span class="params">(self)</span>:</span></span><br><span class="line"> <span class="comment"># 这里会调用到DAG的get_template_env，将DAG级别的macro, filter, template_search_path加载进来</span></span><br><span class="line">    <span class="keyword">return</span> self.dag.get_template_env() \</span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'dag'</span>) \</span><br><span class="line">        <span class="keyword">else</span> jinja2.Environment(cache_size=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_template_from_field</span><span class="params">(self, attr, content, context, jinja_env)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Renders a template from a field. If the field is a string, it will</span></span><br><span class="line"><span class="string">    simply render the string and return the result. If it is a collection or</span></span><br><span class="line"><span class="string">    nested set of collections, it will traverse the structure and render</span></span><br><span class="line"><span class="string">    all elements in it. If the field has another type, it will return it as it is.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    rt = self.render_template</span><br><span class="line">    <span class="keyword">if</span> isinstance(content, six.string_types):</span><br><span class="line">        result = jinja_env.from_string(content).render(**context)</span><br><span class="line">        <span class="comment"># 对于list, tuple, dict类型的变量，会递归地获取字段值，最终还是`基于字符串的渲染`或者`直接返回其他类型`</span></span><br><span class="line">    <span class="keyword">elif</span> isinstance(content, (list, tuple)):</span><br><span class="line">        result = [rt(attr, e, context) <span class="keyword">for</span> e <span class="keyword">in</span> content]</span><br><span class="line">    <span class="keyword">elif</span> isinstance(content, dict):</span><br><span class="line">        result = &#123;</span><br><span class="line">            k: rt(<span class="string">"&#123;&#125;[&#123;&#125;]"</span>.format(attr, k), v, context)</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> list(content.items())&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = content</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>至此，模板渲染就完成了。task的一些属性会被渲染后的content代替。</p><p>另外还有两个方法，是将前面说的<strong>模板文件</strong>的内容加载进来，替换掉原来的<strong>文件名</strong>。同时在最后面<code>prepare_template()</code>方法，可以在这一步对模板文件的内容进行修改。</p><h3 id="在渲染前修改模板内容"><a href="#在渲染前修改模板内容" class="headerlink" title="在渲染前修改模板内容"></a>在渲染前修改模板内容</h3><p><code>resolve_template_files()</code>方法只在bag_dag和web view中有调用，起到将渲染前内容加载出来的作用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resolve_template_files</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># Getting the content of files for template_field / template_ext</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> self.template_fields:</span><br><span class="line">        content = getattr(self, attr)</span><br><span class="line">        <span class="keyword">if</span> content <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(content, six.string_types) <span class="keyword">and</span> \</span><br><span class="line">                any([content.endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> self.template_ext]):</span><br><span class="line">            env = self.get_template_env()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                setattr(self, attr, env.loader.get_source(env, content)[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                self.log.exception(e)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(content, list):</span><br><span class="line">            env = self.dag.get_template_env()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(content)):</span><br><span class="line">                <span class="keyword">if</span> isinstance(content[i], six.string_types) <span class="keyword">and</span> \</span><br><span class="line">                        any([content[i].endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> self.template_ext]):</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        content[i] = env.loader.get_source(env, content[i])[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                        self.log.exception(e)</span><br><span class="line">    self.prepare_template()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare_template</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Hook that is triggered after the templated fields get replaced</span></span><br><span class="line"><span class="string">    by their content. If you need your operator to alter the</span></span><br><span class="line"><span class="string">    content of the file before the template is rendered,</span></span><br><span class="line"><span class="string">    it should override this method to do so.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Jinja渲染在Airflow用于参数跟字段的渲染，这里做一个简单的实现分析。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; 
      
    
    </summary>
    
    
      <category term="Airflow" scheme="http://chace.in/tags/Airflow/"/>
    
      <category term="任务编排调度" scheme="http://chace.in/tags/%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Airflow源码分析(2)-xcom部分</title>
    <link href="http://chace.in/2019/09/01/Airflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)-xcom%E9%83%A8%E5%88%86/"/>
    <id>http://chace.in/2019/09/01/Airflow源码分析(2)-xcom部分/</id>
    <published>2019-09-01T04:07:22.000Z</published>
    <updated>2019-09-01T04:20:47.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xcom简介"><a href="#xcom简介" class="headerlink" title="xcom简介"></a>xcom简介</h2><p>XComs(cross-communication)使得任务之间可以交换信息，允许更细粒度的控制和状态共享。XComs包含key, value, timestamp, 同时也包含创建xcom的任务实例的task_id, dag_id, execution_date等。</p><p>Task可以在运行时通过<code>xcom_push(key, value)</code>发送任意<strong>可序列化成JSON</strong>的对象。（其实支持pickle，但是已经被废弃）另外，task.execute()的返回值会默认发送到xcom，key为return_value。</p><p>Task中也可以通过<code>xcom_pull(task_id(s), key)</code>获取到一个或多个task的xcom值。不局限于下游。</p><p>详细介绍参考：<a href="https://airflow.apache.org/concepts.html#xcoms" target="_blank" rel="noopener">xcom</a></p><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>在任务执行前，会先生成运行时的上下文context，然后调用task.execute(context)。因此在Operator的execute(context)方法中可以通过context[‘ti’]得到当前的TaskInstance，然后调用<code>xcom_push</code>和<code>xcom_pull</code></p><p>这里的context包含很多字段，比如ti, task, dag对象，还有Jinja渲染需要的字段。</p><h3 id="Context的字段定义"><a href="#Context的字段定义" class="headerlink" title="Context的字段定义"></a>Context的字段定义</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            'dag': task.dag,</span><br><span class="line">            'ds': ds,</span><br><span class="line">            'next_ds': next_ds,</span><br><span class="line">            'next_ds_nodash': next_ds_nodash,</span><br><span class="line">            'prev_ds': prev_ds,</span><br><span class="line">            'prev_ds_nodash': prev_ds_nodash,</span><br><span class="line">            'ds_nodash': ds_nodash,</span><br><span class="line">            'ts': ts,</span><br><span class="line">            'ts_nodash': ts_nodash,</span><br><span class="line">            'ts_nodash_with_tz': ts_nodash_with_tz,</span><br><span class="line">            'yesterday_ds': yesterday_ds,</span><br><span class="line">            'yesterday_ds_nodash': yesterday_ds_nodash,</span><br><span class="line">            'tomorrow_ds': tomorrow_ds,</span><br><span class="line">            'tomorrow_ds_nodash': tomorrow_ds_nodash,</span><br><span class="line">            'END_DATE': ds,</span><br><span class="line">            'end_date': ds,</span><br><span class="line">            'dag_run': dag_run,</span><br><span class="line">            'run_id': run_id,</span><br><span class="line">            'execution_date': self.execution_date,</span><br><span class="line">            'prev_execution_date': prev_execution_date,</span><br><span class="line">            'prev_execution_date_success': lazy_object_proxy.Proxy(</span><br><span class="line">                lambda: self.previous_execution_date_success),</span><br><span class="line">            'prev_start_date_success': lazy_object_proxy.Proxy(lambda: self.previous_start_date_success),</span><br><span class="line">            'next_execution_date': next_execution_date,</span><br><span class="line">            'latest_date': ds,</span><br><span class="line">            'macros': macros,</span><br><span class="line">            'params': params,</span><br><span class="line">            'tables': tables,</span><br><span class="line">            'task': task,</span><br><span class="line">            'task_instance': self,</span><br><span class="line">            'ti': self,</span><br><span class="line">            'task_instance_key_str': ti_key_str,</span><br><span class="line">            'conf': configuration,</span><br><span class="line">            'test_mode': self.test_mode,</span><br><span class="line">            'var': &#123;</span><br><span class="line">                'value': VariableAccessor(), # NOTICE</span><br><span class="line">                'json': VariableJsonAccessor()</span><br><span class="line">            &#125;,</span><br><span class="line">            'inlets': task.inlets,</span><br><span class="line">            'outlets': task.outlets,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="xcom-py"><a href="#xcom-py" class="headerlink" title="xcom.py"></a>xcom.py</h3><p>Xcom是Model定义类，在里面实现了set(), get_one(), get_many(), delete()方法，对应数据库的增删查。</p><h3 id="taskinstance-py"><a href="#taskinstance-py" class="headerlink" title="taskinstance.py"></a>taskinstance.py</h3><p>上面说的xcom_pull()和xcom_push在BaseOperator和TaskInstance中均有定义。BaseOperator中只是简单调用了TaskInstance中的方法。</p><p><strong>TaskInstance部分代码：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xcom_push</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        key,</span></span></span><br><span class="line"><span class="function"><span class="params">        value,</span></span></span><br><span class="line"><span class="function"><span class="params">        execution_date=None)</span>:</span></span><br><span class="line">    <span class="comment"># 这里日期设置为未来一个时间，到时才可以被其他task发现</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param execution_date: if provided, the XCom will not be visible until</span></span><br><span class="line"><span class="string">        this date. This can be used, for example, to send a message to a</span></span><br><span class="line"><span class="string">        task on a future date without it being immediately visible.</span></span><br><span class="line"><span class="string">    :type execution_date: datetime</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> execution_date <span class="keyword">and</span> execution_date &lt; self.execution_date:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">'execution_date can not be in the past (current '</span></span><br><span class="line">            <span class="string">'execution_date is &#123;&#125;; received &#123;&#125;)'</span>.format(</span><br><span class="line">                self.execution_date, execution_date))</span><br><span class="line"></span><br><span class="line">    XCom.set(</span><br><span class="line">        key=key,</span><br><span class="line">        value=value,</span><br><span class="line">        task_id=self.task_id,</span><br><span class="line">        dag_id=self.dag_id,</span><br><span class="line">        execution_date=execution_date <span class="keyword">or</span> self.execution_date)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xcom_pull</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        task_ids=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        dag_id=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        key=XCOM_RETURN_KEY,</span></span></span><br><span class="line"><span class="function"><span class="params">        include_prior_dates=False)</span>:</span></span><br><span class="line">    <span class="comment"># 这里是为了得到那些设置为未来可见的xcom对象</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param include_prior_dates: If False, only XComs from the current</span></span><br><span class="line"><span class="string">        execution_date are returned. If True, XComs from previous dates</span></span><br><span class="line"><span class="string">        are returned as well.</span></span><br><span class="line"><span class="string">    :type include_prior_dates: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dag_id <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        dag_id = self.dag_id</span><br><span class="line"></span><br><span class="line">    pull_fn = functools.partial(</span><br><span class="line">        XCom.get_one,</span><br><span class="line">        execution_date=self.execution_date,</span><br><span class="line">        key=key,</span><br><span class="line">        dag_id=dag_id,</span><br><span class="line">        include_prior_dates=include_prior_dates)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_container(task_ids):</span><br><span class="line">        <span class="keyword">return</span> tuple(pull_fn(task_id=t) <span class="keyword">for</span> t <span class="keyword">in</span> task_ids)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> pull_fn(task_id=task_ids)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;xcom简介&quot;&gt;&lt;a href=&quot;#xcom简介&quot; class=&quot;headerlink&quot; title=&quot;xcom简介&quot;&gt;&lt;/a&gt;xcom简介&lt;/h2&gt;&lt;p&gt;XComs(cross-communication)使得任务之间可以交换信息，允许更细粒度的控制和状态共享。
      
    
    </summary>
    
    
      <category term="Airflow" scheme="http://chace.in/tags/Airflow/"/>
    
      <category term="任务编排调度" scheme="http://chace.in/tags/%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Airflow源码分析(1)-executor部分</title>
    <link href="http://chace.in/2019/09/01/Airflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)-executor%E9%83%A8%E5%88%86/"/>
    <id>http://chace.in/2019/09/01/Airflow源码分析(1)-executor部分/</id>
    <published>2019-09-01T04:07:07.000Z</published>
    <updated>2019-09-15T10:04:48.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Executor简介"><a href="#Executor简介" class="headerlink" title="Executor简介"></a>Executor简介</h2><p>Executor是在scheduler和worker之间的一个组件，主要作用是接收scheduler发过来的可执行task，然后根据自身类型决定task的运行环境。</p><p>目前有四种类型：</p><ol><li>SequentialExecutor：Dag在单进程中顺序执行，用于测试跟开发</li><li>LocalExecutor：Dag在本地多进程执行，也是用于测试跟开发</li><li>CeleryExecutor：通过Celery下发任务到分布式集群。</li><li>DaskExecutor：下发任务到Dask集群上执行。Dask不支持队列。</li></ol><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>scheduler经过各种验证以后，终于将task标记为queued状态。</p><p>接下来，scheduler调用executor.queue_command将task_instance交给实际的executor。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.executor.queue_command(simple_task_instance, command, priority=priority, queue=queue)</span><br></pre></td></tr></table></figure><h3 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h3><p>我们打开<code>base_executor.py</code>，这个文件中<code>BaseExecutor</code>类作为具体executor的基类，可以看出executor大概的一个流程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个任务队列和一个事件buffer都是dict类型的，key是task_id</span></span><br><span class="line">        self.queued_tasks = OrderedDict()</span><br><span class="line">        self.running = &#123;&#125;</span><br><span class="line">        self.event_buffer = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个方法就是上面scheduler调用的方法，可以看出，BaseExecutor里维护了queued_tasks的任务队列，在这个方法里将新的task加入到了queued_tasks中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">queue_command</span><span class="params">(self, simple_task_instance, command, priority=<span class="number">1</span>, queue=None)</span>:</span></span><br><span class="line">        key = simple_task_instance.key</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.queued_tasks <span class="keyword">and</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.running:</span><br><span class="line">            self.log.info(<span class="string">"Adding to queue: %s"</span>, command)</span><br><span class="line">            self.queued_tasks[key] = (command, priority, queue, simple_task_instance)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.log.info(<span class="string">"could not queue task %s"</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scheduler会在自身的心跳间隔中重复调用executor.heartbeat()</span></span><br><span class="line"><span class="comment"># heartbeat()方法中，除了会打印executor的状态外，还会调用trigger_task()触发任务和sync()来同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heartbeat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Triggering new jobs</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.parallelism:</span><br><span class="line">            open_slots = len(self.queued_tasks)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            open_slots = self.parallelism - len(self.running)</span><br><span class="line"></span><br><span class="line">        num_running_tasks = len(self.running)</span><br><span class="line">        num_queued_tasks = len(self.queued_tasks)</span><br><span class="line"></span><br><span class="line">        self.log.debug(<span class="string">"%s running task instances"</span>, num_running_tasks)</span><br><span class="line">        self.log.debug(<span class="string">"%s in queue"</span>, num_queued_tasks)</span><br><span class="line">        self.log.debug(<span class="string">"%s open slots"</span>, open_slots)</span><br><span class="line"></span><br><span class="line">        Stats.gauge(<span class="string">'executor.open_slots'</span>, open_slots)</span><br><span class="line">        Stats.gauge(<span class="string">'executor.queued_tasks'</span>, num_queued_tasks)</span><br><span class="line">        Stats.gauge(<span class="string">'executor.running_tasks'</span>, num_running_tasks)</span><br><span class="line"></span><br><span class="line">        self.trigger_tasks(open_slots)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calling child class sync method</span></span><br><span class="line">        self.log.debug(<span class="string">"Calling the %s sync method"</span>, self.__class__)</span><br><span class="line">        self.sync()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在trigger_tasks()方法中，最终会调用execute_async()方法来执行命令</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trigger_tasks</span><span class="params">(self, open_slots)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Trigger tasks</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param open_slots: Number of open slots</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sorted_queue = sorted(</span><br><span class="line">            [(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.queued_tasks.items()],</span><br><span class="line">            key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">            reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min((open_slots, len(self.queued_tasks)))):</span><br><span class="line">            key, (command, _, queue, simple_ti) = sorted_queue.pop(<span class="number">0</span>)</span><br><span class="line">            self.queued_tasks.pop(key)</span><br><span class="line">            self.running[key] = command</span><br><span class="line">            self.execute_async(key=key,</span><br><span class="line">                               command=command,</span><br><span class="line">                               queue=queue,</span><br><span class="line">                               executor_config=simple_ti.executor_config)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sync()和execute_async()都是抽象方法，但是从注释中我们可以看出其作用</span></span><br><span class="line"><span class="comment"># sync()用于收集状态，execute_async()是异步执行命令</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sync</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Sync will get called periodically by the heartbeat method.</span></span><br><span class="line"><span class="string">        Executors should override this to perform gather statuses.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute_async</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                      key,</span></span></span><br><span class="line"><span class="function"><span class="params">                      command,</span></span></span><br><span class="line"><span class="function"><span class="params">                      queue=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                      executor_config=None)</span>:</span>  <span class="comment"># pragma: no cover</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        This method will execute the command asynchronously.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="comment"># change_state(...)只会改变event_buffer中的事件状态，但不会真正改变task的状态。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_state</span><span class="params">(self, key, state)</span>:</span></span><br><span class="line">        self.log.debug(<span class="string">"Changing state: %s"</span>, key)</span><br><span class="line">        self.running.pop(key, <span class="keyword">None</span>)</span><br><span class="line">        self.event_buffer[key] = state</span><br></pre></td></tr></table></figure><p>总结一下executor的功能：</p><ol><li>接收来自scheduler的task，加入到自身维护的queued_tasks中</li><li>在接收到scheduler的心跳后，打印自身的一些状态，在trigger_tasks(…)中将task从queued_tasks转移到running中，并最终调用execute_async(…)异步执行命令并调用sync(…)收集状态</li><li>scheduler可以调用get_event_buffer(…)获取executor的事件。executor改变自身维护的queued_tasks和running队列中task的状态时，都会上报事件到event_buffer中，从而可以被scheduler获取到</li></ol><h3 id="SequentialExecutor"><a href="#SequentialExecutor" class="headerlink" title="SequentialExecutor"></a>SequentialExecutor</h3><p>接下来以SequentialExecutor为例，看下execute_async和sync具体是怎么实现的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute_async</span><span class="params">(self, key, command, queue=None, executor_config=None)</span>:</span></span><br><span class="line">    self.commands_to_run.append((key, command,))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, command <span class="keyword">in</span> self.commands_to_run:</span><br><span class="line">        self.log.info(<span class="string">"Executing command: %s"</span>, command)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 在这里启动了一个子进程来执行task对应的command</span></span><br><span class="line">            subprocess.check_call(command, close_fds=<span class="keyword">True</span>)</span><br><span class="line">            <span class="comment"># 阻塞等待子进程返回，然偶上报success或者failed的状态</span></span><br><span class="line">            self.change_state(key, State.SUCCESS)</span><br><span class="line">        <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">            self.change_state(key, State.FAILED)</span><br><span class="line">            self.log.error(<span class="string">"Failed to execute task %s."</span>, str(e))</span><br><span class="line"></span><br><span class="line">    self.commands_to_run = []</span><br></pre></td></tr></table></figure><p><strong>那么，task的调用到这里就结束了吗？</strong></p><p>一个<code>subprocess.check_call(command, close_fds=True)</code>就完了？task本身的状态是在哪改变的？对于HttpOperator，这个command又是如何执行的？</p><p>眉头一皱，发现事情并没有那么简单。</p><p>这里的command具体是什么呢？通过日志我们可以看到，其实是调用airflow CLI的run命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2019-07-04 15:42:25,046] &#123;base_executor.py:59&#125; INFO - Adding to queue: [&apos;airflow&apos;, &apos;run&apos;, &apos;example_json&apos;, &apos;echo_env&apos;, &apos;2019-07-04T07:42:24.824155+00:00&apos;, &apos;--local&apos;]</span><br></pre></td></tr></table></figure></p><h3 id="cli-run"><a href="#cli-run" class="headerlink" title="cli.run"></a>cli.run</h3><p>继续来看cli.run()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run()中加载了配置文件，获取dag并实例化了TaskInstance，最终调用了_run()方法</span></span><br><span class="line"><span class="meta">@cli_utils.action_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(args, dag=None)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    task = dag.get_task(task_id=args.task_id)</span><br><span class="line">    ti = TaskInstance(task, args.execution_date)</span><br><span class="line">    ti.refresh_from_db()</span><br><span class="line"></span><br><span class="line">    ti.init_run_context(raw=args.raw)</span><br><span class="line"></span><br><span class="line">    hostname = get_hostname()</span><br><span class="line">    log.info(<span class="string">"Running %s on host %s"</span>, ti, hostname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.interactive:</span><br><span class="line">        _run(args, dag, ti)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> redirect_stdout(ti.log, logging.INFO), redirect_stderr(ti.log, logging.WARN):</span><br><span class="line">            _run(args, dag, ti)</span><br><span class="line">    logging.shutdown()</span><br><span class="line"></span><br><span class="line"><span class="comment"># _run()方法中会根据参数来选择合适的，根据之前的参数'--local'，我们会进入到LocalTaskJob中去</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run</span><span class="params">(args, dag, ti)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args.local:</span><br><span class="line">        run_job = jobs.LocalTaskJob(</span><br><span class="line">            task_instance=ti,</span><br><span class="line">            mark_success=args.mark_success,</span><br><span class="line">            pickle_id=args.pickle,</span><br><span class="line">            ignore_all_deps=args.ignore_all_dependencies,</span><br><span class="line">            ignore_depends_on_past=args.ignore_depends_on_past,</span><br><span class="line">            ignore_task_deps=args.ignore_dependencies,</span><br><span class="line">            ignore_ti_state=args.force,</span><br><span class="line">            pool=args.pool)</span><br><span class="line">        run_job.run()</span><br><span class="line">    <span class="keyword">elif</span> args.raw:</span><br><span class="line">        ti._run_raw_task(</span><br><span class="line">            mark_success=args.mark_success,</span><br><span class="line">            job_id=args.job_id,</span><br><span class="line">            pool=args.pool,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pickle_id = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> args.ship_dag:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>接下来是<code>base_job.py</code>，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        Stats.incr(self.__class__.__name__.lower() + <span class="string">'_start'</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># Adding an entry in the DB</span></span><br><span class="line">        <span class="keyword">with</span> create_session() <span class="keyword">as</span> session:</span><br><span class="line">            self.state = State.RUNNING</span><br><span class="line">            session.add(self)</span><br><span class="line">            session.commit()</span><br><span class="line">            id_ = self.id</span><br><span class="line">            make_transient(self)</span><br><span class="line">            self.id = id_</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._execute()</span><br><span class="line">                <span class="comment"># In case of max runs or max duration</span></span><br><span class="line">                self.state = State.SUCCESS</span><br><span class="line">            <span class="keyword">except</span> SystemExit:</span><br><span class="line">                <span class="comment"># In case of ^C or SIGTERM</span></span><br><span class="line">                self.state = State.SUCCESS</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                self.state = State.FAILED</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.end_date = timezone.utcnow()</span><br><span class="line">                session.merge(self)</span><br><span class="line">                session.commit()</span><br><span class="line"></span><br><span class="line">        Stats.incr(self.__class__.__name__.lower() + <span class="string">'_end'</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"This method needs to be overridden"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LocalTaskJob中有具体的实现，可以看到是调用了一个TaskRunner</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.task_runner = get_task_runner(self)</span><br><span class="line">        <span class="comment"># 省略...</span></span><br><span class="line">        self.task_runner.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来跳转到StandardTaskRunner</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardTaskRunner</span><span class="params">(BaseTaskRunner)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Runs the raw Airflow task by invoking through the Bash shell.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.process = self.run_command()</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后是run_command的具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(self, run_with=None, join_args=False)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Run the task command.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param run_with: list of tokens to run the task command with e.g. ``['bash', '-c']``</span></span><br><span class="line"><span class="string">        :type run_with: list</span></span><br><span class="line"><span class="string">        :param join_args: whether to concatenate the list of command tokens e.g. ``['airflow', 'run']`` vs</span></span><br><span class="line"><span class="string">            ``['airflow run']``</span></span><br><span class="line"><span class="string">        :param join_args: bool</span></span><br><span class="line"><span class="string">        :return: the process that was run</span></span><br><span class="line"><span class="string">        :rtype: subprocess.Popen</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        run_with = run_with <span class="keyword">or</span> []</span><br><span class="line">        cmd = [<span class="string">" "</span>.join(self._command)] <span class="keyword">if</span> join_args <span class="keyword">else</span> self._command</span><br><span class="line">        full_cmd = run_with + cmd</span><br><span class="line"></span><br><span class="line">        self.log.info(<span class="string">'Running: %s'</span>, full_cmd)</span><br><span class="line">        proc = subprocess.Popen(</span><br><span class="line">            full_cmd,</span><br><span class="line">            stdout=subprocess.PIPE,</span><br><span class="line">            stderr=subprocess.STDOUT,</span><br><span class="line">            universal_newlines=<span class="keyword">True</span>,</span><br><span class="line">            close_fds=<span class="keyword">True</span>,</span><br><span class="line">            env=os.environ.copy(),</span><br><span class="line">            preexec_fn=os.setsid</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Start daemon thread to read subprocess logging output</span></span><br><span class="line">        log_reader = threading.Thread(</span><br><span class="line">            target=self._read_task_logs,</span><br><span class="line">            args=(proc.stdout,),</span><br><span class="line">        )</span><br><span class="line">        log_reader.daemon = <span class="keyword">True</span></span><br><span class="line">        log_reader.start()</span><br><span class="line">        <span class="keyword">return</span> proc</span><br></pre></td></tr></table></figure></p><p>代码看到这里发现又是subprocess.Popen(cmd)，那么这个时候的cmd内容是什么呢？可以从日志中看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2019-07-04 13:15:38,406] &#123;base_task_runner.py:133&#125; INFO - Running: [&apos;airflow&apos;, &apos;run&apos;, &apos;example_json&apos;, &apos;echo_env&apos;, &apos;2019-07-04T05:15:36.239140+00:00&apos;, &apos;--job_id&apos;, &apos;120&apos;, &apos;--raw&apos;, &apos;--cfg_path&apos;, &apos;/tmp/tmpg2123epz&apos;]</span><br></pre></td></tr></table></figure></p><p>会发现又是airflow run，但是这个时候的cmd参数更多了，而且有一个<code>--raw</code>的参数。</p><h3 id="TaskInstance-run-raw-task"><a href="#TaskInstance-run-raw-task" class="headerlink" title="TaskInstance._run_raw_task"></a>TaskInstance._run_raw_task</h3><p>回到<code>_run(...)</code>，这个时候再执行命令会去另一个分支。于是会执行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cli.py</span></span><br><span class="line">    <span class="keyword">elif</span> args.raw:</span><br><span class="line">        ti._run_raw_task(</span><br><span class="line">            mark_success=args.mark_success,</span><br><span class="line">            job_id=args.job_id,</span><br><span class="line">            pool=args.pool,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># taskinstance.py</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_raw_task</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            self,</span></span></span><br><span class="line"><span class="function"><span class="params">            mark_success=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            test_mode=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            job_id=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            pool=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            session=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Immediately runs the task (without checking or changing db state</span></span><br><span class="line"><span class="string">        before execution) and then sets the appropriate final state after</span></span><br><span class="line"><span class="string">        completion and runs any post-execute callbacks. Meant to be called</span></span><br><span class="line"><span class="string">        only after another function changes the state to running.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里的task_copy类型就是Operator，也就是我们再定义DAG的时候选择的具体操作，通过调用Operator.execute(...)真正执行了我们想要运行的操作</span></span><br><span class="line">                task_copy.pre_execute(context=context)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">                    result = task_copy.execute(context=context)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">                task_copy.post_execute(context=context, result=result)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">            self.refresh_from_db(lock_for_update=<span class="keyword">True</span>)</span><br><span class="line">            self.state = State.SUCCESS</span><br><span class="line">        <span class="keyword">except</span> AirflowSkipException:</span><br><span class="line">            self.refresh_from_db(lock_for_update=<span class="keyword">True</span>)</span><br><span class="line">            self.state = State.SKIPPED</span><br><span class="line">        <span class="keyword">except</span> AirflowRescheduleException <span class="keyword">as</span> reschedule_exception:</span><br><span class="line">            self.refresh_from_db()</span><br><span class="line">            <span class="comment"># 在_handle_reschedule(...)中会将需要reschedule的任务加入到task_reschedule表中，状态为up_for_reschedule，等待被再次调度</span></span><br><span class="line">            self._handle_reschedule(actual_start_date, reschedule_exception, test_mode, context)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> AirflowException <span class="keyword">as</span> e:</span><br><span class="line">            self.refresh_from_db()</span><br><span class="line">            <span class="comment"># for case when task is marked as success/failed externally</span></span><br><span class="line">            <span class="comment"># current behavior doesn't hit the success callback</span></span><br><span class="line">            <span class="keyword">if</span> self.state <span class="keyword">in</span> &#123;State.SUCCESS, State.FAILED&#125;:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 在handle_failure(...)中，会根据重试次数等信息将task状态设为up_for_retry或者failed</span></span><br><span class="line">                self.handle_failure(e, test_mode, context)</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">except</span> (Exception, KeyboardInterrupt) <span class="keyword">as</span> e:</span><br><span class="line">            self.handle_failure(e, test_mode, context)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Success callback</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> task.on_success_callback:</span><br><span class="line">                task.on_success_callback(context)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e3:</span><br><span class="line">            self.log.error(<span class="string">"Failed when executing success callback"</span>)</span><br><span class="line">            self.log.exception(e3)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recording SUCCESS</span></span><br><span class="line">        self.end_date = timezone.utcnow()</span><br><span class="line">        self.set_duration()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> test_mode:</span><br><span class="line">            session.add(Log(self.state, self))</span><br><span class="line">            session.merge(self)</span><br><span class="line">        session.commit()</span><br></pre></td></tr></table></figure></p><p>到这里，从scheduler将某个task分发给executor开始，一直到task被真正地执行的流程就完成了。</p><p>这里只分析了SequentialExecutor，对于CeleryExecutor，只是通过CeleryExecutor将cmd分发到远程worker上面执行了，接下来的流程是一样。</p><p>最后总结一下task是如何在worker上运行起来的：</p><ol><li>在worker上执行<code>airflow run &lt;dag_id&gt; &lt;task_id&gt; &lt;execution_date&gt; --local</code>命令</li><li>进入到_run函数，选择local分支执行</li><li>在local分支中绑定一个<code>LocalTaskJob</code>，并选择一个<code>BaseTaskRunner</code>作为task的执行环境。目前实现有<code>StandardTaskRunner</code>和<code>CgroupTaskRunner</code>两种</li><li>在TaskRunner中调用run_command方法在子进程中继续执行命令，这时候命令为<code>airflow run &lt;dag_id&gt; &lt;task_id&gt; &lt;execution_date&gt; --raw</code></li><li>再次进入_run函数，选择raw分支执行</li><li>在raw分支中调用_run_raw_task()，最后真正执行task.execute()方法</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Executor简介&quot;&gt;&lt;a href=&quot;#Executor简介&quot; class=&quot;headerlink&quot; title=&quot;Executor简介&quot;&gt;&lt;/a&gt;Executor简介&lt;/h2&gt;&lt;p&gt;Executor是在scheduler和worker之间的一个组件，主要作用
      
    
    </summary>
    
    
      <category term="Airflow" scheme="http://chace.in/tags/Airflow/"/>
    
      <category term="任务编排调度" scheme="http://chace.in/tags/%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Airflow源码分析(0)-介绍</title>
    <link href="http://chace.in/2019/09/01/Airflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(0)-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://chace.in/2019/09/01/Airflow源码分析(0)-介绍/</id>
    <published>2019-09-01T04:06:46.000Z</published>
    <updated>2019-09-01T04:23:28.388Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://airflow.apache.org/index.html" target="_blank" rel="noopener">Airflow</a>是一套分布式的任务编排和调度系统，核心概念是DAG，通过DAG编排任务，并通过scheduler调度任务到不同的worker上执行。</p><p>Airflow基于Python开发，所以在开发Airflow前要有Python基础。</p><p>开发环境的搭建可以参考：<a href="https://github.com/apache/airflow/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">Contributing</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://airflow.apache.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Airflow&lt;/a&gt;是一套分布式的任务编排和调度系统，核心概念是DAG，通过DAG编排任务，并通过schedule
      
    
    </summary>
    
    
      <category term="Airflow" scheme="http://chace.in/tags/Airflow/"/>
    
      <category term="任务编排调度" scheme="http://chace.in/tags/%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>高可用配置中心etcd</title>
    <link href="http://chace.in/2019/09/01/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83etcd/"/>
    <id>http://chace.in/2019/09/01/高可用配置中心etcd/</id>
    <published>2019-09-01T04:06:07.000Z</published>
    <updated>2019-09-02T02:32:54.281Z</updated>
    
    <content type="html"><![CDATA[<p>占坑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;占坑&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="分布式系统" scheme="http://chace.in/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Docker" scheme="http://chace.in/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker中的namespace和cgroup</title>
    <link href="http://chace.in/2019/09/01/Docker%E4%B8%AD%E7%9A%84namespace%E5%92%8Ccgroup/"/>
    <id>http://chace.in/2019/09/01/Docker中的namespace和cgroup/</id>
    <published>2019-09-01T02:24:07.000Z</published>
    <updated>2019-09-01T03:59:10.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-namespace资源隔离"><a href="#1-namespace资源隔离" class="headerlink" title="1. namespace资源隔离"></a>1. namespace资源隔离</h2><p>Linux提供6种namespace隔离。</p><table><thead><tr><th>namespace</th><th>flag</th><th>备注</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名和域名</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>进程间通信</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>进程PID</td></tr><tr><td>MOUNT</td><td>CLONE_NEWNS</td><td>文件系统挂载点(mount)</td></tr><tr><td>NET</td><td>CLONE_NEWNET</td><td>网络</td></tr><tr><td>USER</td><td>CLONE_NEWUSER</td><td>用户权限</td></tr></tbody></table><p>tips: 文件系统挂载点之所以是NS，是因为这是第一个namespace，当时没有想到会有其他namespace，所以直接用的NS。</p><h3 id="namespace提供的系统调用"><a href="#namespace提供的系统调用" class="headerlink" title="namespace提供的系统调用"></a>namespace提供的系统调用</h3><h4 id="clone-在新namespace中创建进程"><a href="#clone-在新namespace中创建进程" class="headerlink" title="clone: 在新namespace中创建进程"></a>clone: 在新namespace中创建进程</h4><p>传入哪些flag中就可以达到隔离哪些资源的目的，以<code>|</code>分隔，比如<code>CLONE_NEWUTS|CLONE_NEWIPC</code>就隔离了主机名和进程间通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure><h4 id="setns-加入一个已经存在的namespace"><a href="#setns-加入一个已经存在的namespace" class="headerlink" title="setns: 加入一个已经存在的namespace"></a>setns: 加入一个已经存在的namespace</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setns(int fd, int nstype);</span><br></pre></td></tr></table></figure><h4 id="unshare-将当前进程加入到新的namespace中"><a href="#unshare-将当前进程加入到新的namespace中" class="headerlink" title="unshare: 将当前进程加入到新的namespace中"></a>unshare: 将当前进程加入到新的namespace中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int unshare(int flags);</span><br></pre></td></tr></table></figure><h4 id="一些-proc下的文件"><a href="#一些-proc下的文件" class="headerlink" title="一些/proc下的文件"></a>一些/proc下的文件</h4><p>可以修改/proc下的部分文件达到namespace隔离的效果，比如修改user namespace中的/proc/$$/uid_map和/proc/$$/proc/gid_map可以完成用户绑定的操作。</p><h3 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h3><p>隔离主机名和域名。在clone中传入CLONE_NEWUTS，然后在子进程中修改hostname不会影响到父进程。</p><h3 id="IPC-namespace"><a href="#IPC-namespace" class="headerlink" title="IPC namespace"></a>IPC namespace</h3><p>隔离进程间通信的文件，比如信号量、消息队列、PIPE等。</p><h3 id="PID-namespace"><a href="#PID-namespace" class="headerlink" title="PID namespace"></a>PID namespace</h3><p>隔离进程。在新的namespace下不会看到其他namespace下的进程。</p><p>在新的namespace下启动的第一个进程相当于Linux下的init进程，同时要承担init进程收养孤儿，传递SIGNAL的责任，比较重要。</p><p>这时候直接用<code>ps</code>看到的还是原来namespace的进程，需要重新挂载<code>proc</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount -t &lt;文件系统类型&gt; &lt;设备名&gt; &lt;挂载点&gt;</span><br><span class="line">mount -t proc proc /proc</span><br></pre></td></tr></table></figure><p>但是这时候父子进程的文件系统并没有隔离，所以挂载到子进程后父进程也会受影响，所以在退出子进程后。需要在父进程中重新挂载<code>proc</code></p><h3 id="Mount-namespace"><a href="#Mount-namespace" class="headerlink" title="Mount namespace"></a>Mount namespace</h3><p>隔离文件系统挂载点。子进程会复制父进程的所有挂载点，但是之后彼此是独立的。</p><p>需要注意的是Linux有<strong>挂载传播</strong>的特性，也就是说挂载的时候可以将文件系统指定为<strong>shared/slave/private/unbindable</strong>等属性，从而可以控制不同namespace下文件系统的共享状态。</p><p>因此如果挂载点是shared的状态，上述的namespace隔离不会生效。需要通过<code>mount --make-private -t &lt;文件系统类型&gt; &lt;设备名&gt; &lt;挂载点&gt;</code>修改为private。</p><h3 id="Net-namespace"><a href="#Net-namespace" class="headerlink" title="Net namespace"></a>Net namespace</h3><p>隔离网络设备，在子进程中将看不到父进程中的网络设备。</p><p>为了不同namespace可以通过网络互相访问，通常的做法是创建一个veth pair，一端在容器内部，另一端接在网桥上(docker中是docker 0网桥)。通过合理分配IP，不同namespace下的veth通过网桥互相访问。</p><p>还有个细节是，在容器内的veth创建之前，外部是如何与namespace通信的？答案是PIPE。docker daemon先在宿主机上创建一个veth，然后通过PIPE通知容器内部创建veth，容器内部在veth创建之前会循环等待PIPE，完成两个veth的绑定后，移除PIPE。</p><p>到这里，可以实验一下各种namespace的隔离效果。</p><p>net.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"在子进程中!\n"</span>);</span><br><span class="line">    sethostname(<span class="string">"NewNS"</span>, <span class="number">12</span>);</span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"程序开始: \n"</span>);</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"已退出\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="User-namespace"><a href="#User-namespace" class="headerlink" title="User namespace"></a>User namespace</h3><p>隔离用户和权限。不同namespace下的用户相互看不到，权限也不通。</p><p>需要注意的是，新的namespace下的用户需要绑定外部namespace下的用户才能正常显示，通过修改/proc/$$/uid_map和/proc/$$/proc/gid_map完成绑定。</p><h2 id="2-cgroups资源限制"><a href="#2-cgroups资源限制" class="headerlink" title="2. cgroups资源限制"></a>2. cgroups资源限制</h2><p>官方定义：</p><pre><code>cgroups是Linux内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合（或分隔）到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。</code></pre><p>作用：资源限制，资源统计，任务控制，优先级分配</p><p>基本概念：</p><ul><li>task: 进程或者线程</li><li>cgroup: 按某种资源控制标准划分成的任务组</li><li>subsystem: 控制某一种资源，比如CPU子系统，内存子系统</li><li>hierachy(层级): 层级由一系列cgroup排列而成，每个层级通过绑定子系统进行资源控制</li></ul><h3 id="cgroups的实现"><a href="#cgroups的实现" class="headerlink" title="cgroups的实现"></a>cgroups的实现</h3><p>Linux中cgroup的实现形式表现为一个文件系统，所以可以通过操作文件的方式调用cgroup。</p><p>docker实现：</p><pre><code>在docker的实现中，docker daemon会在单独挂载了每一个子系统的cgroup目录(比如/sys/fs/cgroup/cpu)下创建一个名为docker的控制组，然后在docker控制组里面，再为每个容器创建一个以容器ID为名称的容器控制组，这个容器里所有进程都会写到该控制组tasks中，并且会在控制文件(比如cpu.cfs_quota_us)中写入预设的限制参数值。</code></pre><p>cgroups的实现本质上是个任务挂上钩子，当任务运行的过程中涉及某种资源时，就会触发钩子上所附带的子系统进程检测，根据资源类别的不同，使用对应的技术进行资源限制和优先级分配。</p><hr><p>参考资料</p><ol><li><a href="https://linux.cn/article-5057-5.html" target="_blank" rel="noopener">Docker背后的内核知识：命名空间资源隔离</a></li><li><a href="https://book.douban.com/subject/26894736/" target="_blank" rel="noopener">Docker容器与容器云</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-namespace资源隔离&quot;&gt;&lt;a href=&quot;#1-namespace资源隔离&quot; class=&quot;headerlink&quot; title=&quot;1. namespace资源隔离&quot;&gt;&lt;/a&gt;1. namespace资源隔离&lt;/h2&gt;&lt;p&gt;Linux提供6种namespa
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://chace.in/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>CS6.824(3)-Raft</title>
    <link href="http://chace.in/2019/08/31/CS6.824(3)-Raft/"/>
    <id>http://chace.in/2019/08/31/CS6.824(3)-Raft/</id>
    <published>2019-08-31T12:41:50.000Z</published>
    <updated>2019-09-01T04:22:17.865Z</updated>
    
    <content type="html"><![CDATA[<p>Raft作为两大分布式一致性协议之一（另一个就是大名鼎鼎的Paxos），本身是为了解决Paxos学习成本过高，工程实现过于困难的问题。在论文中也是遵循这个原则，因此阅读下来还是比较轻松的，而且也有丰富的图表可以帮助思考。</p><p>不过在实现上还是会有很多坑，再次感受到了分布式编程的困难之处，尤其是调试，也再次印证了printf是最好的调试工具~（事实上只能看日志来调试）</p><p>下面简单过一下Raft比较有意思的点。</p><h2 id="选举安全"><a href="#选举安全" class="headerlink" title="选举安全"></a>选举安全</h2><p>在同一term最多选举出一个leader。</p><p>首先所有节点都是follower，term=0，term相当于一个阶段。</p><p>follower等待一个随机的超时时间，超时以后该节点成为candidate，term+1，向其余节点发起投票请求。</p><p>其余节点发现投票请求中的term&gt;=currentTerm，并且在currentTerm没有投过票，并且投票请求的日志记录至少与自己的日志记录一样新，就授权这次投票请求。</p><p>当某个candidate获得majority的授权以后，成为leader，并且向其余follower发送心跳。</p><p>如果某个term没有leader产生，那么在选举超时以后，会再发起选举。</p><h2 id="Leader的日志完整性"><a href="#Leader的日志完整性" class="headerlink" title="Leader的日志完整性"></a>Leader的日志完整性</h2><p>只要在某个term一条日志被commit，那么这条日志将会出现在所有更高term的leader中。</p><p>假设存在一个比term T大且最小的term U，term U的leader不包含term T已经commit的日志。</p><p>因为要成为leader，必须获得majority follower的投票；同样地，一个日志要被commit，也必须被majority follower接收。所以至少存在一个follower，既接收了term T的leader的日志，也投票给了term U的leader。</p><p>如果term U的leader不包含之前commit的日志，那么这个follower是不会投票给他的。因此会矛盾。</p><p>论文里面是用反证法证明的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Raft作为两大分布式一致性协议之一（另一个就是大名鼎鼎的Paxos），本身是为了解决Paxos学习成本过高，工程实现过于困难的问题。在论文中也是遵循这个原则，因此阅读下来还是比较轻松的，而且也有丰富的图表可以帮助思考。&lt;/p&gt;
&lt;p&gt;不过在实现上还是会有很多坑，再次感受到
      
    
    </summary>
    
    
      <category term="分布式系统" scheme="http://chace.in/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CS6.824(2)-GFS</title>
    <link href="http://chace.in/2019/08/31/CS6.824(2)-GFS/"/>
    <id>http://chace.in/2019/08/31/CS6.824(2)-GFS/</id>
    <published>2019-08-31T12:37:48.000Z</published>
    <updated>2019-08-31T12:53:16.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GFS的架构"><a href="#GFS的架构" class="headerlink" title="GFS的架构"></a>GFS的架构</h2><p>GFS模型的master，chunkserver。master保存文件的元数据，比如file目录结构，文件大小，文件包含的chunk以及chunk在什么位置。chunkserver上保存的是具体的文件数据。</p><h2 id="GFS读文件过程"><a href="#GFS读文件过程" class="headerlink" title="GFS读文件过程"></a>GFS读文件过程</h2><p>client访问master，获取到文件的chunk所在的chunkserver，然后client直接去这些chunkserver上请求数据。控制流跟数据流是解耦的。</p><h2 id="GFS写文件过程"><a href="#GFS写文件过程" class="headerlink" title="GFS写文件过程"></a>GFS写文件过程</h2><ol><li>client访问master，获取到应该写入chunk所在的chunkserver。（超出一个chunk的话，会把写请求分成多次）</li><li>Master会给chunk授权一个租约，增加chunk的版本号，然后让chunkserver也同样地增加版本号。并且会在chunkserver中给本次写请求指定一个primary节点，由他来负责协调本次的写入。然后回应client，后面client跟master不需要再通信了，这样可以减少master的负载。</li><li>client把数据push到master告诉它的chunkserver上。</li><li>一旦数据push完毕，client发送写请求给primary。primary决定本次写入的顺序并且应用到chunk上。</li><li>primary主节点完成修改后，将这个顺序传递给从节点secondaries，因此他们也能应用同样的修改顺序。</li><li>从节点完成修改后，回应主节点。</li><li>主节点之后回应client成功或者失败状态：<ul><li>主节点和从节点都成功，则本次写入成功；</li><li>如果有失败，那么client会重试写入</li></ul></li></ol><h2 id="GFS的一致性模型"><a href="#GFS的一致性模型" class="headerlink" title="GFS的一致性模型"></a>GFS的一致性模型</h2><p>主要针对并发写文件的过程。在GFS里，有两种写文件的方式，一种是随机写，一种是append追加数据。这里面的一致性有两个维度，确定与一致。一致是指多个副本的内容相同，确定就是与串行写入时的内容相同。</p><p>append会有一个填充的操作，就是发现原来的chunk+新的数据可能超出一个chunk的大小，就先把chunk填满，再通知client在下一块chunk进行append。这里一次append的数据限制为chunk的1/4大小，这样就不会填充太多的无效数据。这样做的原因是前面GFS的写入操作是针对一个chunk的，就是为了避免一次写两块chunk，这样一致性会被破坏掉。</p><p>随机写是一致的但是不确定的，append填充的部分是不一致的，但是其他正常的数据是确定的。</p><p>并发写同一个区域，可能会出现覆盖的情况，导致undefined，但是几个副本的内容是一致的。<br>Record append填充的部分是不一致的（因此也就不一致），但是其他正常的数据是确定的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GFS的架构&quot;&gt;&lt;a href=&quot;#GFS的架构&quot; class=&quot;headerlink&quot; title=&quot;GFS的架构&quot;&gt;&lt;/a&gt;GFS的架构&lt;/h2&gt;&lt;p&gt;GFS模型的master，chunkserver。master保存文件的元数据，比如file目录结构，文件大
      
    
    </summary>
    
    
      <category term="分布式系统" scheme="http://chace.in/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>快速熟悉开源项目</title>
    <link href="http://chace.in/2019/08/30/%E5%BF%AB%E9%80%9F%E7%86%9F%E6%82%89%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE(%E8%BD%AC%E8%BD%BD)/"/>
    <id>http://chace.in/2019/08/30/快速熟悉开源项目(转载)/</id>
    <published>2019-08-30T07:30:58.000Z</published>
    <updated>2019-08-30T07:37:34.595Z</updated>
    
    <content type="html"><![CDATA[<p>《Docker-容器与容器云》中的一篇文章，觉得挺不错，所以从网上转载了一份过来。原文：<a href="https://my.oschina.net/baijuminglu/blog/834911" target="_blank" rel="noopener">快速熟悉开源项目</a></p><h2 id="查阅文档"><a href="#查阅文档" class="headerlink" title="查阅文档"></a>查阅文档</h2><p>查阅文档包括查阅文档与博客，最好是带着问题去阅读。</p><h3 id="1-查阅文档与博客"><a href="#1-查阅文档与博客" class="headerlink" title="1.查阅文档与博客"></a>1.查阅文档与博客</h3><p>一个好的开源项目未必会火，但是一个火的开源项目一定有其可取之处，而从众心理又会让更多人去研究它。所以，要熟悉你想研究的开源项目，第一步就是在搜索引擎中查找该项目的博客和资料。通过快速阅读介绍开源项目架构，使用方法等这类文章，你就能大体了解该项目的意义，功能和基本使用方法。</p><p>通过搜索到的资料，如果你觉得该项目就是你想要的，那么便可以很耐心的阅读项目提供的官方文档，从中学习一些具体的下载，安装和使用方法，以便了解项目全貌。</p><h3 id="2-带着问题去阅读"><a href="#2-带着问题去阅读" class="headerlink" title="2.带着问题去阅读"></a>2.带着问题去阅读</h3><p>阅读文档过程中不能盲目，需要带着如下问题去阅读。</p><ul><li>这个项目解决了什麽问题？</li><li>这个项目涉及了哪些成熟的技术？</li><li>这个项目是否符合我的要求（用户规模，使用场景，性能，安全性等）？</li><li>当阅读完文档后，能否尝试画出大致的架构图？</li></ul><h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h2><p>实践是最好的老师，在阅读文档过程中，按照文档的操作指南亲手实践，不但有助于加深理解，同时还会注意到很多细节，可以更清楚的感受到项目是否符合自己的需求。</p><h3 id="1-搭建项目"><a href="#1-搭建项目" class="headerlink" title="1.搭建项目"></a>1.搭建项目</h3><p>实践过程一般都遵循项目的README文件，进行部署安装和尝试。如果有现成使用项目的事例代码，那么也可以按照示例代码进行尝试。此时若是运行顺利，则可以尝试着根据自己的理解对事例代码进行修改。若是出现问题也无需慌张，只需要将问题的异常信息当作关键词在搜索引擎中查找即可。如果实在找不到解决方案，那么就可以提交到开源项目的邮件列表中，开源社区的人们一般都比较热心，相信很快就可以解决问题。</p><p>基本尝试过后，我们可以使用项目的一些高级功能，如一些高级配置项，较为复杂的API等。相信一个运作良好的开源项目，为了方便社区的贡献者们可以快速加入，必然会提供一份较为详尽的指南，你只需挑选你感兴趣的部分阅读即可。</p><p>基本尝试过后，我们可以使用项目的一些高级功能，如一些高级配置项，较为复杂的API等。相信一个运作良好的开源项目，为了方便社区的贡献者们可以快速加入，必然会提供一份较为详尽的指南，你只需挑选你感兴趣的部分阅读即可。</p><p>下面推荐几个解决疑惑的好网站</p><ul><li>Google搜索引擎: google.com</li><li>Stackoverflow: stackoverflow.com</li><li>项目相关的Google讨论组: groups.google.com</li><li>对GitHub的项目提Issues: github.com</li></ul><h3 id="2-深层次改动"><a href="#2-深层次改动" class="headerlink" title="2.深层次改动"></a>2.深层次改动</h3><p>有趣的是，很多开源项目一般都会为了方便用户使用，提供release的版本。如果基本的部署和使用已经成功的话，强烈建议你从源码构建和部署该项目。这样你就能从开发，调试到发布整个一体化的全部过程，由此全方位的感受项目的优缺点。</p><p>基本尝试过后，我们可以使用项目的一些高级功能，如一些高级配置项，较为复杂的API等。相信一个运作良好的开源项目，为了方便社区的贡献者们可以快速加入，必然会提供一份较为详尽的指南，你只需挑选你感兴趣的部分阅读即可。</p><h2 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h2><p>经过以上两步之后，你必然对项目的大致情况了然于胸，想更深入的了解自然非阅读源码莫属了。</p><p>一般阅读源码有两种习惯方式，一是根据命令行的代码调用过程阅读；二是根据架构分模块阅读。</p><h3 id="1-跟着运行过程阅读"><a href="#1-跟着运行过程阅读" class="headerlink" title="1.跟着运行过程阅读"></a>1.跟着运行过程阅读</h3><p>刚上手的过程可以使用的一种方式。通过实践过程中对对某个命令或参数的理解，从主干开始，一步一步理清这个命令在运行过程中代码调用的路径。通过debug工具观察变量和函数，修改源码打印日志，可以更好的帮你理解源码。</p><p>当理清这个过程后可以将这个过程用流程图的形式记录下来，从而加深印象，方便下次阅读的时候快速会议和对比。</p><h3 id="2-分模块阅读"><a href="#2-分模块阅读" class="headerlink" title="2.分模块阅读"></a>2.分模块阅读</h3><p>在理清了程序运行的基本流程后，可以根据架构上各个模块的作用，挑选你有兴趣的部分阅读，如网络，存储，通信，用户接口，界面等，选择一个模块深入到实现细节中。</p><p>此时也可以带着如下几个问题帮助自己理解。</p><ul><li>调用了什麽底层库？</li><li>采用了什麽设计模式？</li><li>这麽写有什麽好处？</li></ul><p>如果在阅读源码的过程中出现瓶颈，你一时无法理解代码的用意，不妨去阅读一下相关的单元测试。一个好的单元测试通常都描述了要测试代码的主要功能和数据边界，通过运行和理解单元测试，可以有效的帮助理解源码。</p><p>相信经过以上三步，你必然已经对这个开源项目非常熟悉了。此时如果你感兴趣，也可以加入其中为开源社区做出一定贡献。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《Docker-容器与容器云》中的一篇文章，觉得挺不错，所以从网上转载了一份过来。原文：&lt;a href=&quot;https://my.oschina.net/baijuminglu/blog/834911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;快速熟悉开
      
    
    </summary>
    
    
      <category term="经验之谈" scheme="http://chace.in/tags/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Go tour(3)-Concurrency</title>
    <link href="http://chace.in/2019/06/11/Go-tour-3-Concurrency/"/>
    <id>http://chace.in/2019/06/11/Go-tour-3-Concurrency/</id>
    <published>2019-06-11T03:05:58.000Z</published>
    <updated>2019-06-11T03:08:24.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul><li>gorotine 协程</li><li>channel 信道</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> TYPE, BUFFER_SIZE) <span class="comment">// 创建一个信道</span></span><br><span class="line"><span class="keyword">go</span> FUNC(ch) <span class="comment">// 用协程执行FUNC，并传递一个信道</span></span><br><span class="line"><span class="keyword">for</span> y := <span class="keyword">range</span> ch <span class="comment">// 用range循环等待</span></span><br></pre></td></tr></table></figure><h3 id="练习：比较二叉树是否存储相同的值"><a href="#练习：比较二叉树是否存储相同的值" class="headerlink" title="练习：比较二叉树是否存储相同的值"></a>练习：比较二叉树是否存储相同的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"golang.org/x/tour/tree"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Walk walks the tree t sending all values</span></span><br><span class="line"><span class="comment">// from the tree to the channel ch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(t *tree.Tree, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ch &lt;- t.Value</span><br><span class="line">Walk(t.Left, ch)</span><br><span class="line">Walk(t.Right, ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same determines whether the trees</span></span><br><span class="line"><span class="comment">// t1 and t2 contain the same values.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Same</span><span class="params">(t1, t2 *tree.Tree)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> Walk(t1, ch1)</span><br><span class="line"><span class="keyword">go</span> Walk(t2, ch2)</span><br><span class="line">values1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">values2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 阻塞在select</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v1 := &lt;- ch1:</span><br><span class="line">values1 = <span class="built_in">append</span>(values1, v1)</span><br><span class="line"><span class="keyword">case</span> v2 := &lt;- ch2:</span><br><span class="line">values2 = <span class="built_in">append</span>(values2, v2)</span><br><span class="line"><span class="comment">//在其余case没有准备好的时候，default会执行。不会阻塞</span></span><br><span class="line"><span class="comment">//default:</span></span><br><span class="line"><span class="comment">//fmt.Println("default")</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"values1: %v\n"</span>, values1)</span><br><span class="line">fmt.Printf(<span class="string">"values2: %v\n"</span>, values2)</span><br><span class="line"></span><br><span class="line">same := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> v1:=<span class="keyword">range</span> values1 &#123;</span><br><span class="line">same = <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> v2:=<span class="keyword">range</span> values2 &#123;</span><br><span class="line"><span class="keyword">if</span> v1 == v2 &#123;</span><br><span class="line">same = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !same &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> same</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> Walk(tree.New(<span class="number">1</span>), ch)</span><br><span class="line"></span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">tmp[i] = v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"tmp: %v\n"</span>, tmp)</span><br><span class="line">fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">isSame := Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">2</span>))</span><br><span class="line">fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line">fmt.Println(isSame)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>基于channel的同步<br>By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span> <span class="comment">// 会出现死锁</span></span><br></pre></td></tr></table></figure></li><li><p>基于sync.Mutex的同步</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mux sync.Mutex</span><br><span class="line">mux.Lock()</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">mux.Unlock()</span><br></pre></td></tr></table></figure></li><li><p>基于sync.WaitGroup同步<br>主线程等待所有协程返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 在执行协程之前调用Add</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure></li></ol><p>在执行协程之前调用Add。文档说明：Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. </p><h2 id="练习：并发爬虫"><a href="#练习：并发爬虫" class="headerlink" title="练习：并发爬虫"></a>练习：并发爬虫</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Fetch returns the body of URL and</span></span><br><span class="line"><span class="comment">// a slice of URLs found on that page.</span></span><br><span class="line">Fetch(url <span class="keyword">string</span>) (body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crawl uses fetcher to recursively crawl</span></span><br><span class="line"><span class="comment">// pages starting with url, to a maximum of depth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line"><span class="comment">// 用waitgroup实现主线程等待</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Fetch URLs in parallel.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Don't fetch the same URL twice.</span></span><br><span class="line"><span class="comment">// 判断是否已访问</span></span><br><span class="line"><span class="keyword">if</span> safemap.IsVisited(url) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This implementation doesn't do either:</span></span><br><span class="line"><span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">body, urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记为已访问</span></span><br><span class="line">safemap.Visit(url)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"found: %s %q\n"</span>, url, body)</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Crawl(u, depth<span class="number">-1</span>, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Crawl(<span class="string">"https://golang.org/"</span>, <span class="number">4</span>, fetcher)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问过的url</span></span><br><span class="line"><span class="keyword">type</span> SafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">visited <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现安全操作map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m SafeMap)</span> <span class="title">IsVisited</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">m.mux.Lock()</span><br><span class="line">_, ok := m.visited[url]</span><br><span class="line"><span class="keyword">defer</span> m.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现安全操作map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m SafeMap)</span> <span class="title">Visit</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">m.mux.Lock()</span><br><span class="line">m.visited[url] = <span class="literal">true</span></span><br><span class="line">m.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> safemap = SafeMap&#123;visited: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher is Fetcher that returns canned results.</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span> <span class="title">Fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher is a populated fakeFetcher.</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"The Go Programming Language"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/cmd/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Packages"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/cmd/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/fmt/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/os/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"https://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package fmt"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"https://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package os"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;gorotine 协程&lt;/li&gt;
&lt;li&gt;channel 信道&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chace.in/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go tour(2)-Methods and Interfaces</title>
    <link href="http://chace.in/2019/06/11/Go-tour-2-Methods-and-Interfaces/"/>
    <id>http://chace.in/2019/06/11/Go-tour-2-Methods-and-Interfaces/</id>
    <published>2019-06-11T03:05:45.000Z</published>
    <updated>2019-06-11T03:08:26.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go没有类，方法跟函数的区别就是多了一个接收器Receiver</p><p>指针接收器，接收到的变量是指针形式的，意味着可以修改原变量。pointer receivers比value receivers更加常见。</p><p>函数的参数为指针必须显式传入一个指针，但如果是方法，Go解释器会隐式地将对象的指针传入，不需要显式取地址。同样的情况也发生在参数为值value的情况下，方法依然会进行隐式转换。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">ScaleFunc(v, <span class="number">5</span>) <span class="comment">// error</span></span><br><span class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// ok</span></span><br><span class="line">v.Scale(<span class="number">5</span>) <span class="comment">// OK</span></span><br><span class="line">(&amp;v).Scale(<span class="number">5</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p><p>指针接收器优点: 1.可以改变原变量；2.避免了传值拷贝</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口也是一种type。没有类，感觉像是在type上去实现方法。可以看成(value, type)的元组。<br>接口内的值就算是nil，也可以调用它的方法，不会报空指针异常。但是如果是nil接口，就会报错。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">t.M()</span><br><span class="line"><span class="comment">// 会报错</span></span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 这样就实现了接口I</span></span><br><span class="line"><span class="keyword">var</span> i I = F(<span class="number">1.2</span>) <span class="comment">// 可以给接口赋值</span></span><br><span class="line">i.M() <span class="comment">// 调用接口实现中的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口可以接收任意类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断接口具体的类型，跟map类似</span></span><br><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure></p><p>Error处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了error接口的ErrNegativeSqrt</span></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"cannot Sqrt negative number: %v"</span>, <span class="keyword">float64</span>(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">z := <span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> last_z := z; math.Abs(last_z-z) &gt; <span class="number">0.00001</span>; last_z = z &#123;</span><br><span class="line">z -= (z*z - x) / (<span class="number">2</span>*z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, ErrNegativeSqrt(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">fmt.Println(Sqrt(<span class="number">-2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了从无限流中读取'A'的Read方法</span></span><br><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyReader)</span> <span class="title">Read</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(bytes); i++ &#123;</span><br><span class="line">bytes[i]=<span class="string">'A'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(bytes), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在io.Reader上包装，实现rot13算法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rot13Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(b <span class="keyword">byte</span>)</span> <span class="params">(bb <span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (b &gt;= <span class="number">65</span> &amp;&amp; b &lt; <span class="number">78</span>) || (b &gt;= <span class="number">97</span> &amp;&amp; b &lt; <span class="number">110</span>) &#123;</span><br><span class="line">bb = b+<span class="number">13</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="number">78</span> &amp;&amp; b &lt; <span class="number">91</span>) || (b &gt;= <span class="number">110</span> &amp;&amp; b &lt; <span class="number">123</span>) &#123;</span><br><span class="line">bb = b<span class="number">-13</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rot rot13Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">n, e := rot.r.Read(b)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">b[i] = transform(b[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, e</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := strings.NewReader(<span class="string">"Lbh penpxrq gur pbqr!"</span>)</span><br><span class="line">r := rot13Reader&#123;s&#125;</span><br><span class="line">io.Copy(os.Stdout, &amp;r)</span><br><span class="line">    <span class="comment">// output: Youcrackedthecode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现Image接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"golang.org/x/tour/pic"</span></span><br><span class="line"><span class="string">"image/color"</span></span><br><span class="line"><span class="string">"image"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义了一个Image结构体</span></span><br><span class="line"><span class="keyword">type</span> Image <span class="keyword">struct</span>&#123;</span><br><span class="line">w <span class="keyword">int</span></span><br><span class="line">h <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Image实现Image的接口</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type Image interface &#123;</span></span><br><span class="line"><span class="comment">    ColorModel() color.Model</span></span><br><span class="line"><span class="comment">    Bounds() Rectangle</span></span><br><span class="line"><span class="comment">    At(x, y int) color.Color</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span> <span class="title">ColorModel</span><span class="params">()</span> <span class="title">color</span>.<span class="title">Model</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> color.RGBAModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span> <span class="title">Bounds</span><span class="params">()</span> <span class="title">image</span>.<span class="title">Rectangle</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> image.Rect(<span class="number">0</span>, <span class="number">0</span>, img.w, img.h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span> <span class="title">At</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">color</span>.<span class="title">Color</span></span> &#123;</span><br><span class="line">v := <span class="keyword">uint8</span>(x^y)</span><br><span class="line"><span class="keyword">return</span> color.RGBA&#123;v, v, <span class="number">255</span>, <span class="number">255</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := Image&#123;w:<span class="number">200</span>, h:<span class="number">200</span>&#125;</span><br><span class="line"><span class="comment">// 使用实现了Image接口的m</span></span><br><span class="line">pic.ShowImage(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;p&gt;Go没有类，方法跟函数的区别就是多了一个接收器Receiver&lt;/p&gt;
&lt;p&gt;指针接收器，接收到的变量是指针形式的，意味着可以修改原变量。p
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chace.in/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go tour(1)-Basics</title>
    <link href="http://chace.in/2019/06/11/Go-tour-1-Basics/"/>
    <id>http://chace.in/2019/06/11/Go-tour-1-Basics/</id>
    <published>2019-06-11T03:05:17.000Z</published>
    <updated>2019-06-11T03:08:27.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// :=是在函数内部声明变量并赋值，在函数外部不能用</span></span><br><span class="line"><span class="comment">// 变量用var，常量用const，常量不能用:=</span></span><br><span class="line">k := <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> K <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">3</span></span><br><span class="line"><span class="comment">// 返回值可以命名，可以多个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有初始值的变量会被赋零值</span></span><br><span class="line"><span class="comment">/* 基本数据类型</span></span><br><span class="line"><span class="comment">bool string</span></span><br><span class="line"><span class="comment">int int8 .... int64</span></span><br><span class="line"><span class="comment">uint uint8 ...... uint64</span></span><br><span class="line"><span class="comment">byte // uint8的别名 </span></span><br><span class="line"><span class="comment">rune // int32的别名</span></span><br><span class="line"><span class="comment">float32 float64</span></span><br><span class="line"><span class="comment">complex64 complex128</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="分支循环"><a href="#分支循环" class="headerlink" title="分支循环"></a>分支循环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if后面可以跟一句初始语句，整个条件语句作用域可用</span></span><br><span class="line"><span class="keyword">if</span> a:=b<span class="number">-32</span>; a&gt;<span class="number">0</span> &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// switch也可以这样，而且不用显示break</span></span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// switch也可以没有条件表达式</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good morning!"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good evening."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有一种循环for，不用小括号，必须用花括号</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defer声明的语句会在外部函数返回才调用，这些语句会被压入到栈中</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br></pre></td></tr></table></figure><h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line">i := <span class="number">21</span></span><br><span class="line">pp = &amp;i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> Vertext <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">v := Vertex&#123;X:<span class="number">1</span>, Y:<span class="number">2</span>&#125;</span><br><span class="line">p := &amp;v</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="comment">// 切片传参是传指针</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">string</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片以后是在原数组上操作</span></span><br><span class="line"><span class="comment">// 切片的长度和容量：len是切片含有多少个元素，capacity是从切片第一个元素到数组最后一个元素含有的元素个数</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s = s[:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">len</span>(s) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">cap</span>(s) <span class="comment">// 4</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">len</span>(s) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">cap</span>(s) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// make创建动态数组</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// append进行切片追加的时候，如果元素个数大于了capacity，那么按什么方式将底层数组扩容？2,4,8?</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">range</span></span></span><br><span class="line"><span class="function">// <span class="title">v</span>是浅拷贝还是深拷贝？浅拷贝，依然可以通过<span class="title">v</span>操作原数组</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pow = [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">v[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">       <span class="comment">// 可以通过pow[i]对原数组进行操作</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, pow)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[5 2]</span></span><br><span class="line"><span class="comment">[5 4]</span></span><br><span class="line"><span class="comment">[[5 2] [5 4]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>实现built-in的append函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(slice []<span class="keyword">int</span>, data ...<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">m := <span class="built_in">len</span>(slice)</span><br><span class="line">n := m+<span class="built_in">len</span>(data)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">cap</span>(slice) &#123;</span><br><span class="line"><span class="keyword">var</span> newSlice []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">newSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">newSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>*m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(newSlice, slice)</span><br><span class="line">slice = newSlice</span><br><span class="line">&#125;</span><br><span class="line">slice = slice[<span class="number">0</span>:n]</span><br><span class="line"><span class="built_in">copy</span>(slice[m:n], data)</span><br><span class="line"><span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>slice练习<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="keyword">int</span>)</span> [][]<span class="title">uint8</span></span> &#123;</span><br><span class="line">ret := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dy)</span><br><span class="line"><span class="keyword">for</span> y := <span class="keyword">range</span> ret &#123;</span><br><span class="line">ret[y] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> x:=<span class="number">0</span>; x &lt; dx; x++ &#123;</span><br><span class="line">ret[y][x] = <span class="keyword">uint8</span>(<span class="keyword">float64</span>(x)*math.Log(<span class="keyword">float64</span>(y)))</span><br><span class="line">            <span class="comment">// 两种方法都可以</span></span><br><span class="line"><span class="comment">// ret[y] = append(ret[y], uint8(float64(x)*math.Log(float64(y))))</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map初始化</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line"><span class="comment">// 操作</span></span><br><span class="line">a = m[key]</span><br><span class="line"><span class="built_in">delete</span>(m, key) <span class="comment">// 删除key</span></span><br><span class="line">item, ok := m[key] <span class="comment">// 判断key是否在m中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数可以是函数，也可以有匿名函数</span></span><br><span class="line"><span class="comment">// 赋值再调用</span></span><br><span class="line">fplus := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line">fplus(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 直接调用匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x + y &#125; (<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>闭包实现斐波那契数列<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 跟Python不一样的是，不会发生自由变量降级成为局部变量的现象，也不需要nolocal声明。因为go语言需要变量声明，Python不需要变量声明。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fibonacci is a function that returns</span></span><br><span class="line"><span class="comment">// a function that returns an int.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">pre2 := <span class="number">-1</span></span><br><span class="line">pre1 := <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">tmp := pre2</span><br><span class="line">pre2 = pre1</span><br><span class="line">pre1 = tmp + pre1</span><br><span class="line"><span class="keyword">return</span> pre1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chace.in/tags/Go/"/>
    
  </entry>
  
</feed>
