<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chace</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chace.in/"/>
  <updated>2017-10-27T13:48:26.000Z</updated>
  <id>http://chace.in/</id>
  
  <author>
    <name>chace</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fluent Python(5)——函数装饰器和闭包</title>
    <link href="http://chace.in/2017/10/13/Fluent%20Python(5)%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>http://chace.in/2017/10/13/Fluent Python(5)——函数装饰器和闭包/</id>
    <published>2017-10-13T12:04:04.000Z</published>
    <updated>2017-10-27T13:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一章主要介绍的是Python中的装饰器，装饰器有两大特性：</p><ol><li>把被装饰的函数替换成其他函数；</li><li><strong>装饰器在加载模块时立即执行</strong></li></ol><p>即函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。</p><p>Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量，所以这一点必须要小心。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数能访问定义体之外定义的非全局变量。</p><p>另一个术语是自由变量(free variable)。<a href="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables" target="_blank" rel="external">wiki的定义</a>是这样的：</p><blockquote><p>In computer programming, the term free variable refers to variables used in a function that are neither local variables nor parameters of that function. The term non-local variable is often a synonym in this context.</p></blockquote><p>通俗来说，也就是未在本地作用域中绑定的变量。</p><p>自由变量可以隐式定义，也可以使用<code>nolocal</code>关键字显示定义，避免出现上面说的因为在函数定义体中赋值导致变量成为局部变量的情况。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器从本质上就是返回一个装饰后的新的函数。</p><p>标准库中的<code>functools.lru_cache(maxsize=128, typed=True)</code>实现缓存经常被调用的函数返回结果，在递归中使用地会比较多。</p><p>另外，<code>functools.singledispatch</code>可以实现泛函数。</p><p>如果是带有参数的装饰器，要设计到三层的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># clock是参数化装饰器工厂函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(*deco_args)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*func_args)</span>:</span></div><div class="line">            result = func(*func_args)</div><div class="line">            <span class="keyword">return</span> result <span class="comment"># 返回原本func运行的结果</span></div><div class="line">        <span class="keyword">return</span> clocked <span class="comment"># 返回func被装饰后的函数clocked</span></div><div class="line">    <span class="keyword">return</span> decorate <span class="comment"># 返回真正的装饰函数</span></div></pre></td></tr></table></figure></p><p>这个比较复杂，有些是用class而不是function来实现的，参见拓展阅读。有时间再看一下。</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><a href="http://effbot.org/zone/closure.html" target="_blank" rel="external">Closures in Python</a></li><li><a href="https://github.com/GrahamDumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md" target="_blank" rel="external">How you implemented your Python decorator is wrong</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一章主要介绍的是Python中的装饰器，装饰器有两大特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把被装饰的函数替换成其他函数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装饰器在加载模块时立即执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即函数装饰器在导入模块时立即执行，而被装饰的函
      
    
    </summary>
    
    
      <category term="Python" scheme="http://chace.in/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python生成随机字符串</title>
    <link href="http://chace.in/2017/10/07/Python%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://chace.in/2017/10/07/Python生成随机字符串/</id>
    <published>2017-10-07T04:31:23.000Z</published>
    <updated>2017-10-07T05:05:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章的起因是在看微信JS接口demo的Python版本时，看到了一种生成随机字符串的方式，于是在V2EX上写了一个讨论：<a href="https://www.v2ex.com/t/394944#reply16" target="_blank" rel="external">Python生成一段随机字符串的两种写法</a>。这里是对那个讨论的小结。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 方法1</span></div><div class="line">s1 = <span class="string">''</span>.join(<span class="built_in">random</span>.choice(<span class="built_in">string</span>.ascii_letters + <span class="built_in">string</span>.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>))</div><div class="line"></div><div class="line"><span class="meta"># 方法2</span></div><div class="line">s2 = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    s2 += <span class="built_in">random</span>.choice(<span class="built_in">string</span>.ascii_letters + <span class="built_in">string</span>.digits)</div><div class="line"></div><div class="line"><span class="meta"># 方法3</span></div><div class="line">s3 = <span class="string">''</span>.join(<span class="built_in">random</span>.choices(<span class="built_in">string</span>.ascii_letters + <span class="built_in">string</span>.digits, k=<span class="number">10</span>))</div><div class="line"></div><div class="line"><span class="meta"># 方法4</span></div><div class="line">s4 = binascii.hexlify(os.urandom(<span class="number">5</span>)).decode()</div><div class="line"></div><div class="line"><span class="meta"># 方法5</span></div><div class="line">s5 = secrets.token_urlsafe(<span class="number">10</span>)</div></pre></td></tr></table></figure><p>下面是对这几种方法的对比：</p><p><strong>速度上来讲，方法4是最快的</strong></p><p>random.choice()和random.choices()底层都是C语言实现。但是因为choice每次只是生成一个随机字符，如果要生成长字符串，需要反复调用Python的函数，导致速度很慢，而choices是一次生成一个k长度的随机字符串，Python代码调用的少，所以速度要快。详情参考附录2。</p><p>然而os.random()内部实现是直接调用的syscall(such as /dev/urandom on Unix or CryptGenRandom on Windows)，所以速度最快。详情参考附录3。</p><p><strong>方便程度来讲，方法5是最好的</strong></p><p>secrets模块从Python 3.6引入，目的是为了实现生成用于加密的随机字符串。</p><p>对于secrets模块和原理的random模块，官方文档的说明是这样的：In particularly, secrets should be used in preference to the default pseudo-random number generator in the random module, which is designed for modelling and simulation, not security or cryptography.详情参见附录4.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.v2ex.com/t/394944#reply16" target="_blank" rel="external">Python生成一段随机字符串的两种写法</a></li><li><a href="https://hg.python.org/cpython/file/tip/Lib/random.py#l252" target="_blank" rel="external">random模块源码</a></li><li><a href="https://docs.python.org/3/library/os.html?highlight=os%20urandom#os.urandom" target="_blank" rel="external">os.urandom文档</a></li><li><a href="https://docs.python.org/3/library/secrets.html" target="_blank" rel="external">secrets模块文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写这篇文章的起因是在看微信JS接口demo的Python版本时，看到了一种生成随机字符串的方式，于是在V2EX上写了一个讨论：&lt;a href=&quot;https://www.v2ex.com/t/394944#reply16&quot; target=&quot;_blank&quot; rel=&quot;exter
      
    
    </summary>
    
    
      <category term="Python" scheme="http://chace.in/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python(4)——一等函数</title>
    <link href="http://chace.in/2017/09/28/Fluent%20Python(4)%E2%80%94%E2%80%94%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0/"/>
    <id>http://chace.in/2017/09/28/Fluent Python(4)——一等函数/</id>
    <published>2017-09-28T12:48:00.000Z</published>
    <updated>2017-10-27T13:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>可调用对象：在自定义的类Cls中实现<strong>call</strong>()方法即可直接使用cls()调用。</p><p>获取关于函数参数的信息：sig=inspect.signature(func)可以查看函数参数的一些信息，还可以使用sig.bind(**args)绑定参数。</p><p>函数可以添加注解，虽然并不会被用到，但是可以增加函数的可读性。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> func(<span class="string">parm:</span>str, <span class="string">len:</span> <span class="string">'int &gt; 0'</span>=<span class="number">80</span>) -&gt; <span class="string">str:</span></div><div class="line">    <span class="keyword">return</span> parm</div></pre></td></tr></table></figure></p><h3 id="operator模块的函数支持函数式编程"><a href="#operator模块的函数支持函数式编程" class="headerlink" title="operator模块的函数支持函数式编程"></a>operator模块的函数支持函数式编程</h3><p>itemgetter 获取元素<br>attrgetter 获取对象的属性<br>methodcaller(‘replace’,’ ‘, ‘_’) 在对象上调用参数指定的方法<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from operator import itemgetter</div><div class="line">odd=itemgetter<span class="comment">(0,2,4)</span></div><div class="line">odd<span class="comment">(range(10)</span>)</div><div class="line"><span class="attr"># Out[10</span>]: <span class="comment">(0, 2, 4)</span></div></pre></td></tr></table></figure></p><h3 id="functools-partial可以绑定一些参数。"><a href="#functools-partial可以绑定一些参数。" class="headerlink" title="functools.partial可以绑定一些参数。"></a>functools.partial可以绑定一些参数。</h3><p>以下就是定义了一个nfc函数，不用每次都输入NFC这个参数了。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> unicodedata, functools</div><div class="line"><span class="built_in">nfc</span> = functools.partial(unicodedata.normalize, <span class="string">'NFC'</span>)</div><div class="line">s=<span class="string">'你好'</span></div><div class="line"><span class="built_in">nfc</span>(s)</div><div class="line"># Out[<span class="number">15</span>]: <span class="string">'你好'</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可调用对象：在自定义的类Cls中实现&lt;strong&gt;call&lt;/strong&gt;()方法即可直接使用cls()调用。&lt;/p&gt;
&lt;p&gt;获取关于函数参数的信息：sig=inspect.signature(func)可以查看函数参数的一些信息，还可以使用sig.bind(**arg
      
    
    </summary>
    
    
      <category term="Python" scheme="http://chace.in/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python(3)——文本和字节序列</title>
    <link href="http://chace.in/2017/09/25/Fluent%20Python(3)%E2%80%94%E2%80%94%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/"/>
    <id>http://chace.in/2017/09/25/Fluent Python(3)——文本和字节序列/</id>
    <published>2017-09-25T08:38:00.000Z</published>
    <updated>2017-10-27T13:47:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-处理文本文件"><a href="#1-处理文本文件" class="headerlink" title="1.处理文本文件"></a>1.处理文本文件</h2><p><strong>unicode三明治</strong>：bytes-&gt;str-&gt;bytes，中间的文本处理只涉及到str。</p><p><strong>chardet</strong>：检测文本编码的模块。</p><p>不要依赖系统的默认编码，一定要设置编码。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用文本方式打开文本文件</span></div><div class="line"><span class="keyword">open</span>(<span class="string">'a.txt'</span>, <span class="string">'r'</span>, <span class="keyword">encoding</span>=<span class="string">'utf-8'</span>)</div><div class="line"><span class="comment"># 使用二进制模式打开二进制文件</span></div><div class="line"><span class="keyword">open</span>(<span class="string">'a.gif'</span>, <span class="string">'rb'</span>)</div></pre></td></tr></table></figure><h2 id="2-规范化Unicode字符串"><a href="#2-规范化Unicode字符串" class="headerlink" title="2.规范化Unicode字符串"></a>2.规范化Unicode字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nfc_equal</span><span class="params">(str1, str2)</span>:</span></div><div class="line">    <span class="keyword">return</span> normalize(<span class="string">'NFC'</span>, str1)==normalize(<span class="string">'NFC'</span>, str2)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold_equal</span><span class="params">(str1, str2)</span>:</span></div><div class="line">    <span class="keyword">return</span> (normalize(<span class="string">'NFC'</span>, str1).casefold() ==</div><div class="line">        normalize(<span class="string">'NFC'</span>, str2).casefold())</div></pre></td></tr></table></figure><h2 id="3-正则表达式对str和bytes的匹配"><a href="#3-正则表达式对str和bytes的匹配" class="headerlink" title="3.正则表达式对str和bytes的匹配"></a>3.正则表达式对str和bytes的匹配</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 按str形式进行匹配，可以匹配到中文</span></div><div class="line">re.compile(<span class="string">r'\w'</span>)</div><div class="line"><span class="comment"># 按bytes形式进行匹配，只匹配ascii</span></div><div class="line">re.compile(r<span class="string">b'\w'</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-处理文本文件&quot;&gt;&lt;a href=&quot;#1-处理文本文件&quot; class=&quot;headerlink&quot; title=&quot;1.处理文本文件&quot;&gt;&lt;/a&gt;1.处理文本文件&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;unicode三明治&lt;/strong&gt;：bytes-&amp;gt;str-&amp;gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://chace.in/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python(2)——字典和集合</title>
    <link href="http://chace.in/2017/09/13/Fluent%20Python(2)%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
    <id>http://chace.in/2017/09/13/Fluent Python(2)——字典和集合/</id>
    <published>2017-09-13T09:30:18.000Z</published>
    <updated>2017-10-27T13:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-字典"><a href="#1-字典" class="headerlink" title="1. 字典"></a>1. 字典</h2><p>只有可散列类型可用作键，可散列类型：str、bytes、数值、frozenset。</p><p>通过查找来插入新值的时候优化，使用setdefault函数：<br><code>my_dict.setdefault(key, []).append(new_value)</code></p><p>查找取值的时候优化，使用defaultdict：<br><code>my_dict = collections.defaultdict(list)</code></p><p>collections.Counter：给每个键准备一个整数计数器<br>继承UserDict去自定义dict类型<br>types.MappingProxyType：创建一个视图，只可读不可写</p><h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h2><p>求两个集合相同的元素个数：<code>found = len(needles &amp; haystack)</code><br>用{…}比用构造方法set([…])速度要快</p><hr><ol><li>dict和set内部都是用hash表来实现快速查询，也就是空间换时间。</li><li>不可在迭代dict的同时添加新值，因为可能导致散列表发生变化，某些键在迭代时被跳过。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-字典&quot;&gt;&lt;a href=&quot;#1-字典&quot; class=&quot;headerlink&quot; title=&quot;1. 字典&quot;&gt;&lt;/a&gt;1. 字典&lt;/h2&gt;&lt;p&gt;只有可散列类型可用作键，可散列类型：str、bytes、数值、frozenset。&lt;/p&gt;
&lt;p&gt;通过查找来插入新值的时
      
    
    </summary>
    
    
      <category term="Python" scheme="http://chace.in/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python(1)——序列构成的数组</title>
    <link href="http://chace.in/2017/09/13/Fluent%20Python(1)%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>http://chace.in/2017/09/13/Fluent Python(1)——序列构成的数组/</id>
    <published>2017-09-13T09:21:18.000Z</published>
    <updated>2017-10-27T13:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一章在讲Python中的序列类型，其中关于切片、元组还有+=的谜题值得一读。</p><h2 id="1-序列类型"><a href="#1-序列类型" class="headerlink" title="1. 序列类型"></a>1. 序列类型</h2><p>容器序列：list,tuple,collections.deque</p><p>扁平序列：str,bytes,bytearray,memoryview,array.array</p><p>可变序列：list, bytearray,array.array,collections.deque,memoryview</p><p>不可变序列：tuple,str,bytes</p><h2 id="2-生成器表达式与列表推导"><a href="#2-生成器表达式与列表推导" class="headerlink" title="2. 生成器表达式与列表推导"></a>2. 生成器表达式与列表推导</h2><p>生成器表达式可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数中。因此<strong>使用生成器表达式(generator expression)相比列表推导(list comprehension)更能够节省内存</strong>。</p><h2 id="3-更多"><a href="#3-更多" class="headerlink" title="3. 更多"></a>3. 更多</h2><p><img src="/img/序列构成的数组.jpeg" alt=""></p><hr><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://docs.python.org/3/library/string.html#format-string-syntax" target="_blank" rel="external">string format语法格式</a></p><p><a href="http://blog.csdn.net/handsomekang/article/details/9183303" target="_blank" rel="external">string format</a></p><p><a href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" target="_blank" rel="external">为什么数组要从零开始编号 and 为什么是2 ≤ i &lt; 13？</a></p><p><a href="http://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews/" target="_blank" rel="external">memoryview教程减少buffer的复制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一章在讲Python中的序列类型，其中关于切片、元组还有+=的谜题值得一读。&lt;/p&gt;
&lt;h2 id=&quot;1-序列类型&quot;&gt;&lt;a href=&quot;#1-序列类型&quot; class=&quot;headerlink&quot; title=&quot;1. 序列类型&quot;&gt;&lt;/a&gt;1. 序列类型&lt;/h2&gt;&lt;p&gt;容器序列：
      
    
    </summary>
    
    
      <category term="Python" scheme="http://chace.in/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行大全(4)——shell编程</title>
    <link href="http://chace.in/2017/08/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8(4)%E2%80%94%E2%80%94shell%E7%BC%96%E7%A8%8B/"/>
    <id>http://chace.in/2017/08/11/Linux命令行大全(4)——shell编程/</id>
    <published>2017-08-11T06:35:32.000Z</published>
    <updated>2017-09-07T14:27:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><p><strong>数值：</strong> 默认的bash程序中只支持整数运算，使用<code>bc</code>命令可用于浮点运算：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 数值运算需要在(())中</div><div class="line">echo $((<span class="number">1</span>+<span class="number">3</span><span class="number">-2</span>/<span class="number">5</span>*<span class="number">3</span>)) # 输出<span class="string">"4"</span></div><div class="line">echo $((<span class="number">2</span>**<span class="number">3</span>)) # 输出<span class="string">"8"</span></div><div class="line">bc &lt;&lt;&lt; '<span class="number">2.5</span>+<span class="number">4.9</span>*<span class="number">4.7</span>' # 输出<span class="string">"25.5"</span></div></pre></td></tr></table></figure></p><p><strong>字符串：</strong> 字符串的操作比较多：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo="Hello world"</div><div class="line">echo $&#123;#foo&#125; # 输出"11"</div><div class="line">m</div><div class="line">echo $&#123;foo/world/World&#125; # 输出"Hello World"</div></pre></td></tr></table></figure></p><p><strong>数组</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">declare -a a # 创建一个数值</div><div class="line">arr=("1" "2" "abc" "4" 5) # 数组赋值</div><div class="line">arr[0]=8 # 数组赋值</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 以下是*和@输出的区别，*是扩展成一串，而@分开了</span></div><div class="line">for i in "$&#123;arr[*]&#125;"; do echo $i; done</div><div class="line">8 2 abc 4 5</div><div class="line">for i in "$&#123;arr[@]&#125;"; do echo $i; done</div><div class="line">8</div><div class="line">2</div><div class="line">abc</div><div class="line">4</div><div class="line">5</div></pre></td></tr></table></figure></p><h2 id="2-分支、循环"><a href="#2-分支、循环" class="headerlink" title="2. 分支、循环"></a>2. 分支、循环</h2><p>跟类C语言大同小异，需要注意的是条件分支的test命令</p><p><strong>分支：</strong> test命令判断是否符合条件，其中传统的test命令形式为<code>[ express ]</code>，更为现代的形式为用于字符串和普通变量的<code>[[ express ]]</code>和用于数值的<code>(( express ))</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">string=20</div><div class="line"><span class="keyword">if</span> [ -z string ]; <span class="keyword">then</span> <span class="comment"># 判断字符串是否为空</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"string is empty"</span></div><div class="line"><span class="keyword">elif</span> [[ <span class="variable">$string</span> =~ ^h.+o$ ]]; <span class="keyword">then</span> <span class="comment"># 匹配正则表达式</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"string is right"</span></div><div class="line"><span class="keyword">elif</span> (( string&gt;10 )); <span class="keyword">then</span> <span class="comment"># 数值比较</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"string is greater than 10"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"string is not be matched"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="comment"># 输出"string is greater than 10"</span></div></pre></td></tr></table></figure></p><p><strong>循环：</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">while</span>型</span></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]; do</div><div class="line">    printf "%d " $((count++))</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> until型</span></div><div class="line">until [ $count -gt 10 ]; do</div><div class="line">    printf "%d " $((count++))</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 输出<span class="string">"1 2 3 4 5 6 7 8 9 10"</span></span></div></pre></td></tr></table></figure></p><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><p>shell中的函数定义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[function] foo [()] &#123;</div><div class="line">    # action</div><div class="line">    [return int]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash">定义其实是两种形式:</span></div><div class="line">function foo &#123;...&#125;</div><div class="line">foo () &#123;...&#125;</div><div class="line"></div><div class="line">foo # 函数调用</div></pre></td></tr></table></figure><p>不像类C语言在函数括号中传递参数，shell中使用<strong>位置参数</strong>来进行参数传递。shell中的返回值通过<code>$?</code>接收。<br>如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo () &#123;</div><div class="line">    echo $0 # 输出的永远是运行脚本的命令本身</div><div class="line">    echo $($1+$2) # 输出58</div><div class="line">    return (($1+$2+2)) # 返回60，返回值范围是0~255整数</div><div class="line">&#125;</div><div class="line">foo 13 45 # 函数调用</div><div class="line">echo $? # 输出的是最后一次调用foo的返回值60</div></pre></td></tr></table></figure><p>一些特殊的参数如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo $$ # 输出当前进程pid</div><div class="line">echo $# # 输出命令参数个数</div><div class="line">echo $? # 输出函数返回值</div><div class="line">echo $! # 输出后台中最后一次运行的进程pid</div></pre></td></tr></table></figure></p><h2 id="4-实现quicksort"><a href="#4-实现quicksort" class="headerlink" title="4. 实现quicksort"></a>4. 实现quicksort</h2><p>拿个quicksort来作为练习倒是一个不错的选择</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">!/bin/bash -x</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> a quicksort algorithm implement <span class="keyword">in</span> shell</span></div><div class="line"></div><div class="line">arr=(3 23 4 1 45 56 34 78 79 89)</div><div class="line"></div><div class="line">get_pos() &#123;</div><div class="line">    local low=$1</div><div class="line">    local high=$2</div><div class="line">    local value=$&#123;arr[$low]&#125; # 数组取值</div><div class="line"></div><div class="line">    while (( $low&lt;$high )); do</div><div class="line">        while (( $low&lt;$high &amp;&amp; $value&lt;=$&#123;arr[$high]&#125; )); do</div><div class="line">            high=$(($high-1))</div><div class="line">        done</div><div class="line">        if (( $low&lt;$high )); then</div><div class="line">            arr[$low]=$&#123;arr[$high]&#125;</div><div class="line">            ((++low)) # 整数运算只能在(())中</div><div class="line">        fi</div><div class="line">        while (( $low&lt;$high &amp;&amp; $value&gt;=$&#123;arr[$low]&#125; )); do</div><div class="line">            low=$(($low+1))</div><div class="line">        done</div><div class="line">        if (( $low&lt;$high )); then</div><div class="line">            arr[$high]=$&#123;arr[$low]&#125;</div><div class="line">            ((--high)) # 整数运算只能在(())中</div><div class="line">        fi</div><div class="line">    done</div><div class="line"></div><div class="line">    arr[$low]=$value</div><div class="line">    return $low</div><div class="line">&#125;</div><div class="line"></div><div class="line">quicksort() &#123;</div><div class="line">    local low=$1</div><div class="line">    local high=$2</div><div class="line">    local pos=0</div><div class="line">    local tempLow=0</div><div class="line">    local tempHigh=0</div><div class="line">    if (( $low&lt;$high )); then</div><div class="line">        get_pos $low $high</div><div class="line">        pos=$? # 获得返回值</div><div class="line">        tempLow=$(($pos-1))</div><div class="line">        tempHigh=$(($pos+1))</div><div class="line">        quicksort $low $tempLow</div><div class="line">        quicksort $tempHigh $high</div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">quicksort 0 9 # 调用函数</div><div class="line"></div><div class="line">echo $&#123;arr[@]&#125; # 另一种形式是$&#123;arr[*]&#125;，两者区别在前者扩展数组单个元素，后者将数组扩展成一个长串</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数据类型&quot;&gt;&lt;a href=&quot;#1-数据类型&quot; class=&quot;headerlink&quot; title=&quot;1. 数据类型&quot;&gt;&lt;/a&gt;1. 数据类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数值：&lt;/strong&gt; 默认的bash程序中只支持整数运算，使用&lt;code&gt;bc&lt;/c
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://chace.in/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行大全(3)——常见任务和工具</title>
    <link href="http://chace.in/2017/08/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8(3)%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://chace.in/2017/08/11/Linux命令行大全(3)——常见任务和工具/</id>
    <published>2017-08-11T06:33:32.000Z</published>
    <updated>2017-09-07T14:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-软件包管理"><a href="#1-软件包管理" class="headerlink" title="1. 软件包管理"></a>1. 软件包管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-cache search pkg_name # 查找软件包</div><div class="line">apt-cache show pgk_name # 显示软件包信息</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dpkg -i pkg_file # 用.deb安装软件包</div><div class="line">dpkg --list # 列出已安装的软件包列表</div><div class="line">dpkg --status pkg_name # 判断软件包是否已安装</div><div class="line">dpkg --search file_name # 查看某文件由哪个软件包安装得到</div></pre></td></tr></table></figure><h2 id="2-存储"><a href="#2-存储" class="headerlink" title="2. 存储"></a>2. 存储</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mount</div><div class="line">umount /dev/hdc</div><div class="line">fdisk # 磁盘分区</div><div class="line">mkfs -t vfat /dev/sdb1 # 创建文件系统</div><div class="line">dd if=/dev/sdb of=/dev/sdc # 完全复制数据块</div><div class="line">md5sum /dev/cdrom</div></pre></td></tr></table></figure><h2 id="3-网络"><a href="#3-网络" class="headerlink" title="3. 网络"></a>3. 网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget scp ssh</div><div class="line">netstat -ie # 显示网络状态 ifconfig</div><div class="line">netstat -r # 显示路由表</div><div class="line">sftp # 此命令尤其好使，因为sftp使用的是ssh的22端口，所以不需要服务器单独再开服务</div></pre></td></tr></table></figure><h2 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4. 文件搜索"></a>4. 文件搜索</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">find ~ -type f -name '*.bak' -delete # 查找用户目录下.bak文件并删除</div><div class="line">find ~ -type f | wc -l # 统计用户目录下文件个数</div><div class="line">find的两个选项：test和action</div></pre></td></tr></table></figure><h2 id="5-文件归档和压缩"><a href="#5-文件归档和压缩" class="headerlink" title="5. 文件归档和压缩"></a>5. 文件归档和压缩</h2><p>文件归档和压缩是两个概念，zip命令同时包括两种功能</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync -av <span class="params">&lt;dir1&gt;</span> <span class="params">&lt;dir2&gt;</span> <span class="meta"># 同步dir1和dir2</span></div></pre></td></tr></table></figure><p><strong>压缩</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gzip gunzip bzip2 bunzip2</div></pre></td></tr></table></figure><p><strong>归档</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar xzvf &lt;file_name&gt; -C &lt;dir&gt; # 解压到&lt;dir&gt;文件夹下</div><div class="line">tar czvf &lt;file_name&gt; &lt;dir&gt; # 打包dir到file_name</div><div class="line">zip -r &lt;dir&gt; # 压缩dir</div></pre></td></tr></table></figure></p><p><strong>将远程系统中某目录转移到本地系统</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh remote-sys 'tar cf - &lt;dir&gt;' <span class="string">| tar xf -</span></div></pre></td></tr></table></figure><h2 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6. 正则表达式"></a>6. 正则表达式</h2><p>BRE POSIX基本正则表达式 <code>grep &#39;...&#39;</code></p><p>ERE 扩展正则表达式 <code>grep -E &#39;...&#39;</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">find</span> <span class="symbol">&lt;dir&gt;</span> -regex <span class="string">'&lt;regex&gt;'</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">? * + &#123;&#125; . <span class="selector-attr">[]</span> # 元字符</div></pre></td></tr></table></figure><h2 id="7-文本处理"><a href="#7-文本处理" class="headerlink" title="7. 文本处理"></a>7. 文本处理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cut -f &lt;字段编号&gt; &lt;file_name&gt; # 切片某字段</div><div class="line">cat -n # 显示行号</div><div class="line">aspell # 拼写检查</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 比较两文件的不同产生一个patch，并且还原文件</span></div><div class="line">diff -Naur &lt;old_file&gt; &lt;new_file&gt; &gt; file_patch</div><div class="line">patch &lt; file_patch</div><div class="line"></div><div class="line">diff -c/-u &lt;file_1&gt; &lt;file_2&gt; # 将file_1与file_2进行比较</div></pre></td></tr></table></figure><h2 id="8-格式化输出"><a href="#8-格式化输出" class="headerlink" title="8. 格式化输出"></a>8. 格式化输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">printf "format" arguments # 格式化输出</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 输出manual到PDF文件</span></div><div class="line">zcat /usr/share/man/man1/ls.1.gz | groff -mandoc &gt; ~/foo.ps</div><div class="line">ps2pdf foo.ps ls.pdf</div><div class="line"></div><div class="line">a2ps -o ~/ls.ps # ASCII-&gt;PostScript</div><div class="line">lpstat -s # 查看打印机状态</div></pre></td></tr></table></figure><h2 id="9-编译程序"><a href="#9-编译程序" class="headerlink" title="9. 编译程序"></a>9. 编译程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">make # 编译程序</div><div class="line">./configure # 分析生成环境</div><div class="line">make install # 默认安装到/usr/local/bin</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-软件包管理&quot;&gt;&lt;a href=&quot;#1-软件包管理&quot; class=&quot;headerlink&quot; title=&quot;1. 软件包管理&quot;&gt;&lt;/a&gt;1. 软件包管理&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://chace.in/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行大全(2)——配置与环境</title>
    <link href="http://chace.in/2017/08/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8(2)%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%8E%AF%E5%A2%83/"/>
    <id>http://chace.in/2017/08/11/Linux命令行大全(2)——配置与环境/</id>
    <published>2017-08-11T06:32:35.000Z</published>
    <updated>2017-10-08T12:30:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">printenv | less # 查看本机的各种环境变量</div><div class="line">alias ll=“ls -laF” # 为命令起别名</div></pre></td></tr></table></figure><h2 id="2-vi的使用"><a href="#2-vi的使用" class="headerlink" title="2.vi的使用"></a>2.vi的使用</h2><p>这本书里只是简单地讲了一遍，这篇文章讲得更多一些：<a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/" target="_blank" rel="external">Learn Vim Progressively</a>。另外就是阅读<code>:help usr_02.txt</code></p><p>移动光标、删除、复制粘贴对比来记忆就很容易了，都一样。</p><p><strong>移动光标</strong></p><table><thead><tr><th style="text-align:left">键</th><th style="text-align:left">动作</th></tr></thead><tbody><tr><td style="text-align:left">数字0</td><td style="text-align:left">至本行开头</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">至本行末尾</td></tr><tr><td style="text-align:left">G</td><td style="text-align:left">至文件末尾</td></tr><tr><td style="text-align:left">gg</td><td style="text-align:left">至文件开头</td></tr><tr><td style="text-align:left">ctrl+F</td><td style="text-align:left">下翻一页</td></tr><tr><td style="text-align:left">ctrl+B</td><td style="text-align:left">上翻一页</td></tr><tr><td style="text-align:left">number+G</td><td style="text-align:left">至第number行</td></tr></tbody></table><p><strong>删除文本</strong></p><table><thead><tr><th style="text-align:left">键</th><th style="text-align:left">动作</th></tr></thead><tbody><tr><td style="text-align:left">dd</td><td style="text-align:left">删除一行</td></tr><tr><td style="text-align:left">d$</td><td style="text-align:left">删除光标到行末尾</td></tr><tr><td style="text-align:left">d0</td><td style="text-align:left">删除光标到行开头</td></tr><tr><td style="text-align:left">d7</td><td style="text-align:left">删除光标后的7行</td></tr></tbody></table><p><strong>复制粘贴</strong></p><table><thead><tr><th style="text-align:left">键</th><th style="text-align:left">动作</th></tr></thead><tbody><tr><td style="text-align:left">p</td><td style="text-align:left">粘贴文本</td></tr><tr><td style="text-align:left">yy</td><td style="text-align:left">复制一行</td></tr><tr><td style="text-align:left">y$</td><td style="text-align:left">复制到行末尾</td></tr><tr><td style="text-align:left">y0</td><td style="text-align:left">复制到行开头</td></tr><tr><td style="text-align:left">y7</td><td style="text-align:left">复制光标后的7行</td></tr></tbody></table><p><strong>搜索</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/pattern # 按n查找下一个</div><div class="line">:%s/pattern_old/pattern_new/g # 全局替换</div></pre></td></tr></table></figure><p><strong>多文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">:n # 切换下一个</div><div class="line">:N # 切换上一个</div><div class="line">:buffers # 正在编辑的文件</div><div class="line">:buffer 2 # 切换到第2个文件</div><div class="line"></div><div class="line">:e &lt;filename&gt; # 打开一个新的文件</div><div class="line">:r &lt;filename&gt; # 将filename的内容整个复制到当前文件中，光标前</div><div class="line"></div><div class="line">:w &lt;filename&gt; # 另存为新文件</div><div class="line">ZZ # 相当于:wq，智障操作</div></pre></td></tr></table></figure><h2 id="3-提示符"><a href="#3-提示符" class="headerlink" title="3.提示符"></a>3.提示符</h2><p>环境变量<code>PS1</code>中保存的是提示符信息，喜欢可以自己随便改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-环境&quot;&gt;&lt;a href=&quot;#1-环境&quot; class=&quot;headerlink&quot; title=&quot;1.环境&quot;&gt;&lt;/a&gt;1.环境&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://chace.in/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行大全(1)——shell入门</title>
    <link href="http://chace.in/2017/08/11/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8(1)%E2%80%94%E2%80%94shell%E5%85%A5%E9%97%A8/"/>
    <id>http://chace.in/2017/08/11/Linux命令行大全(1)——shell入门/</id>
    <published>2017-08-11T06:30:32.000Z</published>
    <updated>2017-09-07T14:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然一直在用Linux，也折腾过很多命令，但是因为缺乏系统的学习，所以常用到的命令也就那么些，对于Linux更多的命令，自己是缺乏了解的。</p><p>趁着暑假的时间，自己学完了这本《Linux命令行大全》，总体而言这本书讲的还是比较浅，缺乏深入，但是我本身就只是抱着学习命令的态度，所以一路看下来，倒也不至于失望。</p><p>如果只是想学习Linux命令入门，这本书挺好的；但是如果想深入学习Linux的使用，甚至内核开发，那还是另请高明吧！</p><p>以下四篇，是我在看这本书的过程中记录的笔记，有所整理，尽量涵盖主要命令，同时去除掉书中一些冗余的地方。</p><h2 id="1-导航类"><a href="#1-导航类" class="headerlink" title="1. 导航类"></a>1. 导航类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cd - # 返回上一次位置</div><div class="line">ls -la # 显示隐藏文件和长格式</div><div class="line">ls -d # 显示文件夹本身的详细信息，而不是文件夹内的文件信息</div><div class="line">/bin # 系统可执行文件</div><div class="line">/etc # 配置文件</div><div class="line">/usr # 普通用户使用的所有文件和程序</div><div class="line">/usr/include # C语言系统头文件</div><div class="line">/usr/bin # 用户大部分可执行文件</div></pre></td></tr></table></figure><h2 id="2-操作文件与目录"><a href="#2-操作文件与目录" class="headerlink" title="2. 操作文件与目录"></a>2. 操作文件与目录</h2><p><code>-r</code> 一般用于文件夹目录树的递归操作，复制、删除等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir    cp    mv</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -r &lt;dir&gt;</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 建立硬链接和软链接</span></div><div class="line">in &lt;file&gt; &lt;file_hard&gt;</div><div class="line">in -s &lt;file&gt; &lt;file_soft&gt;</div></pre></td></tr></table></figure><h2 id="3-查看命令的属性"><a href="#3-查看命令的属性" class="headerlink" title="3. 查看命令的属性"></a>3. 查看命令的属性</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span>    <span class="type">which    </span>whatis</div></pre></td></tr></table></figure><p>最重要的命令：man、info、help<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man -k &lt;search_string&gt; # 查找哪些命令可用</div></pre></td></tr></table></figure></p><h2 id="4-重定向"><a href="#4-重定向" class="headerlink" title="4. 重定向"></a>4. 重定向</h2><p>重定向符和管道符的区别：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">重定向符将stdout重定向到&gt;后接的文件中；</div><div class="line">管道<span class="keyword">A</span>|B将程序<span class="keyword">A</span>的标准输出重定向到程序B的标准输入中。</div></pre></td></tr></table></figure></p><p>重定向：<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;  标准输出重定向</div><div class="line"><span class="meta">2&gt; </span> 标准错误重定向</div><div class="line">&amp;&gt; 标准输出+标准错误重定向</div><div class="line">&gt;&amp;<span class="number">2</span> 标准输出重定向到标准错误中 （可用于shell脚本输出错误信息）</div></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wc -l # 统计行数  </div><div class="line">wc -w # 统计字数</div><div class="line">head/tail -n &lt;num&gt;</div><div class="line">tee # 读取标准输入，同时输出到标准输出和文件中，相当于可以在中途截取掉信息。</div></pre></td></tr></table></figure><h2 id="5-快捷键"><a href="#5-快捷键" class="headerlink" title="5. 快捷键"></a>5. 快捷键</h2><table><thead><tr><th style="text-align:left">键</th><th style="text-align:left">动作</th><th style="text-align:left">键</th><th style="text-align:left">动作</th></tr></thead><tbody><tr><td style="text-align:left">Ctrl+A</td><td style="text-align:left">移动到行首</td><td style="text-align:left">Ctrl+E</td><td style="text-align:left">移动到行尾</td></tr><tr><td style="text-align:left">Alt+F</td><td style="text-align:left">往前一个字</td><td style="text-align:left">Alt+B</td><td style="text-align:left">往后一个字</td></tr><tr><td style="text-align:left">Ctrl+Y</td><td style="text-align:left">粘贴</td><td style="text-align:left">Ctrl+L</td><td style="text-align:left">清屏</td></tr><tr><td style="text-align:left">Ctrl+K</td><td style="text-align:left">向后剪切到行尾</td><td style="text-align:left">Ctrl+U</td><td style="text-align:left">向前剪切到行头</td></tr></tbody></table><h2 id="6-权限"><a href="#6-权限" class="headerlink" title="6. 权限"></a>6. 权限</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">su    passwd</div><div class="line">chmod xxx &lt;file&gt;</div><div class="line">chown [ower][:[group]] &lt;file&gt;</div></pre></td></tr></table></figure><h2 id="7-进程"><a href="#7-进程" class="headerlink" title="7. 进程"></a>7. 进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ps    top    pstree</div><div class="line">kill -9 &lt;pid/jobspec&gt; # 杀死进程</div><div class="line">kill -l # 查看所有信号格式</div><div class="line">killall -9 &lt;name&gt; # 杀死指定程序的所有进程</div></pre></td></tr></table></figure><p>前后台进程切换：</p><p><img src="process-switch.png" alt="前后台进程切换"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然一直在用Linux，也折腾过很多命令，但是因为缺乏系统的学习，所以常用到的命令也就那么些，对于Linux更多的命令，自己是缺乏了解的。&lt;/p&gt;
&lt;p&gt;趁着暑假的时间，自己学完了这本《Linux命令行大全》，总体而言这本书讲的还是比较浅，缺乏深入，但是我本身就只是抱着学习
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://chace.in/tags/Linux/"/>
    
  </entry>
  
</feed>
