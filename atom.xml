<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chace</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chace.in/"/>
  <updated>2019-09-02T08:04:44.169Z</updated>
  <id>http://chace.in/</id>
  
  <author>
    <name>chace</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s核心组件分析-scheduler</title>
    <link href="http://chace.in/2019/09/02/k8s%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90-scheduler/"/>
    <id>http://chace.in/2019/09/02/k8s核心组件分析-scheduler/</id>
    <published>2019-09-02T07:36:10.000Z</published>
    <updated>2019-09-02T08:04:44.169Z</updated>
    
    <content type="html"><![CDATA[<p>k8s中的scheduler负责资源调度，具体来说，是将某个pod绑定到某个node上。scheduler的输入是待调度的pod和可调度的node，输出是pod和node的bind对象。</p><p><img src="/img/2019/09/k8s-scheduler.png" alt="scheduler的输入输出"></p><h2 id="k8s采集数据"><a href="#k8s采集数据" class="headerlink" title="k8s采集数据"></a>k8s采集数据</h2><p>要进行调度首先得知道哪些需要调度，哪些node可以调度，调度策略需要很多信息来进行决策。k8s中并不会有消息队列来进行组件之间的通信，scheduler是直接访问APIServer来获取集群信息的。但是如果是暴力轮询肯定会给APIServer带来很大负担。所以scheduler在本地做了cache。</p><p>本地cache主要有两种，一种是对于有序资源信息，比如待调度的pod，使用Queue来保存；另一种是无序资源信息，比如可调度的node，使用链表保存。</p><h2 id="k8s的调度算法"><a href="#k8s的调度算法" class="headerlink" title="k8s的调度算法"></a>k8s的调度算法</h2><p>k8s的调度算法是可插拔的，由算法provider提供，一个provider即提供一个调度策略集合，而这个调度策略集合下会包括很多的计算方法。</p><p>这些具体的计算方法包括两类：predicates和priorities。</p><p>predicates解决pod能不能被调度到某个node上去，而priorities是在可调度的node中排优先级。</p><h3 id="predicates"><a href="#predicates" class="headerlink" title="predicates"></a>predicates</h3><p>有判断会不会HostPort冲突的，也有判断NodeSelector的。所有predicates都满足，则该pod和该node是可以绑定的。</p><h3 id="priorities"><a href="#priorities" class="headerlink" title="priorities"></a>priorities</h3><p>这里是采用计算score的方式。每个priority算法返回一个0~10的score，然后计算<code>sum = priorities · weights</code>(这里是点乘的意思)。调度pod到得分最高的pod上去。</p><p>一般就根据资源分配情况，selector的分配情况来计算。</p><h2 id="k8s的启动与运行"><a href="#k8s的启动与运行" class="headerlink" title="k8s的启动与运行"></a>k8s的启动与运行</h2><ol><li>收集scheduler产生的事件信息，发送给APIServer</li><li>创建一个http server，端口默认是10250</li><li>根据配置创建启动scheduler</li><li>注册metrics规则，检测scheduler的性能</li></ol><p>k8s在完成绑定以后，其实是创建了一个Binding对象，发送给APIServer。（最后由Controller Manager通知绑定的node的kubelet创建绑定的pod）</p><h2 id="multi-scheduler的问题"><a href="#multi-scheduler的问题" class="headerlink" title="multi-scheduler的问题"></a>multi-scheduler的问题</h2><p>如果需要多个调度器，目前的解决办法是使用annotations的方式给pod指定由某个scheduler调度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;k8s中的scheduler负责资源调度，具体来说，是将某个pod绑定到某个node上。scheduler的输入是待调度的pod和可调度的node，输出是pod和node的bind对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019/09/k8s-scheduler
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://chace.in/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Docker架构分析</title>
    <link href="http://chace.in/2019/09/01/Docker%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://chace.in/2019/09/01/Docker架构分析/</id>
    <published>2019-09-01T11:34:33.000Z</published>
    <updated>2019-09-02T02:05:45.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker架构概览"><a href="#Docker架构概览" class="headerlink" title="Docker架构概览"></a>Docker架构概览</h2><p><strong>网上很多架构图中都有Docker Engine和Job，但是1.7版本其实不再用这种方式。</strong></p><p>Docker使用C/S架构。用户通过Docker client与Docker daemon通信，Docker daemon中有个API Server处理具体请求。而具体到后端的实际操作，Docker则分了很多模块，其中对容器运行时、volume、镜像以及网络方面的具体实现已经放在daemon以外的模块中。</p><p><img src="/img/2019/09/docker.png" alt="Docker架构"></p><p>其中execdriver是容器执行驱动，volumedriver是volume存储驱动，graphdriver是镜像存储驱动。</p><p>网络部分现在已经分离成一个libnetwork库独立维护。</p><h2 id="client和daemon"><a href="#client和daemon" class="headerlink" title="client和daemon"></a>client和daemon</h2><p>client模式的命令基本就是执行对应方法，向daemon发起请求，之后读取docker daemon的返回结果。</p><p>daemon首先要启动一个API server，然后创建各种容器配置和环境(/var/lib/docker/)以及网络，最后一个daemon对象诞生。</p><p>启动容器再执行下去就是去调用execdriver了，这一块再交由底层模块处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker架构概览&quot;&gt;&lt;a href=&quot;#Docker架构概览&quot; class=&quot;headerlink&quot; title=&quot;Docker架构概览&quot;&gt;&lt;/a&gt;Docker架构概览&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;网上很多架构图中都有Docker Engine和Job，但是
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://chace.in/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Airflow源码分析(3)-jinja渲染部分</title>
    <link href="http://chace.in/2019/09/01/Airflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(3)-jinja%E6%B8%B2%E6%9F%93%E9%83%A8%E5%88%86/"/>
    <id>http://chace.in/2019/09/01/Airflow源码分析(3)-jinja渲染部分/</id>
    <published>2019-09-01T04:07:37.000Z</published>
    <updated>2019-09-01T04:20:58.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Jinja渲染在Airflow用于参数跟字段的渲染，这里做一个简单的实现分析。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>模板渲染的流程是在TaskInstance()._run_raw_task()中进行的。</p><h3 id="run-raw-task"><a href="#run-raw-task" class="headerlink" title="_run_raw_task"></a>_run_raw_task</h3><p>_run_raw_task大致的逻辑如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_raw_task</span><span class="params">(...)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 渲染模板主要在这两个函数里面</span></span><br><span class="line">context = self.get_template_context()</span><br><span class="line">self.render_templates()</span><br><span class="line"><span class="comment"># 真正地执行</span></span><br><span class="line">task_copy.pre_execute(context=context)</span><br><span class="line">result = task_copy.execute(context=context)</span><br><span class="line">task_copy.post_execute(context=context, result=result)</span><br><span class="line"><span class="keyword">except</span> AirflowSkipException:</span><br><span class="line">    self.state = State.SKIPPED</span><br><span class="line"><span class="keyword">except</span> AirflowRescheduleException：</span><br><span class="line">self._handle_reschedule()</span><br><span class="line"><span class="keyword">except</span> Error:</span><br><span class="line"><span class="comment"># 会处理retry的情况以及on_failure_callback()</span></span><br><span class="line">self.handle_failure()</span><br><span class="line"><span class="comment"># 执行成功时的回调函数</span></span><br><span class="line"><span class="keyword">if</span> task.on_success_callback:</span><br><span class="line">                task.on_success_callback(context)</span><br></pre></td></tr></table></figure></p><h3 id="get-template-context"><a href="#get-template-context" class="headerlink" title="get_template_context"></a>get_template_context</h3><p>get_template_context中实际就是获取各种值，从返回值我们可以看到那些字段是可以通过context[‘variable’]拿到的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">get_template_context</span><span class="params">(self, session=None)</span>:</span></span><br><span class="line"> ...</span><br><span class="line">   <span class="comment"># 这里会发现trigger_dag中依然可以通过传递conf的方式覆盖参数值。conf是dict或者序列化的dict。</span></span><br><span class="line"><span class="comment"># 如果在airflow.cfg中，dag_run_conf_overrides_params=True的话</span></span><br><span class="line"><span class="comment"># 在pre_execute之前，会有params.update(dag_run.conf)的操作</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> configuration.getboolean(<span class="string">'core'</span>, <span class="string">'dag_run_conf_overrides_params'</span>):</span><br><span class="line">          self.overwrite_params_with_dag_run_conf(params=params, dag_run=dag_run)</span><br><span class="line">         </span><br><span class="line">         <span class="comment"># 这个类也是对应&#123;var.value.your_variable_name&#125;这种方式的实现</span></span><br><span class="line">         <span class="class"><span class="keyword">class</span> <span class="title">VariableAccessor</span>:</span></span><br><span class="line">         <span class="string">"""</span></span><br><span class="line"><span class="string">         Wrapper around Variable. This way you can get variables in templates by using</span></span><br><span class="line"><span class="string">         &#123;var.value.your_variable_name&#125;.</span></span><br><span class="line"><span class="string">         """</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">             self.var = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">             self.var = Variable.get(item)</span><br><span class="line">             <span class="keyword">return</span> self.var</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">             <span class="keyword">return</span> str(self.var)</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="string">'dag'</span>: task.dag,</span><br><span class="line">         <span class="string">'ds'</span>: ds,</span><br><span class="line">         <span class="string">'next_ds'</span>: next_ds,</span><br><span class="line">         <span class="string">'next_ds_nodash'</span>: next_ds_nodash,</span><br><span class="line">         <span class="string">'prev_ds'</span>: prev_ds,</span><br><span class="line">         <span class="string">'prev_ds_nodash'</span>: prev_ds_nodash,</span><br><span class="line">         <span class="string">'ds_nodash'</span>: ds_nodash,</span><br><span class="line">         <span class="string">'ts'</span>: ts,</span><br><span class="line">         <span class="string">'ts_nodash'</span>: ts_nodash,</span><br><span class="line">         <span class="string">'ts_nodash_with_tz'</span>: ts_nodash_with_tz,</span><br><span class="line">         <span class="string">'yesterday_ds'</span>: yesterday_ds,</span><br><span class="line">         <span class="string">'yesterday_ds_nodash'</span>: yesterday_ds_nodash,</span><br><span class="line">         <span class="string">'tomorrow_ds'</span>: tomorrow_ds,</span><br><span class="line">         <span class="string">'tomorrow_ds_nodash'</span>: tomorrow_ds_nodash,</span><br><span class="line">         <span class="string">'END_DATE'</span>: ds,</span><br><span class="line">         <span class="string">'end_date'</span>: ds,</span><br><span class="line">         <span class="string">'dag_run'</span>: dag_run,</span><br><span class="line">         <span class="string">'run_id'</span>: run_id,</span><br><span class="line">         <span class="string">'execution_date'</span>: self.execution_date,</span><br><span class="line">         <span class="string">'prev_execution_date'</span>: prev_execution_date,</span><br><span class="line">         <span class="string">'prev_execution_date_success'</span>: lazy_object_proxy.Proxy(</span><br><span class="line">             <span class="keyword">lambda</span>: self.previous_execution_date_success),</span><br><span class="line">         <span class="string">'prev_start_date_success'</span>: lazy_object_proxy.Proxy(<span class="keyword">lambda</span>: self.previous_start_date_success),</span><br><span class="line">         <span class="string">'next_execution_date'</span>: next_execution_date,</span><br><span class="line">         <span class="string">'latest_date'</span>: ds,</span><br><span class="line">         <span class="string">'macros'</span>: macros,</span><br><span class="line">         <span class="string">'params'</span>: params,</span><br><span class="line">         <span class="string">'tables'</span>: tables,</span><br><span class="line">         <span class="string">'task'</span>: task,</span><br><span class="line">         <span class="string">'task_instance'</span>: self,</span><br><span class="line">         <span class="string">'ti'</span>: self,</span><br><span class="line">         <span class="string">'task_instance_key_str'</span>: ti_key_str,</span><br><span class="line">         <span class="string">'conf'</span>: configuration,</span><br><span class="line">         <span class="string">'test_mode'</span>: self.test_mode,</span><br><span class="line">         <span class="string">'var'</span>: &#123;</span><br><span class="line">             <span class="string">'value'</span>: VariableAccessor(), <span class="comment"># NOTICE</span></span><br><span class="line">             <span class="string">'json'</span>: VariableJsonAccessor()</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="string">'inlets'</span>: task.inlets,</span><br><span class="line">         <span class="string">'outlets'</span>: task.outlets,</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><h3 id="render-templates"><a href="#render-templates" class="headerlink" title="render_templates"></a>render_templates</h3><p>render_templates方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_templates</span><span class="params">(self)</span>:</span></span><br><span class="line">    task = self.task</span><br><span class="line">    <span class="comment"># 这里又调用了一次get_template_context，因为有dry_run的情况</span></span><br><span class="line">    <span class="comment"># dry_run中不会调用get_template_context</span></span><br><span class="line">    jinja_context = self.get_template_context()</span><br><span class="line">    <span class="keyword">if</span> hasattr(self, <span class="string">'task'</span>) <span class="keyword">and</span> hasattr(self.task, <span class="string">'dag'</span>):</span><br><span class="line">     <span class="comment"># 这里也是user_defined_macros的实际处理</span></span><br><span class="line">     <span class="comment"># 比如user_defined_macros=dict(foo='bar')，那么可以使用&#123;&#123; foo &#125;&#125;拿到</span></span><br><span class="line">        <span class="keyword">if</span> self.task.dag.user_defined_macros:</span><br><span class="line">            jinja_context.update(</span><br><span class="line">                self.task.dag.user_defined_macros)</span><br><span class="line"></span><br><span class="line">    rt = self.task.render_template  <span class="comment"># shortcut to method</span></span><br><span class="line">    <span class="comment"># 这里可以发现Operator中定义的template_fields的作用，只有这里面的字段才会被渲染</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> task.__class__.template_fields:</span><br><span class="line">        content = getattr(task, attr)</span><br><span class="line">        <span class="keyword">if</span> content:</span><br><span class="line">            <span class="comment"># 真正的渲染逻辑在task.render_template中</span></span><br><span class="line">            <span class="comment"># 参数为(属性名，内容，上下文)</span></span><br><span class="line">            rendered_content = rt(attr, content, jinja_context)</span><br><span class="line">            <span class="comment"># 修改task的属性值为渲染后的内容</span></span><br><span class="line">            setattr(task, attr, rendered_content)</span><br></pre></td></tr></table></figure></p><h3 id="BaseOperator中的渲染"><a href="#BaseOperator中的渲染" class="headerlink" title="BaseOperator中的渲染"></a>BaseOperator中的渲染</h3><p>接下来我们进入到BaseOperator中，来看一下到底是怎么渲染的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_template</span><span class="params">(self, attr, content, context)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Renders a template either from a file or directly in a field, and returns</span></span><br><span class="line"><span class="string">    the rendered result.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 首先，初始化jinja对象</span></span><br><span class="line">    jinja_env = self.get_template_env()</span><br><span class="line"></span><br><span class="line">    exts = self.__class__.template_ext</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">            isinstance(content, six.string_types) <span class="keyword">and</span></span><br><span class="line">            any([content.endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> exts])):</span><br><span class="line">        <span class="comment"># 对于在template_ext=[]中定义的文件后缀，直接去读取文件内容渲染</span></span><br><span class="line">        <span class="comment"># 比如bash_command='test.sh', template_ext=['.sh']，那么会直接去将test.sh中的内容渲染出来</span></span><br><span class="line">        <span class="keyword">return</span> jinja_env.get_template(content).render(**context)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">     <span class="comment"># 这里继续调用自身方法</span></span><br><span class="line">        <span class="keyword">return</span> self.render_template_from_field(attr, content, context, jinja_env)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_template_env</span><span class="params">(self)</span>:</span></span><br><span class="line"> <span class="comment"># 这里会调用到DAG的get_template_env，将DAG级别的macro, filter, template_search_path加载进来</span></span><br><span class="line">    <span class="keyword">return</span> self.dag.get_template_env() \</span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">'dag'</span>) \</span><br><span class="line">        <span class="keyword">else</span> jinja2.Environment(cache_size=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render_template_from_field</span><span class="params">(self, attr, content, context, jinja_env)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Renders a template from a field. If the field is a string, it will</span></span><br><span class="line"><span class="string">    simply render the string and return the result. If it is a collection or</span></span><br><span class="line"><span class="string">    nested set of collections, it will traverse the structure and render</span></span><br><span class="line"><span class="string">    all elements in it. If the field has another type, it will return it as it is.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    rt = self.render_template</span><br><span class="line">    <span class="keyword">if</span> isinstance(content, six.string_types):</span><br><span class="line">        result = jinja_env.from_string(content).render(**context)</span><br><span class="line">        <span class="comment"># 对于list, tuple, dict类型的变量，会递归地获取字段值，最终还是`基于字符串的渲染`或者`直接返回其他类型`</span></span><br><span class="line">    <span class="keyword">elif</span> isinstance(content, (list, tuple)):</span><br><span class="line">        result = [rt(attr, e, context) <span class="keyword">for</span> e <span class="keyword">in</span> content]</span><br><span class="line">    <span class="keyword">elif</span> isinstance(content, dict):</span><br><span class="line">        result = &#123;</span><br><span class="line">            k: rt(<span class="string">"&#123;&#125;[&#123;&#125;]"</span>.format(attr, k), v, context)</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> list(content.items())&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = content</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>至此，模板渲染就完成了。task的一些属性会被渲染后的content代替。</p><p>另外还有两个方法，是将前面说的<strong>模板文件</strong>的内容加载进来，替换掉原来的<strong>文件名</strong>。同时在最后面<code>prepare_template()</code>方法，可以在这一步对模板文件的内容进行修改。</p><h3 id="在渲染前修改模板内容"><a href="#在渲染前修改模板内容" class="headerlink" title="在渲染前修改模板内容"></a>在渲染前修改模板内容</h3><p><code>resolve_template_files()</code>方法只在bag_dag和web view中有调用，起到将渲染前内容加载出来的作用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resolve_template_files</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># Getting the content of files for template_field / template_ext</span></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> self.template_fields:</span><br><span class="line">        content = getattr(self, attr)</span><br><span class="line">        <span class="keyword">if</span> content <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(content, six.string_types) <span class="keyword">and</span> \</span><br><span class="line">                any([content.endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> self.template_ext]):</span><br><span class="line">            env = self.get_template_env()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                setattr(self, attr, env.loader.get_source(env, content)[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                self.log.exception(e)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(content, list):</span><br><span class="line">            env = self.dag.get_template_env()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(content)):</span><br><span class="line">                <span class="keyword">if</span> isinstance(content[i], six.string_types) <span class="keyword">and</span> \</span><br><span class="line">                        any([content[i].endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> self.template_ext]):</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        content[i] = env.loader.get_source(env, content[i])[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                        self.log.exception(e)</span><br><span class="line">    self.prepare_template()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare_template</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Hook that is triggered after the templated fields get replaced</span></span><br><span class="line"><span class="string">    by their content. If you need your operator to alter the</span></span><br><span class="line"><span class="string">    content of the file before the template is rendered,</span></span><br><span class="line"><span class="string">    it should override this method to do so.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Jinja渲染在Airflow用于参数跟字段的渲染，这里做一个简单的实现分析。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; 
      
    
    </summary>
    
    
      <category term="Airflow" scheme="http://chace.in/tags/Airflow/"/>
    
      <category term="任务编排调度" scheme="http://chace.in/tags/%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Airflow源码分析(2)-xcom部分</title>
    <link href="http://chace.in/2019/09/01/Airflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)-xcom%E9%83%A8%E5%88%86/"/>
    <id>http://chace.in/2019/09/01/Airflow源码分析(2)-xcom部分/</id>
    <published>2019-09-01T04:07:22.000Z</published>
    <updated>2019-09-01T04:20:47.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xcom简介"><a href="#xcom简介" class="headerlink" title="xcom简介"></a>xcom简介</h2><p>XComs(cross-communication)使得任务之间可以交换信息，允许更细粒度的控制和状态共享。XComs包含key, value, timestamp, 同时也包含创建xcom的任务实例的task_id, dag_id, execution_date等。</p><p>Task可以在运行时通过<code>xcom_push(key, value)</code>发送任意<strong>可序列化成JSON</strong>的对象。（其实支持pickle，但是已经被废弃）另外，task.execute()的返回值会默认发送到xcom，key为return_value。</p><p>Task中也可以通过<code>xcom_pull(task_id(s), key)</code>获取到一个或多个task的xcom值。不局限于下游。</p><p>详细介绍参考：<a href="https://airflow.apache.org/concepts.html#xcoms" target="_blank" rel="noopener">xcom</a></p><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>在任务执行前，会先生成运行时的上下文context，然后调用task.execute(context)。因此在Operator的execute(context)方法中可以通过context[‘ti’]得到当前的TaskInstance，然后调用<code>xcom_push</code>和<code>xcom_pull</code></p><p>这里的context包含很多字段，比如ti, task, dag对象，还有Jinja渲染需要的字段。</p><h3 id="Context的字段定义"><a href="#Context的字段定义" class="headerlink" title="Context的字段定义"></a>Context的字段定义</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            'dag': task.dag,</span><br><span class="line">            'ds': ds,</span><br><span class="line">            'next_ds': next_ds,</span><br><span class="line">            'next_ds_nodash': next_ds_nodash,</span><br><span class="line">            'prev_ds': prev_ds,</span><br><span class="line">            'prev_ds_nodash': prev_ds_nodash,</span><br><span class="line">            'ds_nodash': ds_nodash,</span><br><span class="line">            'ts': ts,</span><br><span class="line">            'ts_nodash': ts_nodash,</span><br><span class="line">            'ts_nodash_with_tz': ts_nodash_with_tz,</span><br><span class="line">            'yesterday_ds': yesterday_ds,</span><br><span class="line">            'yesterday_ds_nodash': yesterday_ds_nodash,</span><br><span class="line">            'tomorrow_ds': tomorrow_ds,</span><br><span class="line">            'tomorrow_ds_nodash': tomorrow_ds_nodash,</span><br><span class="line">            'END_DATE': ds,</span><br><span class="line">            'end_date': ds,</span><br><span class="line">            'dag_run': dag_run,</span><br><span class="line">            'run_id': run_id,</span><br><span class="line">            'execution_date': self.execution_date,</span><br><span class="line">            'prev_execution_date': prev_execution_date,</span><br><span class="line">            'prev_execution_date_success': lazy_object_proxy.Proxy(</span><br><span class="line">                lambda: self.previous_execution_date_success),</span><br><span class="line">            'prev_start_date_success': lazy_object_proxy.Proxy(lambda: self.previous_start_date_success),</span><br><span class="line">            'next_execution_date': next_execution_date,</span><br><span class="line">            'latest_date': ds,</span><br><span class="line">            'macros': macros,</span><br><span class="line">            'params': params,</span><br><span class="line">            'tables': tables,</span><br><span class="line">            'task': task,</span><br><span class="line">            'task_instance': self,</span><br><span class="line">            'ti': self,</span><br><span class="line">            'task_instance_key_str': ti_key_str,</span><br><span class="line">            'conf': configuration,</span><br><span class="line">            'test_mode': self.test_mode,</span><br><span class="line">            'var': &#123;</span><br><span class="line">                'value': VariableAccessor(), # NOTICE</span><br><span class="line">                'json': VariableJsonAccessor()</span><br><span class="line">            &#125;,</span><br><span class="line">            'inlets': task.inlets,</span><br><span class="line">            'outlets': task.outlets,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="xcom-py"><a href="#xcom-py" class="headerlink" title="xcom.py"></a>xcom.py</h3><p>Xcom是Model定义类，在里面实现了set(), get_one(), get_many(), delete()方法，对应数据库的增删查。</p><h3 id="taskinstance-py"><a href="#taskinstance-py" class="headerlink" title="taskinstance.py"></a>taskinstance.py</h3><p>上面说的xcom_pull()和xcom_push在BaseOperator和TaskInstance中均有定义。BaseOperator中只是简单调用了TaskInstance中的方法。</p><p><strong>TaskInstance部分代码：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xcom_push</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        key,</span></span></span><br><span class="line"><span class="function"><span class="params">        value,</span></span></span><br><span class="line"><span class="function"><span class="params">        execution_date=None)</span>:</span></span><br><span class="line">    <span class="comment"># 这里日期设置为未来一个时间，到时才可以被其他task发现</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param execution_date: if provided, the XCom will not be visible until</span></span><br><span class="line"><span class="string">        this date. This can be used, for example, to send a message to a</span></span><br><span class="line"><span class="string">        task on a future date without it being immediately visible.</span></span><br><span class="line"><span class="string">    :type execution_date: datetime</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> execution_date <span class="keyword">and</span> execution_date &lt; self.execution_date:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">'execution_date can not be in the past (current '</span></span><br><span class="line">            <span class="string">'execution_date is &#123;&#125;; received &#123;&#125;)'</span>.format(</span><br><span class="line">                self.execution_date, execution_date))</span><br><span class="line"></span><br><span class="line">    XCom.set(</span><br><span class="line">        key=key,</span><br><span class="line">        value=value,</span><br><span class="line">        task_id=self.task_id,</span><br><span class="line">        dag_id=self.dag_id,</span><br><span class="line">        execution_date=execution_date <span class="keyword">or</span> self.execution_date)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xcom_pull</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        task_ids=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        dag_id=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        key=XCOM_RETURN_KEY,</span></span></span><br><span class="line"><span class="function"><span class="params">        include_prior_dates=False)</span>:</span></span><br><span class="line">    <span class="comment"># 这里是为了得到那些设置为未来可见的xcom对象</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param include_prior_dates: If False, only XComs from the current</span></span><br><span class="line"><span class="string">        execution_date are returned. If True, XComs from previous dates</span></span><br><span class="line"><span class="string">        are returned as well.</span></span><br><span class="line"><span class="string">    :type include_prior_dates: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dag_id <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        dag_id = self.dag_id</span><br><span class="line"></span><br><span class="line">    pull_fn = functools.partial(</span><br><span class="line">        XCom.get_one,</span><br><span class="line">        execution_date=self.execution_date,</span><br><span class="line">        key=key,</span><br><span class="line">        dag_id=dag_id,</span><br><span class="line">        include_prior_dates=include_prior_dates)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_container(task_ids):</span><br><span class="line">        <span class="keyword">return</span> tuple(pull_fn(task_id=t) <span class="keyword">for</span> t <span class="keyword">in</span> task_ids)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> pull_fn(task_id=task_ids)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;xcom简介&quot;&gt;&lt;a href=&quot;#xcom简介&quot; class=&quot;headerlink&quot; title=&quot;xcom简介&quot;&gt;&lt;/a&gt;xcom简介&lt;/h2&gt;&lt;p&gt;XComs(cross-communication)使得任务之间可以交换信息，允许更细粒度的控制和状态共享。
      
    
    </summary>
    
    
      <category term="Airflow" scheme="http://chace.in/tags/Airflow/"/>
    
      <category term="任务编排调度" scheme="http://chace.in/tags/%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Airflow源码分析(1)-executor部分</title>
    <link href="http://chace.in/2019/09/01/Airflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)-executor%E9%83%A8%E5%88%86/"/>
    <id>http://chace.in/2019/09/01/Airflow源码分析(1)-executor部分/</id>
    <published>2019-09-01T04:07:07.000Z</published>
    <updated>2019-09-01T04:20:38.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Executor简介"><a href="#Executor简介" class="headerlink" title="Executor简介"></a>Executor简介</h2><p>Executor是在scheduler和worker之间的一个组件，主要作用是接收scheduler发过来的可执行task，然后根据自身类型决定task的运行环境。</p><p>目前有四种类型：</p><ol><li>SequentialExecutor：Dag在单进程中顺序执行，用于测试跟开发</li><li>LocalExecutor：Dag在本地多进程执行，也是用于测试跟开发</li><li>CeleryExecutor：通过Celery下发任务到分布式集群。</li><li>DaskExecutor：下发任务到Dask集群上执行。Dask不支持队列。</li></ol><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>scheduler经过各种验证以后，终于将task标记为queued状态。</p><p>接下来，scheduler调用executor.queue_command将task_instance交给实际的executor。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.executor.queue_command(simple_task_instance, command, priority=priority, queue=queue)</span><br></pre></td></tr></table></figure><h3 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h3><p>我们打开<code>base_executor.py</code>，这个文件中<code>BaseExecutor</code>类作为具体executor的基类，可以看出executor大概的一个流程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个任务队列和一个事件buffer都是dict类型的，key是task_id</span></span><br><span class="line">        self.queued_tasks = OrderedDict()</span><br><span class="line">        self.running = &#123;&#125;</span><br><span class="line">        self.event_buffer = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个方法就是上面scheduler调用的方法，可以看出，BaseExecutor里维护了queued_tasks的任务队列，在这个方法里将新的task加入到了queued_tasks中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">queue_command</span><span class="params">(self, simple_task_instance, command, priority=<span class="number">1</span>, queue=None)</span>:</span></span><br><span class="line">        key = simple_task_instance.key</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.queued_tasks <span class="keyword">and</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.running:</span><br><span class="line">            self.log.info(<span class="string">"Adding to queue: %s"</span>, command)</span><br><span class="line">            self.queued_tasks[key] = (command, priority, queue, simple_task_instance)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.log.info(<span class="string">"could not queue task %s"</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scheduler会在自身的心跳间隔中重复调用executor.heartbeat()</span></span><br><span class="line"><span class="comment"># heartbeat()方法中，除了会打印executor的状态外，还会调用trigger_task()触发任务和sync()来同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heartbeat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Triggering new jobs</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.parallelism:</span><br><span class="line">            open_slots = len(self.queued_tasks)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            open_slots = self.parallelism - len(self.running)</span><br><span class="line"></span><br><span class="line">        num_running_tasks = len(self.running)</span><br><span class="line">        num_queued_tasks = len(self.queued_tasks)</span><br><span class="line"></span><br><span class="line">        self.log.debug(<span class="string">"%s running task instances"</span>, num_running_tasks)</span><br><span class="line">        self.log.debug(<span class="string">"%s in queue"</span>, num_queued_tasks)</span><br><span class="line">        self.log.debug(<span class="string">"%s open slots"</span>, open_slots)</span><br><span class="line"></span><br><span class="line">        Stats.gauge(<span class="string">'executor.open_slots'</span>, open_slots)</span><br><span class="line">        Stats.gauge(<span class="string">'executor.queued_tasks'</span>, num_queued_tasks)</span><br><span class="line">        Stats.gauge(<span class="string">'executor.running_tasks'</span>, num_running_tasks)</span><br><span class="line"></span><br><span class="line">        self.trigger_tasks(open_slots)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calling child class sync method</span></span><br><span class="line">        self.log.debug(<span class="string">"Calling the %s sync method"</span>, self.__class__)</span><br><span class="line">        self.sync()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在trigger_tasks()方法中，最终会调用execute_async()方法来执行命令</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trigger_tasks</span><span class="params">(self, open_slots)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Trigger tasks</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param open_slots: Number of open slots</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sorted_queue = sorted(</span><br><span class="line">            [(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> self.queued_tasks.items()],</span><br><span class="line">            key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">            reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min((open_slots, len(self.queued_tasks)))):</span><br><span class="line">            key, (command, _, queue, simple_ti) = sorted_queue.pop(<span class="number">0</span>)</span><br><span class="line">            self.queued_tasks.pop(key)</span><br><span class="line">            self.running[key] = command</span><br><span class="line">            self.execute_async(key=key,</span><br><span class="line">                               command=command,</span><br><span class="line">                               queue=queue,</span><br><span class="line">                               executor_config=simple_ti.executor_config)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sync()和execute_async()都是抽象方法，但是从注释中我们可以看出其作用</span></span><br><span class="line"><span class="comment"># sync()用于收集状态，execute_async()是异步执行命令</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sync</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Sync will get called periodically by the heartbeat method.</span></span><br><span class="line"><span class="string">        Executors should override this to perform gather statuses.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute_async</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                      key,</span></span></span><br><span class="line"><span class="function"><span class="params">                      command,</span></span></span><br><span class="line"><span class="function"><span class="params">                      queue=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                      executor_config=None)</span>:</span>  <span class="comment"># pragma: no cover</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        This method will execute the command asynchronously.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="comment"># change_state(...)只会改变event_buffer中的事件状态，但不会真正改变task的状态。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_state</span><span class="params">(self, key, state)</span>:</span></span><br><span class="line">        self.log.debug(<span class="string">"Changing state: %s"</span>, key)</span><br><span class="line">        self.running.pop(key, <span class="keyword">None</span>)</span><br><span class="line">        self.event_buffer[key] = state</span><br></pre></td></tr></table></figure><p>总结一下executor的功能：</p><ol><li>接收来自scheduler的task，加入到自身维护的queued_tasks中</li><li>在接收到scheduler的心跳后，打印自身的一些状态，在trigger_tasks(…)中将task从queued_tasks转移到running中，并最终调用execute_async(…)异步执行命令并调用sync(…)收集状态</li><li>scheduler可以调用get_event_buffer(…)获取executor的事件。executor改变自身维护的queued_tasks和running队列中task的状态时，都会上报事件到event_buffer中，从而可以被scheduler获取到</li></ol><h3 id="SequentialExecutor"><a href="#SequentialExecutor" class="headerlink" title="SequentialExecutor"></a>SequentialExecutor</h3><p>接下来以SequentialExecutor为例，看下execute_async和sync具体是怎么实现的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute_async</span><span class="params">(self, key, command, queue=None, executor_config=None)</span>:</span></span><br><span class="line">    self.commands_to_run.append((key, command,))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, command <span class="keyword">in</span> self.commands_to_run:</span><br><span class="line">        self.log.info(<span class="string">"Executing command: %s"</span>, command)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 在这里启动了一个子进程来执行task对应的command</span></span><br><span class="line">            subprocess.check_call(command, close_fds=<span class="keyword">True</span>)</span><br><span class="line">            <span class="comment"># 阻塞等待子进程返回，然偶上报success或者failed的状态</span></span><br><span class="line">            self.change_state(key, State.SUCCESS)</span><br><span class="line">        <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">            self.change_state(key, State.FAILED)</span><br><span class="line">            self.log.error(<span class="string">"Failed to execute task %s."</span>, str(e))</span><br><span class="line"></span><br><span class="line">    self.commands_to_run = []</span><br></pre></td></tr></table></figure><p><strong>那么，task的调用到这里就结束了吗？</strong></p><p>一个<code>subprocess.check_call(command, close_fds=True)</code>就完了？task本身的状态是在哪改变的？对于HttpOperator，这个command又是如何执行的？</p><p>眉头一皱，发现事情并没有那么简单。</p><p>这里的command具体是什么呢？通过日志我们可以看到，其实是调用airflow CLI的run命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2019-07-04 15:42:25,046] &#123;base_executor.py:59&#125; INFO - Adding to queue: [&apos;airflow&apos;, &apos;run&apos;, &apos;example_json&apos;, &apos;echo_env&apos;, &apos;2019-07-04T07:42:24.824155+00:00&apos;, &apos;--local&apos;]</span><br></pre></td></tr></table></figure></p><h3 id="cli-run"><a href="#cli-run" class="headerlink" title="cli.run"></a>cli.run</h3><p>继续来看cli.run()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run()中加载了配置文件，获取dag并实例化了TaskInstance，最终调用了_run()方法</span></span><br><span class="line"><span class="meta">@cli_utils.action_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(args, dag=None)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    task = dag.get_task(task_id=args.task_id)</span><br><span class="line">    ti = TaskInstance(task, args.execution_date)</span><br><span class="line">    ti.refresh_from_db()</span><br><span class="line"></span><br><span class="line">    ti.init_run_context(raw=args.raw)</span><br><span class="line"></span><br><span class="line">    hostname = get_hostname()</span><br><span class="line">    log.info(<span class="string">"Running %s on host %s"</span>, ti, hostname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.interactive:</span><br><span class="line">        _run(args, dag, ti)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> redirect_stdout(ti.log, logging.INFO), redirect_stderr(ti.log, logging.WARN):</span><br><span class="line">            _run(args, dag, ti)</span><br><span class="line">    logging.shutdown()</span><br><span class="line"></span><br><span class="line"><span class="comment"># _run()方法中会根据参数来选择合适的，根据之前的参数'--local'，我们会进入到LocalTaskJob中去</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run</span><span class="params">(args, dag, ti)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args.local:</span><br><span class="line">        run_job = jobs.LocalTaskJob(</span><br><span class="line">            task_instance=ti,</span><br><span class="line">            mark_success=args.mark_success,</span><br><span class="line">            pickle_id=args.pickle,</span><br><span class="line">            ignore_all_deps=args.ignore_all_dependencies,</span><br><span class="line">            ignore_depends_on_past=args.ignore_depends_on_past,</span><br><span class="line">            ignore_task_deps=args.ignore_dependencies,</span><br><span class="line">            ignore_ti_state=args.force,</span><br><span class="line">            pool=args.pool)</span><br><span class="line">        run_job.run()</span><br><span class="line">    <span class="keyword">elif</span> args.raw:</span><br><span class="line">        ti._run_raw_task(</span><br><span class="line">            mark_success=args.mark_success,</span><br><span class="line">            job_id=args.job_id,</span><br><span class="line">            pool=args.pool,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pickle_id = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> args.ship_dag:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>接下来是<code>base_job.py</code>，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        Stats.incr(self.__class__.__name__.lower() + <span class="string">'_start'</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># Adding an entry in the DB</span></span><br><span class="line">        <span class="keyword">with</span> create_session() <span class="keyword">as</span> session:</span><br><span class="line">            self.state = State.RUNNING</span><br><span class="line">            session.add(self)</span><br><span class="line">            session.commit()</span><br><span class="line">            id_ = self.id</span><br><span class="line">            make_transient(self)</span><br><span class="line">            self.id = id_</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._execute()</span><br><span class="line">                <span class="comment"># In case of max runs or max duration</span></span><br><span class="line">                self.state = State.SUCCESS</span><br><span class="line">            <span class="keyword">except</span> SystemExit:</span><br><span class="line">                <span class="comment"># In case of ^C or SIGTERM</span></span><br><span class="line">                self.state = State.SUCCESS</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                self.state = State.FAILED</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.end_date = timezone.utcnow()</span><br><span class="line">                session.merge(self)</span><br><span class="line">                session.commit()</span><br><span class="line"></span><br><span class="line">        Stats.incr(self.__class__.__name__.lower() + <span class="string">'_end'</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"This method needs to be overridden"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LocalTaskJob中有具体的实现，可以看到是调用了一个TaskRunner</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.task_runner = get_task_runner(self)</span><br><span class="line">        <span class="comment"># 省略...</span></span><br><span class="line">        self.task_runner.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来跳转到StandardTaskRunner</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardTaskRunner</span><span class="params">(BaseTaskRunner)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Runs the raw Airflow task by invoking through the Bash shell.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.process = self.run_command()</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后是run_command的具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(self, run_with=None, join_args=False)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Run the task command.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param run_with: list of tokens to run the task command with e.g. ``['bash', '-c']``</span></span><br><span class="line"><span class="string">        :type run_with: list</span></span><br><span class="line"><span class="string">        :param join_args: whether to concatenate the list of command tokens e.g. ``['airflow', 'run']`` vs</span></span><br><span class="line"><span class="string">            ``['airflow run']``</span></span><br><span class="line"><span class="string">        :param join_args: bool</span></span><br><span class="line"><span class="string">        :return: the process that was run</span></span><br><span class="line"><span class="string">        :rtype: subprocess.Popen</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        run_with = run_with <span class="keyword">or</span> []</span><br><span class="line">        cmd = [<span class="string">" "</span>.join(self._command)] <span class="keyword">if</span> join_args <span class="keyword">else</span> self._command</span><br><span class="line">        full_cmd = run_with + cmd</span><br><span class="line"></span><br><span class="line">        self.log.info(<span class="string">'Running: %s'</span>, full_cmd)</span><br><span class="line">        proc = subprocess.Popen(</span><br><span class="line">            full_cmd,</span><br><span class="line">            stdout=subprocess.PIPE,</span><br><span class="line">            stderr=subprocess.STDOUT,</span><br><span class="line">            universal_newlines=<span class="keyword">True</span>,</span><br><span class="line">            close_fds=<span class="keyword">True</span>,</span><br><span class="line">            env=os.environ.copy(),</span><br><span class="line">            preexec_fn=os.setsid</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Start daemon thread to read subprocess logging output</span></span><br><span class="line">        log_reader = threading.Thread(</span><br><span class="line">            target=self._read_task_logs,</span><br><span class="line">            args=(proc.stdout,),</span><br><span class="line">        )</span><br><span class="line">        log_reader.daemon = <span class="keyword">True</span></span><br><span class="line">        log_reader.start()</span><br><span class="line">        <span class="keyword">return</span> proc</span><br></pre></td></tr></table></figure></p><p>代码看到这里发现又是subprocess.Popen(cmd)，那么这个时候的cmd内容是什么呢？可以从日志中看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2019-07-04 13:15:38,406] &#123;base_task_runner.py:133&#125; INFO - Running: [&apos;airflow&apos;, &apos;run&apos;, &apos;example_json&apos;, &apos;echo_env&apos;, &apos;2019-07-04T05:15:36.239140+00:00&apos;, &apos;--job_id&apos;, &apos;120&apos;, &apos;--raw&apos;, &apos;--cfg_path&apos;, &apos;/tmp/tmpg2123epz&apos;]</span><br></pre></td></tr></table></figure></p><p>会发现又是airflow run，但是这个时候的cmd参数更多了，而且有一个<code>--raw</code>的参数。</p><h3 id="TaskInstance-run-raw-task"><a href="#TaskInstance-run-raw-task" class="headerlink" title="TaskInstance._run_raw_task"></a>TaskInstance._run_raw_task</h3><p>回到<code>_run(...)</code>，这个时候再执行命令会去另一个分支。于是会执行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cli.py</span></span><br><span class="line">    <span class="keyword">elif</span> args.raw:</span><br><span class="line">        ti._run_raw_task(</span><br><span class="line">            mark_success=args.mark_success,</span><br><span class="line">            job_id=args.job_id,</span><br><span class="line">            pool=args.pool,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># taskinstance.py</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_raw_task</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            self,</span></span></span><br><span class="line"><span class="function"><span class="params">            mark_success=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            test_mode=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            job_id=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            pool=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            session=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Immediately runs the task (without checking or changing db state</span></span><br><span class="line"><span class="string">        before execution) and then sets the appropriate final state after</span></span><br><span class="line"><span class="string">        completion and runs any post-execute callbacks. Meant to be called</span></span><br><span class="line"><span class="string">        only after another function changes the state to running.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里的task_copy类型就是Operator，也就是我们再定义DAG的时候选择的具体操作，通过调用Operator.execute(...)真正执行了我们想要运行的操作</span></span><br><span class="line">                task_copy.pre_execute(context=context)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">                    result = task_copy.execute(context=context)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">                task_copy.post_execute(context=context, result=result)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">            self.refresh_from_db(lock_for_update=<span class="keyword">True</span>)</span><br><span class="line">            self.state = State.SUCCESS</span><br><span class="line">        <span class="keyword">except</span> AirflowSkipException:</span><br><span class="line">            self.refresh_from_db(lock_for_update=<span class="keyword">True</span>)</span><br><span class="line">            self.state = State.SKIPPED</span><br><span class="line">        <span class="keyword">except</span> AirflowRescheduleException <span class="keyword">as</span> reschedule_exception:</span><br><span class="line">            self.refresh_from_db()</span><br><span class="line">            <span class="comment"># 在_handle_reschedule(...)中会将需要reschedule的任务加入到task_reschedule表中，状态为up_for_reschedule，等待被再次调度</span></span><br><span class="line">            self._handle_reschedule(actual_start_date, reschedule_exception, test_mode, context)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> AirflowException <span class="keyword">as</span> e:</span><br><span class="line">            self.refresh_from_db()</span><br><span class="line">            <span class="comment"># for case when task is marked as success/failed externally</span></span><br><span class="line">            <span class="comment"># current behavior doesn't hit the success callback</span></span><br><span class="line">            <span class="keyword">if</span> self.state <span class="keyword">in</span> &#123;State.SUCCESS, State.FAILED&#125;:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 在handle_failure(...)中，会根据重试次数等信息将task状态设为up_for_retry或者failed</span></span><br><span class="line">                self.handle_failure(e, test_mode, context)</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">except</span> (Exception, KeyboardInterrupt) <span class="keyword">as</span> e:</span><br><span class="line">            self.handle_failure(e, test_mode, context)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Success callback</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> task.on_success_callback:</span><br><span class="line">                task.on_success_callback(context)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e3:</span><br><span class="line">            self.log.error(<span class="string">"Failed when executing success callback"</span>)</span><br><span class="line">            self.log.exception(e3)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recording SUCCESS</span></span><br><span class="line">        self.end_date = timezone.utcnow()</span><br><span class="line">        self.set_duration()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> test_mode:</span><br><span class="line">            session.add(Log(self.state, self))</span><br><span class="line">            session.merge(self)</span><br><span class="line">        session.commit()</span><br></pre></td></tr></table></figure></p><p>到这里，从scheduler将某个task分发给executor开始，一直到task被真正地执行的流程就完成了。</p><p>这里只分析了SequentialExecutor，对于CeleryExecutor，只是通过CeleryExecutor将cmd分发到远程worker上面执行了，接下来的流程是一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Executor简介&quot;&gt;&lt;a href=&quot;#Executor简介&quot; class=&quot;headerlink&quot; title=&quot;Executor简介&quot;&gt;&lt;/a&gt;Executor简介&lt;/h2&gt;&lt;p&gt;Executor是在scheduler和worker之间的一个组件，主要作用
      
    
    </summary>
    
    
      <category term="Airflow" scheme="http://chace.in/tags/Airflow/"/>
    
      <category term="任务编排调度" scheme="http://chace.in/tags/%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Airflow源码分析(0)-介绍</title>
    <link href="http://chace.in/2019/09/01/Airflow%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(0)-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://chace.in/2019/09/01/Airflow源码分析(0)-介绍/</id>
    <published>2019-09-01T04:06:46.000Z</published>
    <updated>2019-09-01T04:23:28.388Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://airflow.apache.org/index.html" target="_blank" rel="noopener">Airflow</a>是一套分布式的任务编排和调度系统，核心概念是DAG，通过DAG编排任务，并通过scheduler调度任务到不同的worker上执行。</p><p>Airflow基于Python开发，所以在开发Airflow前要有Python基础。</p><p>开发环境的搭建可以参考：<a href="https://github.com/apache/airflow/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">Contributing</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://airflow.apache.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Airflow&lt;/a&gt;是一套分布式的任务编排和调度系统，核心概念是DAG，通过DAG编排任务，并通过schedule
      
    
    </summary>
    
    
      <category term="Airflow" scheme="http://chace.in/tags/Airflow/"/>
    
      <category term="任务编排调度" scheme="http://chace.in/tags/%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>高可用配置中心etcd</title>
    <link href="http://chace.in/2019/09/01/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83etcd/"/>
    <id>http://chace.in/2019/09/01/高可用配置中心etcd/</id>
    <published>2019-09-01T04:06:07.000Z</published>
    <updated>2019-09-02T02:32:54.281Z</updated>
    
    <content type="html"><![CDATA[<p>占坑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;占坑&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="分布式系统" scheme="http://chace.in/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Docker" scheme="http://chace.in/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker中的namespace和cgroup</title>
    <link href="http://chace.in/2019/09/01/Docker%E4%B8%AD%E7%9A%84namespace%E5%92%8Ccgroup/"/>
    <id>http://chace.in/2019/09/01/Docker中的namespace和cgroup/</id>
    <published>2019-09-01T02:24:07.000Z</published>
    <updated>2019-09-01T03:59:10.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-namespace资源隔离"><a href="#1-namespace资源隔离" class="headerlink" title="1. namespace资源隔离"></a>1. namespace资源隔离</h2><p>Linux提供6种namespace隔离。</p><table><thead><tr><th>namespace</th><th>flag</th><th>备注</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名和域名</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>进程间通信</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>进程PID</td></tr><tr><td>MOUNT</td><td>CLONE_NEWNS</td><td>文件系统挂载点(mount)</td></tr><tr><td>NET</td><td>CLONE_NEWNET</td><td>网络</td></tr><tr><td>USER</td><td>CLONE_NEWUSER</td><td>用户权限</td></tr></tbody></table><p>tips: 文件系统挂载点之所以是NS，是因为这是第一个namespace，当时没有想到会有其他namespace，所以直接用的NS。</p><h3 id="namespace提供的系统调用"><a href="#namespace提供的系统调用" class="headerlink" title="namespace提供的系统调用"></a>namespace提供的系统调用</h3><h4 id="clone-在新namespace中创建进程"><a href="#clone-在新namespace中创建进程" class="headerlink" title="clone: 在新namespace中创建进程"></a>clone: 在新namespace中创建进程</h4><p>传入哪些flag中就可以达到隔离哪些资源的目的，以<code>|</code>分隔，比如<code>CLONE_NEWUTS|CLONE_NEWIPC</code>就隔离了主机名和进程间通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure><h4 id="setns-加入一个已经存在的namespace"><a href="#setns-加入一个已经存在的namespace" class="headerlink" title="setns: 加入一个已经存在的namespace"></a>setns: 加入一个已经存在的namespace</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setns(int fd, int nstype);</span><br></pre></td></tr></table></figure><h4 id="unshare-将当前进程加入到新的namespace中"><a href="#unshare-将当前进程加入到新的namespace中" class="headerlink" title="unshare: 将当前进程加入到新的namespace中"></a>unshare: 将当前进程加入到新的namespace中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int unshare(int flags);</span><br></pre></td></tr></table></figure><h4 id="一些-proc下的文件"><a href="#一些-proc下的文件" class="headerlink" title="一些/proc下的文件"></a>一些/proc下的文件</h4><p>可以修改/proc下的部分文件达到namespace隔离的效果，比如修改user namespace中的/proc/$$/uid_map和/proc/$$/proc/gid_map可以完成用户绑定的操作。</p><h3 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h3><p>隔离主机名和域名。在clone中传入CLONE_NEWUTS，然后在子进程中修改hostname不会影响到父进程。</p><h3 id="IPC-namespace"><a href="#IPC-namespace" class="headerlink" title="IPC namespace"></a>IPC namespace</h3><p>隔离进程间通信的文件，比如信号量、消息队列、PIPE等。</p><h3 id="PID-namespace"><a href="#PID-namespace" class="headerlink" title="PID namespace"></a>PID namespace</h3><p>隔离进程。在新的namespace下不会看到其他namespace下的进程。</p><p>在新的namespace下启动的第一个进程相当于Linux下的init进程，同时要承担init进程收养孤儿，传递SIGNAL的责任，比较重要。</p><p>这时候直接用<code>ps</code>看到的还是原来namespace的进程，需要重新挂载<code>proc</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount -t &lt;文件系统类型&gt; &lt;设备名&gt; &lt;挂载点&gt;</span><br><span class="line">mount -t proc proc /proc</span><br></pre></td></tr></table></figure><p>但是这时候父子进程的文件系统并没有隔离，所以挂载到子进程后父进程也会受影响，所以在退出子进程后。需要在父进程中重新挂载<code>proc</code></p><h3 id="Mount-namespace"><a href="#Mount-namespace" class="headerlink" title="Mount namespace"></a>Mount namespace</h3><p>隔离文件系统挂载点。子进程会复制父进程的所有挂载点，但是之后彼此是独立的。</p><p>需要注意的是Linux有<strong>挂载传播</strong>的特性，也就是说挂载的时候可以将文件系统指定为<strong>shared/slave/private/unbindable</strong>等属性，从而可以控制不同namespace下文件系统的共享状态。</p><p>因此如果挂载点是shared的状态，上述的namespace隔离不会生效。需要通过<code>mount --make-private -t &lt;文件系统类型&gt; &lt;设备名&gt; &lt;挂载点&gt;</code>修改为private。</p><h3 id="Net-namespace"><a href="#Net-namespace" class="headerlink" title="Net namespace"></a>Net namespace</h3><p>隔离网络设备，在子进程中将看不到父进程中的网络设备。</p><p>为了不同namespace可以通过网络互相访问，通常的做法是创建一个veth pair，一端在容器内部，另一端接在网桥上(docker中是docker 0网桥)。通过合理分配IP，不同namespace下的veth通过网桥互相访问。</p><p>还有个细节是，在容器内的veth创建之前，外部是如何与namespace通信的？答案是PIPE。docker daemon先在宿主机上创建一个veth，然后通过PIPE通知容器内部创建veth，容器内部在veth创建之前会循环等待PIPE，完成两个veth的绑定后，移除PIPE。</p><p>到这里，可以实验一下各种namespace的隔离效果。</p><p>net.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"在子进程中!\n"</span>);</span><br><span class="line">    sethostname(<span class="string">"NewNS"</span>, <span class="number">12</span>);</span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"程序开始: \n"</span>);</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"已退出\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="User-namespace"><a href="#User-namespace" class="headerlink" title="User namespace"></a>User namespace</h3><p>隔离用户和权限。不同namespace下的用户相互看不到，权限也不通。</p><p>需要注意的是，新的namespace下的用户需要绑定外部namespace下的用户才能正常显示，通过修改/proc/$$/uid_map和/proc/$$/proc/gid_map完成绑定。</p><h2 id="2-cgroups资源限制"><a href="#2-cgroups资源限制" class="headerlink" title="2. cgroups资源限制"></a>2. cgroups资源限制</h2><p>官方定义：</p><pre><code>cgroups是Linux内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合（或分隔）到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。</code></pre><p>作用：资源限制，资源统计，任务控制，优先级分配</p><p>基本概念：</p><ul><li>task: 进程或者线程</li><li>cgroup: 按某种资源控制标准划分成的任务组</li><li>subsystem: 控制某一种资源，比如CPU子系统，内存子系统</li><li>hierachy(层级): 层级由一系列cgroup排列而成，每个层级通过绑定子系统进行资源控制</li></ul><h3 id="cgroups的实现"><a href="#cgroups的实现" class="headerlink" title="cgroups的实现"></a>cgroups的实现</h3><p>Linux中cgroup的实现形式表现为一个文件系统，所以可以通过操作文件的方式调用cgroup。</p><p>docker实现：</p><pre><code>在docker的实现中，docker daemon会在单独挂载了每一个子系统的cgroup目录(比如/sys/fs/cgroup/cpu)下创建一个名为docker的控制组，然后在docker控制组里面，再为每个容器创建一个以容器ID为名称的容器控制组，这个容器里所有进程都会写到该控制组tasks中，并且会在控制文件(比如cpu.cfs_quota_us)中写入预设的限制参数值。</code></pre><p>cgroups的实现本质上是个任务挂上钩子，当任务运行的过程中涉及某种资源时，就会触发钩子上所附带的子系统进程检测，根据资源类别的不同，使用对应的技术进行资源限制和优先级分配。</p><hr><p>参考资料</p><ol><li><a href="https://linux.cn/article-5057-5.html" target="_blank" rel="noopener">Docker背后的内核知识：命名空间资源隔离</a></li><li><a href="https://book.douban.com/subject/26894736/" target="_blank" rel="noopener">Docker容器与容器云</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-namespace资源隔离&quot;&gt;&lt;a href=&quot;#1-namespace资源隔离&quot; class=&quot;headerlink&quot; title=&quot;1. namespace资源隔离&quot;&gt;&lt;/a&gt;1. namespace资源隔离&lt;/h2&gt;&lt;p&gt;Linux提供6种namespa
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://chace.in/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>CS6.824(3)-Raft</title>
    <link href="http://chace.in/2019/08/31/CS6.824(3)-Raft/"/>
    <id>http://chace.in/2019/08/31/CS6.824(3)-Raft/</id>
    <published>2019-08-31T12:41:50.000Z</published>
    <updated>2019-09-01T04:22:17.865Z</updated>
    
    <content type="html"><![CDATA[<p>Raft作为两大分布式一致性协议之一（另一个就是大名鼎鼎的Paxos），本身是为了解决Paxos学习成本过高，工程实现过于困难的问题。在论文中也是遵循这个原则，因此阅读下来还是比较轻松的，而且也有丰富的图表可以帮助思考。</p><p>不过在实现上还是会有很多坑，再次感受到了分布式编程的困难之处，尤其是调试，也再次印证了printf是最好的调试工具~（事实上只能看日志来调试）</p><p>下面简单过一下Raft比较有意思的点。</p><h2 id="选举安全"><a href="#选举安全" class="headerlink" title="选举安全"></a>选举安全</h2><p>在同一term最多选举出一个leader。</p><p>首先所有节点都是follower，term=0，term相当于一个阶段。</p><p>follower等待一个随机的超时时间，超时以后该节点成为candidate，term+1，向其余节点发起投票请求。</p><p>其余节点发现投票请求中的term&gt;=currentTerm，并且在currentTerm没有投过票，并且投票请求的日志记录至少与自己的日志记录一样新，就授权这次投票请求。</p><p>当某个candidate获得majority的授权以后，成为leader，并且向其余follower发送心跳。</p><p>如果某个term没有leader产生，那么在选举超时以后，会再发起选举。</p><h2 id="Leader的日志完整性"><a href="#Leader的日志完整性" class="headerlink" title="Leader的日志完整性"></a>Leader的日志完整性</h2><p>只要在某个term一条日志被commit，那么这条日志将会出现在所有更高term的leader中。</p><p>假设存在一个比term T大且最小的term U，term U的leader不包含term T已经commit的日志。</p><p>因为要成为leader，必须获得majority follower的投票；同样地，一个日志要被commit，也必须被majority follower接收。所以至少存在一个follower，既接收了term T的leader的日志，也投票给了term U的leader。</p><p>如果term U的leader不包含之前commit的日志，那么这个follower是不会投票给他的。因此会矛盾。</p><p>论文里面是用反证法证明的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Raft作为两大分布式一致性协议之一（另一个就是大名鼎鼎的Paxos），本身是为了解决Paxos学习成本过高，工程实现过于困难的问题。在论文中也是遵循这个原则，因此阅读下来还是比较轻松的，而且也有丰富的图表可以帮助思考。&lt;/p&gt;
&lt;p&gt;不过在实现上还是会有很多坑，再次感受到
      
    
    </summary>
    
    
      <category term="分布式系统" scheme="http://chace.in/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CS6.824(2)-GFS</title>
    <link href="http://chace.in/2019/08/31/CS6.824(2)-GFS/"/>
    <id>http://chace.in/2019/08/31/CS6.824(2)-GFS/</id>
    <published>2019-08-31T12:37:48.000Z</published>
    <updated>2019-08-31T12:53:16.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GFS的架构"><a href="#GFS的架构" class="headerlink" title="GFS的架构"></a>GFS的架构</h2><p>GFS模型的master，chunkserver。master保存文件的元数据，比如file目录结构，文件大小，文件包含的chunk以及chunk在什么位置。chunkserver上保存的是具体的文件数据。</p><h2 id="GFS读文件过程"><a href="#GFS读文件过程" class="headerlink" title="GFS读文件过程"></a>GFS读文件过程</h2><p>client访问master，获取到文件的chunk所在的chunkserver，然后client直接去这些chunkserver上请求数据。控制流跟数据流是解耦的。</p><h2 id="GFS写文件过程"><a href="#GFS写文件过程" class="headerlink" title="GFS写文件过程"></a>GFS写文件过程</h2><ol><li>client访问master，获取到应该写入chunk所在的chunkserver。（超出一个chunk的话，会把写请求分成多次）</li><li>Master会给chunk授权一个租约，增加chunk的版本号，然后让chunkserver也同样地增加版本号。并且会在chunkserver中给本次写请求指定一个primary节点，由他来负责协调本次的写入。然后回应client，后面client跟master不需要再通信了，这样可以减少master的负载。</li><li>client把数据push到master告诉它的chunkserver上。</li><li>一旦数据push完毕，client发送写请求给primary。primary决定本次写入的顺序并且应用到chunk上。</li><li>primary主节点完成修改后，将这个顺序传递给从节点secondaries，因此他们也能应用同样的修改顺序。</li><li>从节点完成修改后，回应主节点。</li><li>主节点之后回应client成功或者失败状态：<ul><li>主节点和从节点都成功，则本次写入成功；</li><li>如果有失败，那么client会重试写入</li></ul></li></ol><h2 id="GFS的一致性模型"><a href="#GFS的一致性模型" class="headerlink" title="GFS的一致性模型"></a>GFS的一致性模型</h2><p>主要针对并发写文件的过程。在GFS里，有两种写文件的方式，一种是随机写，一种是append追加数据。这里面的一致性有两个维度，确定与一致。一致是指多个副本的内容相同，确定就是与串行写入时的内容相同。</p><p>append会有一个填充的操作，就是发现原来的chunk+新的数据可能超出一个chunk的大小，就先把chunk填满，再通知client在下一块chunk进行append。这里一次append的数据限制为chunk的1/4大小，这样就不会填充太多的无效数据。这样做的原因是前面GFS的写入操作是针对一个chunk的，就是为了避免一次写两块chunk，这样一致性会被破坏掉。</p><p>随机写是一致的但是不确定的，append填充的部分是不一致的，但是其他正常的数据是确定的。</p><p>并发写同一个区域，可能会出现覆盖的情况，导致undefined，但是几个副本的内容是一致的。<br>Record append填充的部分是不一致的（因此也就不一致），但是其他正常的数据是确定的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GFS的架构&quot;&gt;&lt;a href=&quot;#GFS的架构&quot; class=&quot;headerlink&quot; title=&quot;GFS的架构&quot;&gt;&lt;/a&gt;GFS的架构&lt;/h2&gt;&lt;p&gt;GFS模型的master，chunkserver。master保存文件的元数据，比如file目录结构，文件大
      
    
    </summary>
    
    
      <category term="分布式系统" scheme="http://chace.in/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>快速熟悉开源项目</title>
    <link href="http://chace.in/2019/08/30/%E5%BF%AB%E9%80%9F%E7%86%9F%E6%82%89%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE(%E8%BD%AC%E8%BD%BD)/"/>
    <id>http://chace.in/2019/08/30/快速熟悉开源项目(转载)/</id>
    <published>2019-08-30T07:30:58.000Z</published>
    <updated>2019-08-30T07:37:34.595Z</updated>
    
    <content type="html"><![CDATA[<p>《Docker-容器与容器云》中的一篇文章，觉得挺不错，所以从网上转载了一份过来。原文：<a href="https://my.oschina.net/baijuminglu/blog/834911" target="_blank" rel="noopener">快速熟悉开源项目</a></p><h2 id="查阅文档"><a href="#查阅文档" class="headerlink" title="查阅文档"></a>查阅文档</h2><p>查阅文档包括查阅文档与博客，最好是带着问题去阅读。</p><h3 id="1-查阅文档与博客"><a href="#1-查阅文档与博客" class="headerlink" title="1.查阅文档与博客"></a>1.查阅文档与博客</h3><p>一个好的开源项目未必会火，但是一个火的开源项目一定有其可取之处，而从众心理又会让更多人去研究它。所以，要熟悉你想研究的开源项目，第一步就是在搜索引擎中查找该项目的博客和资料。通过快速阅读介绍开源项目架构，使用方法等这类文章，你就能大体了解该项目的意义，功能和基本使用方法。</p><p>通过搜索到的资料，如果你觉得该项目就是你想要的，那么便可以很耐心的阅读项目提供的官方文档，从中学习一些具体的下载，安装和使用方法，以便了解项目全貌。</p><h3 id="2-带着问题去阅读"><a href="#2-带着问题去阅读" class="headerlink" title="2.带着问题去阅读"></a>2.带着问题去阅读</h3><p>阅读文档过程中不能盲目，需要带着如下问题去阅读。</p><ul><li>这个项目解决了什麽问题？</li><li>这个项目涉及了哪些成熟的技术？</li><li>这个项目是否符合我的要求（用户规模，使用场景，性能，安全性等）？</li><li>当阅读完文档后，能否尝试画出大致的架构图？</li></ul><h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h2><p>实践是最好的老师，在阅读文档过程中，按照文档的操作指南亲手实践，不但有助于加深理解，同时还会注意到很多细节，可以更清楚的感受到项目是否符合自己的需求。</p><h3 id="1-搭建项目"><a href="#1-搭建项目" class="headerlink" title="1.搭建项目"></a>1.搭建项目</h3><p>实践过程一般都遵循项目的README文件，进行部署安装和尝试。如果有现成使用项目的事例代码，那么也可以按照示例代码进行尝试。此时若是运行顺利，则可以尝试着根据自己的理解对事例代码进行修改。若是出现问题也无需慌张，只需要将问题的异常信息当作关键词在搜索引擎中查找即可。如果实在找不到解决方案，那么就可以提交到开源项目的邮件列表中，开源社区的人们一般都比较热心，相信很快就可以解决问题。</p><p>基本尝试过后，我们可以使用项目的一些高级功能，如一些高级配置项，较为复杂的API等。相信一个运作良好的开源项目，为了方便社区的贡献者们可以快速加入，必然会提供一份较为详尽的指南，你只需挑选你感兴趣的部分阅读即可。</p><p>基本尝试过后，我们可以使用项目的一些高级功能，如一些高级配置项，较为复杂的API等。相信一个运作良好的开源项目，为了方便社区的贡献者们可以快速加入，必然会提供一份较为详尽的指南，你只需挑选你感兴趣的部分阅读即可。</p><p>下面推荐几个解决疑惑的好网站</p><ul><li>Google搜索引擎: google.com</li><li>Stackoverflow: stackoverflow.com</li><li>项目相关的Google讨论组: groups.google.com</li><li>对GitHub的项目提Issues: github.com</li></ul><h3 id="2-深层次改动"><a href="#2-深层次改动" class="headerlink" title="2.深层次改动"></a>2.深层次改动</h3><p>有趣的是，很多开源项目一般都会为了方便用户使用，提供release的版本。如果基本的部署和使用已经成功的话，强烈建议你从源码构建和部署该项目。这样你就能从开发，调试到发布整个一体化的全部过程，由此全方位的感受项目的优缺点。</p><p>基本尝试过后，我们可以使用项目的一些高级功能，如一些高级配置项，较为复杂的API等。相信一个运作良好的开源项目，为了方便社区的贡献者们可以快速加入，必然会提供一份较为详尽的指南，你只需挑选你感兴趣的部分阅读即可。</p><h2 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h2><p>经过以上两步之后，你必然对项目的大致情况了然于胸，想更深入的了解自然非阅读源码莫属了。</p><p>一般阅读源码有两种习惯方式，一是根据命令行的代码调用过程阅读；二是根据架构分模块阅读。</p><h3 id="1-跟着运行过程阅读"><a href="#1-跟着运行过程阅读" class="headerlink" title="1.跟着运行过程阅读"></a>1.跟着运行过程阅读</h3><p>刚上手的过程可以使用的一种方式。通过实践过程中对对某个命令或参数的理解，从主干开始，一步一步理清这个命令在运行过程中代码调用的路径。通过debug工具观察变量和函数，修改源码打印日志，可以更好的帮你理解源码。</p><p>当理清这个过程后可以将这个过程用流程图的形式记录下来，从而加深印象，方便下次阅读的时候快速会议和对比。</p><h3 id="2-分模块阅读"><a href="#2-分模块阅读" class="headerlink" title="2.分模块阅读"></a>2.分模块阅读</h3><p>在理清了程序运行的基本流程后，可以根据架构上各个模块的作用，挑选你有兴趣的部分阅读，如网络，存储，通信，用户接口，界面等，选择一个模块深入到实现细节中。</p><p>此时也可以带着如下几个问题帮助自己理解。</p><ul><li>调用了什麽底层库？</li><li>采用了什麽设计模式？</li><li>这麽写有什麽好处？</li></ul><p>如果在阅读源码的过程中出现瓶颈，你一时无法理解代码的用意，不妨去阅读一下相关的单元测试。一个好的单元测试通常都描述了要测试代码的主要功能和数据边界，通过运行和理解单元测试，可以有效的帮助理解源码。</p><p>相信经过以上三步，你必然已经对这个开源项目非常熟悉了。此时如果你感兴趣，也可以加入其中为开源社区做出一定贡献。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《Docker-容器与容器云》中的一篇文章，觉得挺不错，所以从网上转载了一份过来。原文：&lt;a href=&quot;https://my.oschina.net/baijuminglu/blog/834911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;快速熟悉开
      
    
    </summary>
    
    
      <category term="经验之谈" scheme="http://chace.in/tags/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Go tour(3)-Concurrency</title>
    <link href="http://chace.in/2019/06/11/Go-tour-3-Concurrency/"/>
    <id>http://chace.in/2019/06/11/Go-tour-3-Concurrency/</id>
    <published>2019-06-11T03:05:58.000Z</published>
    <updated>2019-06-11T03:08:24.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul><li>gorotine 协程</li><li>channel 信道</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> TYPE, BUFFER_SIZE) <span class="comment">// 创建一个信道</span></span><br><span class="line"><span class="keyword">go</span> FUNC(ch) <span class="comment">// 用协程执行FUNC，并传递一个信道</span></span><br><span class="line"><span class="keyword">for</span> y := <span class="keyword">range</span> ch <span class="comment">// 用range循环等待</span></span><br></pre></td></tr></table></figure><h3 id="练习：比较二叉树是否存储相同的值"><a href="#练习：比较二叉树是否存储相同的值" class="headerlink" title="练习：比较二叉树是否存储相同的值"></a>练习：比较二叉树是否存储相同的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"golang.org/x/tour/tree"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Walk walks the tree t sending all values</span></span><br><span class="line"><span class="comment">// from the tree to the channel ch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(t *tree.Tree, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ch &lt;- t.Value</span><br><span class="line">Walk(t.Left, ch)</span><br><span class="line">Walk(t.Right, ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same determines whether the trees</span></span><br><span class="line"><span class="comment">// t1 and t2 contain the same values.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Same</span><span class="params">(t1, t2 *tree.Tree)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> Walk(t1, ch1)</span><br><span class="line"><span class="keyword">go</span> Walk(t2, ch2)</span><br><span class="line">values1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">values2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 阻塞在select</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v1 := &lt;- ch1:</span><br><span class="line">values1 = <span class="built_in">append</span>(values1, v1)</span><br><span class="line"><span class="keyword">case</span> v2 := &lt;- ch2:</span><br><span class="line">values2 = <span class="built_in">append</span>(values2, v2)</span><br><span class="line"><span class="comment">//在其余case没有准备好的时候，default会执行。不会阻塞</span></span><br><span class="line"><span class="comment">//default:</span></span><br><span class="line"><span class="comment">//fmt.Println("default")</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"values1: %v\n"</span>, values1)</span><br><span class="line">fmt.Printf(<span class="string">"values2: %v\n"</span>, values2)</span><br><span class="line"></span><br><span class="line">same := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> v1:=<span class="keyword">range</span> values1 &#123;</span><br><span class="line">same = <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> v2:=<span class="keyword">range</span> values2 &#123;</span><br><span class="line"><span class="keyword">if</span> v1 == v2 &#123;</span><br><span class="line">same = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !same &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> same</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> Walk(tree.New(<span class="number">1</span>), ch)</span><br><span class="line"></span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">tmp[i] = v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"tmp: %v\n"</span>, tmp)</span><br><span class="line">fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">isSame := Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">2</span>))</span><br><span class="line">fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line">fmt.Println(isSame)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>基于channel的同步<br>By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span> <span class="comment">// 会出现死锁</span></span><br></pre></td></tr></table></figure></li><li><p>基于sync.Mutex的同步</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mux sync.Mutex</span><br><span class="line">mux.Lock()</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">mux.Unlock()</span><br></pre></td></tr></table></figure></li><li><p>基于sync.WaitGroup同步<br>主线程等待所有协程返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 在执行协程之前调用Add</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure></li></ol><p>在执行协程之前调用Add。文档说明：Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. </p><h2 id="练习：并发爬虫"><a href="#练习：并发爬虫" class="headerlink" title="练习：并发爬虫"></a>练习：并发爬虫</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Fetch returns the body of URL and</span></span><br><span class="line"><span class="comment">// a slice of URLs found on that page.</span></span><br><span class="line">Fetch(url <span class="keyword">string</span>) (body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crawl uses fetcher to recursively crawl</span></span><br><span class="line"><span class="comment">// pages starting with url, to a maximum of depth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line"><span class="comment">// 用waitgroup实现主线程等待</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Fetch URLs in parallel.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Don't fetch the same URL twice.</span></span><br><span class="line"><span class="comment">// 判断是否已访问</span></span><br><span class="line"><span class="keyword">if</span> safemap.IsVisited(url) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This implementation doesn't do either:</span></span><br><span class="line"><span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">body, urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记为已访问</span></span><br><span class="line">safemap.Visit(url)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"found: %s %q\n"</span>, url, body)</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Crawl(u, depth<span class="number">-1</span>, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Crawl(<span class="string">"https://golang.org/"</span>, <span class="number">4</span>, fetcher)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问过的url</span></span><br><span class="line"><span class="keyword">type</span> SafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">visited <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现安全操作map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m SafeMap)</span> <span class="title">IsVisited</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">m.mux.Lock()</span><br><span class="line">_, ok := m.visited[url]</span><br><span class="line"><span class="keyword">defer</span> m.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现安全操作map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m SafeMap)</span> <span class="title">Visit</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">m.mux.Lock()</span><br><span class="line">m.visited[url] = <span class="literal">true</span></span><br><span class="line">m.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> safemap = SafeMap&#123;visited: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher is Fetcher that returns canned results.</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span> <span class="title">Fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher is a populated fakeFetcher.</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"The Go Programming Language"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/cmd/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Packages"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/cmd/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/fmt/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/os/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"https://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package fmt"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"https://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package os"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;gorotine 协程&lt;/li&gt;
&lt;li&gt;channel 信道&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chace.in/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go tour(2)-Methods and Interfaces</title>
    <link href="http://chace.in/2019/06/11/Go-tour-2-Methods-and-Interfaces/"/>
    <id>http://chace.in/2019/06/11/Go-tour-2-Methods-and-Interfaces/</id>
    <published>2019-06-11T03:05:45.000Z</published>
    <updated>2019-06-11T03:08:26.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go没有类，方法跟函数的区别就是多了一个接收器Receiver</p><p>指针接收器，接收到的变量是指针形式的，意味着可以修改原变量。pointer receivers比value receivers更加常见。</p><p>函数的参数为指针必须显式传入一个指针，但如果是方法，Go解释器会隐式地将对象的指针传入，不需要显式取地址。同样的情况也发生在参数为值value的情况下，方法依然会进行隐式转换。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">ScaleFunc(v, <span class="number">5</span>) <span class="comment">// error</span></span><br><span class="line">ScaleFunc(&amp;v, <span class="number">5</span>) <span class="comment">// ok</span></span><br><span class="line">v.Scale(<span class="number">5</span>) <span class="comment">// OK</span></span><br><span class="line">(&amp;v).Scale(<span class="number">5</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p><p>指针接收器优点: 1.可以改变原变量；2.避免了传值拷贝</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口也是一种type。没有类，感觉像是在type上去实现方法。可以看成(value, type)的元组。<br>接口内的值就算是nil，也可以调用它的方法，不会报空指针异常。但是如果是nil接口，就会报错。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">t.M()</span><br><span class="line"><span class="comment">// 会报错</span></span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 这样就实现了接口I</span></span><br><span class="line"><span class="keyword">var</span> i I = F(<span class="number">1.2</span>) <span class="comment">// 可以给接口赋值</span></span><br><span class="line">i.M() <span class="comment">// 调用接口实现中的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口可以接收任意类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断接口具体的类型，跟map类似</span></span><br><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure></p><p>Error处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了error接口的ErrNegativeSqrt</span></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"cannot Sqrt negative number: %v"</span>, <span class="keyword">float64</span>(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">z := <span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> last_z := z; math.Abs(last_z-z) &gt; <span class="number">0.00001</span>; last_z = z &#123;</span><br><span class="line">z -= (z*z - x) / (<span class="number">2</span>*z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, ErrNegativeSqrt(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">fmt.Println(Sqrt(<span class="number">-2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了从无限流中读取'A'的Read方法</span></span><br><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyReader)</span> <span class="title">Read</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, e error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(bytes); i++ &#123;</span><br><span class="line">bytes[i]=<span class="string">'A'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(bytes), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在io.Reader上包装，实现rot13算法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rot13Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(b <span class="keyword">byte</span>)</span> <span class="params">(bb <span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (b &gt;= <span class="number">65</span> &amp;&amp; b &lt; <span class="number">78</span>) || (b &gt;= <span class="number">97</span> &amp;&amp; b &lt; <span class="number">110</span>) &#123;</span><br><span class="line">bb = b+<span class="number">13</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="number">78</span> &amp;&amp; b &lt; <span class="number">91</span>) || (b &gt;= <span class="number">110</span> &amp;&amp; b &lt; <span class="number">123</span>) &#123;</span><br><span class="line">bb = b<span class="number">-13</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rot rot13Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">n, e := rot.r.Read(b)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">b[i] = transform(b[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, e</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := strings.NewReader(<span class="string">"Lbh penpxrq gur pbqr!"</span>)</span><br><span class="line">r := rot13Reader&#123;s&#125;</span><br><span class="line">io.Copy(os.Stdout, &amp;r)</span><br><span class="line">    <span class="comment">// output: Youcrackedthecode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现Image接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"golang.org/x/tour/pic"</span></span><br><span class="line"><span class="string">"image/color"</span></span><br><span class="line"><span class="string">"image"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义了一个Image结构体</span></span><br><span class="line"><span class="keyword">type</span> Image <span class="keyword">struct</span>&#123;</span><br><span class="line">w <span class="keyword">int</span></span><br><span class="line">h <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Image实现Image的接口</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type Image interface &#123;</span></span><br><span class="line"><span class="comment">    ColorModel() color.Model</span></span><br><span class="line"><span class="comment">    Bounds() Rectangle</span></span><br><span class="line"><span class="comment">    At(x, y int) color.Color</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span> <span class="title">ColorModel</span><span class="params">()</span> <span class="title">color</span>.<span class="title">Model</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> color.RGBAModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span> <span class="title">Bounds</span><span class="params">()</span> <span class="title">image</span>.<span class="title">Rectangle</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> image.Rect(<span class="number">0</span>, <span class="number">0</span>, img.w, img.h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span> <span class="title">At</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">color</span>.<span class="title">Color</span></span> &#123;</span><br><span class="line">v := <span class="keyword">uint8</span>(x^y)</span><br><span class="line"><span class="keyword">return</span> color.RGBA&#123;v, v, <span class="number">255</span>, <span class="number">255</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := Image&#123;w:<span class="number">200</span>, h:<span class="number">200</span>&#125;</span><br><span class="line"><span class="comment">// 使用实现了Image接口的m</span></span><br><span class="line">pic.ShowImage(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;p&gt;Go没有类，方法跟函数的区别就是多了一个接收器Receiver&lt;/p&gt;
&lt;p&gt;指针接收器，接收到的变量是指针形式的，意味着可以修改原变量。p
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chace.in/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go tour(1)-Basics</title>
    <link href="http://chace.in/2019/06/11/Go-tour-1-Basics/"/>
    <id>http://chace.in/2019/06/11/Go-tour-1-Basics/</id>
    <published>2019-06-11T03:05:17.000Z</published>
    <updated>2019-06-11T03:08:27.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// :=是在函数内部声明变量并赋值，在函数外部不能用</span></span><br><span class="line"><span class="comment">// 变量用var，常量用const，常量不能用:=</span></span><br><span class="line">k := <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> K <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">3</span></span><br><span class="line"><span class="comment">// 返回值可以命名，可以多个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有初始值的变量会被赋零值</span></span><br><span class="line"><span class="comment">/* 基本数据类型</span></span><br><span class="line"><span class="comment">bool string</span></span><br><span class="line"><span class="comment">int int8 .... int64</span></span><br><span class="line"><span class="comment">uint uint8 ...... uint64</span></span><br><span class="line"><span class="comment">byte // uint8的别名 </span></span><br><span class="line"><span class="comment">rune // int32的别名</span></span><br><span class="line"><span class="comment">float32 float64</span></span><br><span class="line"><span class="comment">complex64 complex128</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="分支循环"><a href="#分支循环" class="headerlink" title="分支循环"></a>分支循环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if后面可以跟一句初始语句，整个条件语句作用域可用</span></span><br><span class="line"><span class="keyword">if</span> a:=b<span class="number">-32</span>; a&gt;<span class="number">0</span> &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// switch也可以这样，而且不用显示break</span></span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// switch也可以没有条件表达式</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good morning!"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good evening."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有一种循环for，不用小括号，必须用花括号</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defer声明的语句会在外部函数返回才调用，这些语句会被压入到栈中</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br></pre></td></tr></table></figure><h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line">i := <span class="number">21</span></span><br><span class="line">pp = &amp;i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> Vertext <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">v := Vertex&#123;X:<span class="number">1</span>, Y:<span class="number">2</span>&#125;</span><br><span class="line">p := &amp;v</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="comment">// 切片传参是传指针</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">string</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片以后是在原数组上操作</span></span><br><span class="line"><span class="comment">// 切片的长度和容量：len是切片含有多少个元素，capacity是从切片第一个元素到数组最后一个元素含有的元素个数</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s = s[:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">len</span>(s) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">cap</span>(s) <span class="comment">// 4</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">len</span>(s) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">cap</span>(s) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// make创建动态数组</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// append进行切片追加的时候，如果元素个数大于了capacity，那么按什么方式将底层数组扩容？2,4,8?</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">range</span></span></span><br><span class="line"><span class="function">// <span class="title">v</span>是浅拷贝还是深拷贝？浅拷贝，依然可以通过<span class="title">v</span>操作原数组</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pow = [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">v[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">       <span class="comment">// 可以通过pow[i]对原数组进行操作</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, pow)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[5 2]</span></span><br><span class="line"><span class="comment">[5 4]</span></span><br><span class="line"><span class="comment">[[5 2] [5 4]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>实现built-in的append函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(slice []<span class="keyword">int</span>, data ...<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">m := <span class="built_in">len</span>(slice)</span><br><span class="line">n := m+<span class="built_in">len</span>(data)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">cap</span>(slice) &#123;</span><br><span class="line"><span class="keyword">var</span> newSlice []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">newSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">newSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>*m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(newSlice, slice)</span><br><span class="line">slice = newSlice</span><br><span class="line">&#125;</span><br><span class="line">slice = slice[<span class="number">0</span>:n]</span><br><span class="line"><span class="built_in">copy</span>(slice[m:n], data)</span><br><span class="line"><span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>slice练习<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="keyword">int</span>)</span> [][]<span class="title">uint8</span></span> &#123;</span><br><span class="line">ret := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, dy)</span><br><span class="line"><span class="keyword">for</span> y := <span class="keyword">range</span> ret &#123;</span><br><span class="line">ret[y] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> x:=<span class="number">0</span>; x &lt; dx; x++ &#123;</span><br><span class="line">ret[y][x] = <span class="keyword">uint8</span>(<span class="keyword">float64</span>(x)*math.Log(<span class="keyword">float64</span>(y)))</span><br><span class="line">            <span class="comment">// 两种方法都可以</span></span><br><span class="line"><span class="comment">// ret[y] = append(ret[y], uint8(float64(x)*math.Log(float64(y))))</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map初始化</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line"><span class="comment">// 操作</span></span><br><span class="line">a = m[key]</span><br><span class="line"><span class="built_in">delete</span>(m, key) <span class="comment">// 删除key</span></span><br><span class="line">item, ok := m[key] <span class="comment">// 判断key是否在m中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数可以是函数，也可以有匿名函数</span></span><br><span class="line"><span class="comment">// 赋值再调用</span></span><br><span class="line">fplus := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line">fplus(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 直接调用匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x + y &#125; (<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>闭包实现斐波那契数列<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 跟Python不一样的是，不会发生自由变量降级成为局部变量的现象，也不需要nolocal声明。因为go语言需要变量声明，Python不需要变量声明。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fibonacci is a function that returns</span></span><br><span class="line"><span class="comment">// a function that returns an int.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">pre2 := <span class="number">-1</span></span><br><span class="line">pre1 := <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">tmp := pre2</span><br><span class="line">pre2 = pre1</span><br><span class="line">pre1 = tmp + pre1</span><br><span class="line"><span class="keyword">return</span> pre1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://chace.in/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>CS6.824(1)-mapreduce</title>
    <link href="http://chace.in/2019/05/15/CS6.824(1)-mapreduce/"/>
    <id>http://chace.in/2019/05/15/CS6.824(1)-mapreduce/</id>
    <published>2019-05-15T12:48:00.000Z</published>
    <updated>2019-05-15T13:37:15.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>master: 获取Job信息，决定mapper和reducer个数，并分割文件。同时接收来自worker的注册，根据一定策略调度task给可用的worker，并进行出错处理。</p><p>worker: 执行具体的mapper或者reducer。</p><p>map阶段: map(k1, v1) -&gt; list(k2, v2)</p><p>reduce阶段: reduce(k2, list(v2)) -&gt; list(k2, v3)</p><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><p>Mapper读取master分配给自己的一份小文件，调用用户定义的map函数处理文件内容，map函数会返回一个key-value列表。</p><p>对于所有的key，mapper会计算其hash值并跟reducer个数取模，这样就完成了partition的过程，这个过程主要是为了将key分散到不同的reducer中。</p><p>对于上面的每一个partition，mapper会生成一个文件，将属于其的key-value对列表写入到该文件中。为了方便，序列化为JSON格式。在reduce阶段，reducer会从多个mapper生成的文件中读取分配给自己的文件。</p><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p>Reducer从map阶段生成的文件中读取分配给自己的文件，反序列化为key-value对列表。接下来，Reducer需要完成根据key来分组的过程。</p><p>这个过程可以用hashmap来实现，也可以用排序来实现。因为考虑到文件会很大，在内存中保存这样一个hashmap消耗很大。这里使用排序来实现。对于key-value对列表，调用排序函数根据key进行排序。排序完成后，只要发现下一个key跟上一个key不一样，就可以判断在这里是两个组的分割点，上一个分割点到这一个分割点中间的数据就是同一个key的列表。</p><p>分组完成后，调用用户定义的reduce函数处理每一个key及其value列表，reduce函数返回一个字符串，代表这个key规约的结果。</p><p>最后将key以及key规约的结果序列化成JSON格式，写入到reduce输出的文件中。</p><p>之后还会有merge的阶段，将多个reducer生成的文件合并成一个完整文件，作为MapReduce最终的输出结果。</p><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>master启动一个RPC服务器，用来接收worker的注册。worker通过RPC注册到master后，master会将worker的信息发送给registerChan。Scheduler从registerChan中接收注册的worker，加入到idleWorkerChan中。这个过程是在一个go程里循环读取的。</p><p>在map阶段或者reduce阶段，对于所有的task，首先将所有task放入到taskChan中，之后循环从这个taskChan中获取一个task，然后启动一个go程，在这个go程里从idleWorkerChan中获取一个worker，把这个task通过rpc的方式交给这个worker去执行。</p><p>在这里简化了worker崩溃的判断，只要rpc调用失败就认为worker崩溃，这个时候将task放回到taskChan中。如果rpc调用成功，则将worker放入idleWorkerChan中，使得其可以重新被调度。</p><p>当所有task执行完毕后，主线程会收到一个通知，跳出循环，结束该阶段的任务。</p><h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><p>因为只有当map阶段的任务完成以后才会开始执行reduce任务，只有当reduce阶段任务全部完成后才会开始执行merge，因此保证了map操作跟reduce操作具有原子性。也就是说，map(reduce)的输出文件要么不可用，要么就是完整的。下一阶段的task不会读取到不一致的数据。</p><p>map跟reduce操作都是幂等的，也就是多次重复执行产生的结果一直，这也是上述在worker失败时，schedule可以将task放回到taskChan中重新执行的背后原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;整体架构&lt;/h2&gt;&lt;p&gt;master: 获取Job信息，决定mapper和reducer个数，并分割文件。同时接收来自worker的注册，根据一定策
      
    
    </summary>
    
    
      <category term="分布式系统" scheme="http://chace.in/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python(17-18)——并发</title>
    <link href="http://chace.in/2019/03/11/Fluent%20Python(17-18)%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/"/>
    <id>http://chace.in/2019/03/11/Fluent Python(17-18)——并发/</id>
    <published>2019-03-11T12:30:04.000Z</published>
    <updated>2019-05-01T04:44:04.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="17-concurrent处理多进程和多线程"><a href="#17-concurrent处理多进程和多线程" class="headerlink" title="17. concurrent处理多进程和多线程"></a>17. concurrent处理多进程和多线程</h1><h2 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h2><ol><li>线程池和进程池：ThreadPoolExecutor和ProcessPoolExecutor</li><li>ThreadPoolExecutor.map(func, list_of_param)返回生成器，获取各个函数返回的值。获取返回值时会<strong>阻塞</strong>，返回结果的顺序与调用的顺序一致。</li><li>ThreadPoolExecutor.submit(func, param)返回future对象，futures.as_completed(list_of_future)返回迭代器，在任一future运行结束后产出future。之后可以使用future.result()获取结果，这样可以<strong>不阻塞</strong>。</li><li>另一种方式是future.add_done_callback(callback)</li></ol><p>as_completed()内部实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将调用as_completed之前已经完成的future直接yield</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> finished</span><br><span class="line"><span class="comment"># 死循环</span></span><br><span class="line"><span class="keyword">while</span> pending:</span><br><span class="line">    <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        wait_timeout = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wait_timeout = end_time - time.time()</span><br><span class="line">        <span class="keyword">if</span> wait_timeout &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> TimeoutError(</span><br><span class="line">                    <span class="string">'%d (of %d) futures unfinished'</span> % (</span><br><span class="line">                    len(pending), len(fs)))</span><br><span class="line">    <span class="comment"># 阻塞等待有没有future完成</span></span><br><span class="line">    waiter.event.wait(wait_timeout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> waiter.lock:</span><br><span class="line">        finished = waiter.finished_futures</span><br><span class="line">        waiter.finished_futures = []</span><br><span class="line">        waiter.event.clear()</span><br><span class="line">    <span class="comment"># 每当有完成的future时，yield future</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> finished:</span><br><span class="line">        <span class="keyword">yield</span> future</span><br><span class="line">        pending.remove(future)</span><br></pre></td></tr></table></figure></p><h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><ol><li>CPython解释器本身不是线程安全的，因此有GIL，一次只允许一个线程执行Python字节码。</li><li>标准库中阻塞性IO操作在等待系统返回结果时会释放GIL，因此IO密集型操作可以用多线程并发；time.sleep()也会释放GIL实现并发。</li><li>CPU密集型操作使用多进程并发。</li><li>PyPy虽然没有释放GIL，但是因为有JIL，在CPU密集型工作时比CPython快。</li></ol><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>注意：with块结束后主程序才会继续往下执行，或者显式地调用executor.shutdown(wait=False)不等待继续执行。</p><p>shutdown(wait=True)的含义：</p><p>Signal the executor that it should free any resources that it is using when the currently pending futures are done executing.</p><p>所以调用shutdown并不会中断当前进程池中的future，只是通知future执行完毕后释放资源。</p><h1 id="18-asyncio协程处理并发"><a href="#18-asyncio协程处理并发" class="headerlink" title="18. asyncio协程处理并发"></a>18. asyncio协程处理并发</h1><h2 id="yield-from-await的概念"><a href="#yield-from-await的概念" class="headerlink" title="yield from/await的概念"></a>yield from/await的概念</h2><p>在调用方-委派生成器-子生成器模型中：<br>在gen中使用yield from subgen()时，subgen获得控制权，把产出的值传给gen的调用方。gen会阻塞，等待subgen()产出值。<br>yield from的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送(send)和产出(yield)值。（在Python 3.5以上，可以使用await代替yield from，更容易理解）<br>假设yield from出现在委派生成器中，客户端代码驱动着委派生成器，而委派生成器驱动着子生成器。</p><p>asyncio中：<br>可以这样理解，yield from跟普通调用的区别就在于不会阻塞事件循环。类似于epoll。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会阻塞事件循环，因为当调用了yield from以后，控制权就回到事件循环手中了。</span></span><br><span class="line">resp = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.request(<span class="string">'GET'</span>, url)</span><br><span class="line"><span class="comment"># resp = await aiohttp.request('GET', url) 用await更容易理解</span></span><br><span class="line"><span class="comment"># 会阻塞主线程</span></span><br><span class="line">resp = aiohttp.request(<span class="string">'GET'</span>, url)</span><br></pre></td></tr></table></figure></p><p>yield from的用法：</p><ol><li>在yield from链接的多个协程最终必须由不是协程的调用方驱动，调用方显示或隐式在最外层委派生成器上调用next(…)或.send(…)。</li><li>链条中最内层的子生成器必须是简单生成器(yield)或可迭代对象。</li></ol><p>在asyncio中：<br>我们编写的协程链条始终通过把最外层委派生成器传给asyncio包API中的某个函数(如loop.run_until_complete(…))驱动。也就是说，调用next(…)或者send(…)的操作由asyncio的事件循环完成。</p><p>概括起来：使用asyncio包时，使用yield from架起管道，让asyncio的事件循环(通过我们编写的协程)，驱动执行底层异步IO操作的库函数。</p><h2 id="使用asyncio的步骤"><a href="#使用asyncio的步骤" class="headerlink" title="使用asyncio的步骤"></a>使用asyncio的步骤</h2><h3 id="1-创建task-可选"><a href="#1-创建task-可选" class="headerlink" title="1. 创建task(可选)"></a>1. 创建task(可选)</h3><p>创建单个task：</p><ul><li>asyncio.async(…)</li><li>BaseEventLoop.create_task(…)</li></ul><p>创建多个task:</p><ul><li>asyncio.wait(coros)  全部协程执行完毕后返回结果</li><li>asyncio.as_completed(coros)  返回一个生成器，当有协程完成时就迭代</li></ul><h3 id="2-获取事件循环"><a href="#2-获取事件循环" class="headerlink" title="2. 获取事件循环"></a>2. 获取事件循环</h3><p>loop = asyncio.get_event_loop()</p><h3 id="3-将task-s-或者coro加入到事件循环中"><a href="#3-将task-s-或者coro加入到事件循环中" class="headerlink" title="3. 将task(s)或者coro加入到事件循环中"></a>3. 将task(s)或者coro加入到事件循环中</h3><ul><li>loop.run_until_complete(coro/task)   普通运行loop</li><li>loop.run_in_executor(coro/task)   在ThreadPoolExecutor中运行loop</li></ul><p><strong>需要注意的是，第1步不是必须的，如果在第3步中传入的是协程而不是task，那么run_until_complete()会将协程包装成task，之所以用第1步，是为了持有task对象，方便对协程进行操作，比如获取完成的task的result、task.cancel()等。</strong></p><p>至于协程本身的定义，内部使用yield from关键字，函数使用@asyncio.coroutine装饰。</p><p><strong>对于Python 3.5以上，内部使用await代替yield from，函数使用async def func()</strong>，语义更加明确。</p><h3 id="异步IO的事件循环示例："><a href="#异步IO的事件循环示例：" class="headerlink" title="异步IO的事件循环示例："></a>异步IO的事件循环示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello world! (%s)'</span> % threading.currentThread())</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'Hello again! (%s)'</span> % threading.currentThread())</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [hello(), hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>执行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">(暂停约1秒)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br></pre></td></tr></table></figure></p><p>可以看到，两个协程并发执行，但是是在同一个线程里完成的，中间并没有发生阻塞。也就是说，当协程运行到await asyncio.sleep(1)时，控制权会交换给事件循环，事件循环会去继续执行其他协程，中间不会阻塞。</p><h3 id="基于异步IO的HTTP服务器"><a href="#基于异步IO的HTTP服务器" class="headerlink" title="基于异步IO的HTTP服务器"></a>基于异步IO的HTTP服务器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'Receive: &#123;&#125;'</span>.format(request))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> web.Response(content_type=<span class="string">'text/html'</span>, text=<span class="string">'&lt;h1&gt;Index&lt;/h1&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'Receive: &#123;&#125;'</span>.format(request))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">    text = <span class="string">'&lt;h1&gt;hello, %s!&lt;/h1&gt;'</span> % request.match_info[<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">return</span> web.Response(content_type=<span class="string">'text/html'</span>, text=text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(loop, address, port)</span>:</span></span><br><span class="line">    app = web.Application(loop=loop)</span><br><span class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/'</span>, index)</span><br><span class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/hello/&#123;name&#125;'</span>, hello)</span><br><span class="line">    srv = <span class="keyword">await</span> loop.create_server(app.make_handler(), address, port)</span><br><span class="line">    print(<span class="string">'Server started at http://&#123;&#125;:&#123;&#125;...'</span>.format(address, port))</span><br><span class="line">    <span class="keyword">return</span> srv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(address=<span class="string">'127.0.0.1'</span>, port=<span class="number">8888</span>)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 注意观察这里的srv，其实是协程init结束后的返回值</span></span><br><span class="line">    srv = loop.run_until_complete(init(loop, address, port))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'Server &#123;&#125; shutting down.'</span>.format(srv))</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(*sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h1 id="Python并发总结"><a href="#Python并发总结" class="headerlink" title="Python并发总结"></a>Python并发总结</h1><p>协程的底层还是基于事件循环，类似于IO多路复用这种方式，让单线程可以实现并发。</p><p>并发的实现依赖于协程的不阻塞，所以协程最后的操作要使用非阻塞操作(比如asyncio.sleep(0.5)是非阻塞的，或者一些asyncio的网络IO操作)才能发挥作用，否则就跟顺序执行一样了。如果必须要使用阻塞的操作，可以使用<code>loop.run_in_executor</code>在线程池中使用多个loop。</p><p>asyncio实现并发的流程：主线程持有一个事件循环loop，会去调度加入到事件循环中的协程并调度执行，当协程进行异步操作的时候，控制权回到事件循环，事件循环再去调度其他协程执行。当暂停的协程返回时，事件循环再去调度其执行。因而实现了并发，跟IO多路复用很像。</p><p>协程跟多线程相比优势：</p><ol><li>没有切换线程的开销</li><li>不用处理锁</li><li>由用户决定协程的调度（通过send()激活，yield暂停）</li></ol><p>协程跟多线程相比劣势：</p><ol><li>执行的操作必须是异步操作，否则就没有调度的意义</li><li>无论怎么说，只有一个线程，没法使用到多核CPU。(Go语言好像解决了这个问题)</li></ol><p>总结来说，并发的实现可以基于三种方式：</p><ol><li>多进程</li><li>多线程</li><li>基于事件循环的异步IO</li></ol><p>而对于3来说，目前主流语言有两种实现方式：1.回调 2.协程。NodeJS里使用的是回调，而Python使用的是协程。</p><p>与回调相比，协程的优势在于：</p><ol><li>不会陷入多层回调嵌套，那样代码是复杂且难以阅读的。</li><li>协程可以在中断处保存上下文，下次继续执行时可以恢复，因而不需要再去单独把中间结果保存到全局或者其他地方（回调中必须这样做）。</li></ol><h2 id="使用场景总结"><a href="#使用场景总结" class="headerlink" title="使用场景总结"></a>使用场景总结</h2><p>计算密集型使用多进程。这样可以用到多核CPU。</p><p>异步IO密集型可以使用协程，然后用线程池创建多个event_loop可以辅助提高性能；</p><p>同步IO密集型使用多线程。Python因为有GIL锁，其实多线程并不能利用多核CPU实现<strong>并行</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;17-concurrent处理多进程和多线程&quot;&gt;&lt;a href=&quot;#17-concurrent处理多进程和多线程&quot; class=&quot;headerlink&quot; title=&quot;17. concurrent处理多进程和多线程&quot;&gt;&lt;/a&gt;17. concurrent处理多进程
      
    
    </summary>
    
    
      <category term="Python" scheme="http://chace.in/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python(14-16)——从迭代器到协程</title>
    <link href="http://chace.in/2019/03/03/Fluent%20Python(14-16)%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://chace.in/2019/03/03/Fluent Python(14-16)——迭代器/</id>
    <published>2019-03-03T07:22:04.000Z</published>
    <updated>2019-04-29T03:32:43.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14-迭代器与生成器"><a href="#14-迭代器与生成器" class="headerlink" title="14. 迭代器与生成器"></a>14. 迭代器与生成器</h1><ol><li><p><strong>可迭代的对象</strong>：使用iter内置函数可以获取迭代器的对象。如果对象实现了<code>__iter__</code>方法，能够返回一个迭代器，那么对象就是可迭代的。</p></li><li><p><strong>迭代器</strong>：对象实现了<code>__next__</code>返回序列中的下一个元素。迭代器还实现了<code>__iter__</code>返回self，因此迭代器也可以迭代。</p></li><li><p><strong>生成器函数</strong>：函数的定义体中有<code>yield</code>关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p></li><li><p><strong>关系</strong>：所有的生成器都是迭代器，因为生成器完全实现了迭代器接口。生成器只是另一种实现可迭代对象的方式而已。除了会创建和保存程序状态，当生成器终结时，还会自动抛出StopIteration异常。</p></li></ol><h1 id="15-上下文管理器和with块"><a href="#15-上下文管理器和with块" class="headerlink" title="15. 上下文管理器和with块"></a>15. 上下文管理器和with块</h1><ol><li><p>else可以用在for, while, try的后面，循环体正常执行完毕（没有break, 没有except）后退出时执行else的内容。</p></li><li><p>上下文管理器对象存在的目的是管理with块，简化try/finally模式。</p></li><li><p>ContextManger实现的两种方式：</p><ol><li>编写一个类，实现<code>__enter__</code>和<code>__exit__</code>方法</li><li>调用<a href="mailto:`@contextlib.contextmanager" target="_blank" rel="noopener">`@contextlib.contextmanager</a><code>装饰器，将生成器函数转变为上下文管理器，函数中yield之前的语句对应</code><strong>enter</strong><code>内容，yield xxx为返回的对象（对应到with func() as xxx的xxx），yield之后的语句对应</code><strong>exit</strong>`内容。<strong>始终用try语句包裹yield语句</strong></li></ol></li></ol><h1 id="16-协程"><a href="#16-协程" class="headerlink" title="16. 协程"></a>16. 协程</h1><h2 id="1-进程、线程、协程"><a href="#1-进程、线程、协程" class="headerlink" title="1. 进程、线程、协程"></a>1. 进程、线程、协程</h2><p>进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。</p><p>线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程，而多个线程共享内存（数据共享，共享全局变量),从而极大地提高了程序的运行效率。 </p><p>协程: 可以理解一种<strong>用户态的轻量级线程</strong>，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><p>协程与子程序的区别：调用子程序执行到return之后子程序就完全返回到主程序了，而协程会保存现场，下次从中断点继续执行。（中断）</p><p>协程与线程优势：1. 没有多线程切换的开销，寄存器和栈都保存在用户态。2. 不需要锁机制，因为是在一个线程中，不存在写变量冲突问题。所以协程是一种协作式多任务，多线程是一种抢占式多任务。</p><p>Python里CPU密集型使用多进程，IO密集型使用多线程或协程。</p><h2 id="2-协程"><a href="#2-协程" class="headerlink" title="2. 协程"></a>2. 协程</h2><ol><li><p><code>b = yield a</code> 表达式左右两边在两次send()执行。</p></li><li><p>调用方调用<code>next(cor)</code>之后，协程执行到<code>yield a</code>并暂停，调用方收到返回值；调用方调用<code>cor.send(b)</code>，从中断点继续执行，将接收到的b赋值给等号左边的b，继续向下执行。当碰到下一个<code>yield a</code>时再次暂停并产出a。 </p></li><li><p><code>yield from</code>实现类似于管道的功能，调用方-委派生成器-子生成器。</p></li><li><p>生成器函数需要初始化也就是<code>f=func()</code>后f才是generator，func是function类型。</p></li></ol><h2 id="3-协程实现生产者消费者模型"><a href="#3-协程实现生产者消费者模型" class="headerlink" title="3. 协程实现生产者消费者模型"></a>3. 协程实现生产者消费者模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(consumer)</span>:</span></span><br><span class="line">    ret = next(consumer)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">'[PRODUCER] produce: %d'</span> % i)</span><br><span class="line">        ret = consumer.send(i)</span><br><span class="line">        print(<span class="string">'[PRODUCER] consumer return: %s'</span> % ret)</span><br><span class="line">    consumer.close()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        i = <span class="keyword">yield</span> ret</span><br><span class="line">        print(<span class="string">'[CONSUMER] consume: %d'</span> % i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        ret = <span class="string">'OK'</span></span><br><span class="line">        </span><br><span class="line">c = consumer()</span><br><span class="line">producer(c)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;14-迭代器与生成器&quot;&gt;&lt;a href=&quot;#14-迭代器与生成器&quot; class=&quot;headerlink&quot; title=&quot;14. 迭代器与生成器&quot;&gt;&lt;/a&gt;14. 迭代器与生成器&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可迭代的对象&lt;/strong&gt;：使用i
      
    
    </summary>
    
    
      <category term="Python" scheme="http://chace.in/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记(二)-工具及底层实现</title>
    <link href="http://chace.in/2018/09/14/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://chace.in/2018/09/14/Docker学习笔记(二)-工具及底层实现/</id>
    <published>2018-09-14T03:15:43.000Z</published>
    <updated>2019-06-11T03:10:29.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h2><p>Compose 中有两个重要的概念：</p><ul><li>服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li></ul><p>命令有点类似docker<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建项目中的服务容器</span></span><br><span class="line">docker-compose build [options] [SERVICE...]</span><br><span class="line"><span class="comment"># 启动一个service</span></span><br><span class="line">docker-compose run [options] [-p PORT...] [-e KEY=VAL...] &lt;SERVICE&gt; [COMMAND] [ARGS...]</span><br><span class="line"><span class="comment"># 启动一个project</span></span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure></p><p>然后是模板文件docker-compose.yml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">examples/web</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/data"</span></span><br></pre></td></tr></table></figure></p><h2 id="Docker-machine"><a href="#Docker-machine" class="headerlink" title="Docker machine"></a>Docker machine</h2><p>Docker machine大概是个用来创建管理虚拟机的工具，当然这些虚拟机都装好了Docker Engine。通过这种方式可以方便地创建多个docker节点。</p><blockquote><p>Docker Machine is a tool that lets you install Docker Engine on virtual hosts, and manage the hosts with docker-machine commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like Azure, AWS, or Digital Ocean.</p></blockquote><h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h2><p>用于集群管理的一个工具。</p><h3 id="1-创建swarm集群"><a href="#1-创建swarm集群" class="headerlink" title="1.创建swarm集群"></a>1.创建swarm集群</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.99.100</span><br><span class="line"><span class="comment"># 用machine创建一个worker1节点</span></span><br><span class="line">docker-machine create -d virtualbox worker1</span><br><span class="line">docker-machine ssh worker1</span><br><span class="line"><span class="comment"># 加入swarm集群</span></span><br><span class="line">docker swarm join \</span><br><span class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">docker node ls</span><br></pre></td></tr></table></figure><h3 id="2-部署服务"><a href="#2-部署服务" class="headerlink" title="2.部署服务"></a>2.部署服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建nginx服务</span></span><br><span class="line">docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">docker service ps nginx</span><br><span class="line">docker service logs nginx</span><br></pre></td></tr></table></figure><h3 id="3-在swarm集群中使用compose来快速部署"><a href="#3-在swarm集群中使用compose来快速部署" class="headerlink" title="3.在swarm集群中使用compose来快速部署"></a>3.在swarm集群中使用compose来快速部署</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml wordpress</span><br><span class="line">docker stack ls</span><br><span class="line">docker stack down</span><br></pre></td></tr></table></figure><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="1-命名空间"><a href="#1-命名空间" class="headerlink" title="1. 命名空间"></a>1. 命名空间</h3><p>命名空间是 Linux内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p><h3 id="2-控制组"><a href="#2-控制组" class="headerlink" title="2. 控制组"></a>2. 控制组</h3><p>控制组（cgroups）是Linux内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p><h3 id="3-联合文件系统"><a href="#3-联合文件系统" class="headerlink" title="3. 联合文件系统"></a>3. 联合文件系统</h3><p>联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p><h3 id="4-网络"><a href="#4-网络" class="headerlink" title="4. 网络"></a>4. 网络</h3><p>Docker 创建一个容器的时候，会执行如下操作：</p><ul><li>创建一对虚拟接口，分别放到本地主机和新容器中；</li><li>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</li><li>容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</li><li>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</li></ul><p>参考：<a href="https://www.kancloud.cn/docker_practice/docker_practice/469861" target="_blank" rel="noopener">Docker 网络实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker-compose&quot;&gt;&lt;a href=&quot;#Docker-compose&quot; class=&quot;headerlink&quot; title=&quot;Docker compose&quot;&gt;&lt;/a&gt;Docker compose&lt;/h2&gt;&lt;p&gt;Compose 中有两个重要的概念：&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://chace.in/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ学习笔记</title>
    <link href="http://chace.in/2018/09/13/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://chace.in/2018/09/13/RabbitMQ学习笔记/</id>
    <published>2018-09-13T11:38:56.000Z</published>
    <updated>2018-09-13T11:41:39.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install rabbitmq-server</span><br></pre></td></tr></table></figure><h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a>2. 基本原理</h2><p>一篇比较好的原理介绍文章：<a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">消息队列之 RabbitMQ</a></p><p><img src="https://upload-images.jianshu.io/upload_images/5015984-367dd717d89ae5db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554" alt="Rabbit架构图"></p><p><img src="https://upload-images.jianshu.io/upload_images/5015984-7fd73af768f28704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/484" alt="路由过程"></p><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了。</p><p>direct：发送到路由键完全匹配的队列<br>fanout: 发送到所有队列<br>topic: 基于模式，比如route key的usa.news, usa.weather都发送到binding key的usa.#</p><p>也可以启动集群，用NODE_NAME来区分。内存节点和磁盘节点，必须有一个磁盘节点。</p><h2 id="3-工作队列"><a href="#3-工作队列" class="headerlink" title="3. 工作队列"></a>3. 工作队列</h2><p>带ACK的消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consume的时候发送ack=false</span></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(QUEUE_NAME, autoAck, consumer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当完成任务后发送ACK</span></span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"># 以下命令查看未ack的消息</span><br><span class="line">rabbitmqctl list_queues name message_ready message_unacknowledged</span><br></pre></td></tr></table></figure></p><p>持久化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure></p><p>公平调度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果work没有发送ACK，则不再发送新消息</span></span><br><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h2 id="4-发布-订阅模式"><a href="#4-发布-订阅模式" class="headerlink" title="4. 发布/订阅模式"></a>4. 发布/订阅模式</h2><p>Exchange<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个exchange，有direct、fanout、topic、headers四种模式</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"><span class="comment">// publish的时候指定exchange name即可</span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure></p><p>Bindings<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个临时队列</span></span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">// 绑定队列到exchange上</span></span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"># 以下命令查看绑定</span><br><span class="line">rabbitmqctl list_bindings</span><br></pre></td></tr></table></figure></p><h2 id="5-路由"><a href="#5-路由" class="headerlink" title="5. 路由"></a>5. 路由</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br><span class="line"><span class="comment">// 指定routing key和binding key即可</span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">"error"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"error"</span>);</span><br></pre></td></tr></table></figure><h2 id="6-topic"><a href="#6-topic" class="headerlink" title="6. topic"></a>6. topic</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 代表一个word</span><br><span class="line"># 代表一个或多个word</span><br><span class="line">使用上面的两个符号来进行匹配，中间用<span class="string">"."</span>隔开。比如<span class="string">"*.kern.error"</span>。</span><br><span class="line"></span><br><span class="line">如果bindingKey=<span class="string">"#"</span>，那就跟fanout模式一样；</span><br><span class="line">如果bindingKey不包含*或#，那就跟direct一样。</span><br><span class="line"></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, bingingKey);</span><br></pre></td></tr></table></figure><h2 id="7-RPC"><a href="#7-RPC" class="headerlink" title="7. RPC"></a>7. RPC</h2><p>用replyTo和correlationId在两者之间建立联系<br><img src="https://www.rabbitmq.com/img/tutorials/python-six.png" alt="RPC"><br>When the Client starts up, it creates an anonymous exclusive callback queue.<br>For an RPC request, the Client sends a message with two properties: replyTo, which is set to the callback queue and correlationId, which is set to a unique value for every request.<br>The request is sent to an rpc_queue queue.<br>The RPC worker (aka: server) is waiting for requests on that queue. When a request appears, it does the job and sends a message with the result back to the Client, using the queue from the  replyTo field.<br>The client waits for data on the callback queue. When a message appears, it checks the correlationId property. If it matches the value from the request it returns the response to the application.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1. 安装&quot;&gt;&lt;/a&gt;1. 安装&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="rabbitMQ" scheme="http://chace.in/tags/rabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes学习笔记(三)-网络管理</title>
    <link href="http://chace.in/2018/09/11/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    <id>http://chace.in/2018/09/11/kubernetes学习笔记(三)-网络管理/</id>
    <published>2018-09-11T01:34:41.000Z</published>
    <updated>2019-06-11T03:10:39.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-要点"><a href="#1-要点" class="headerlink" title="1. 要点"></a>1. 要点</h2><p>IP以Pod为单位分配，一个Pod内部的所有容器共享一个网络堆栈。</p><p>一个Pod内部的应用程序看到的自己的IP地址和端口与集群内其他Pod看到的一样，它们都是Pod从docker0分配的。</p><p>一个pod内的容器可以通过localhost访问另一个容器。</p><p>Pod从网络角度来看，可以看做一台独立的“虚拟机”或“物理机”。</p><p>docker原生网络通过动态端口映射的方式实现多节点访问，访问者看到额IP地址和端口与服务提供者实际绑定的不同。服务自身很难知道自己对外暴露的真实的服务IP和端口，外部应用也无法通过服务所在容器的私有IP地址和端口来访问服务。</p><p>Docker一开始没有考虑到多主机互联的网络解决方案。</p><p><strong>当前docker的多主机网络解决方案？？？</strong></p><h2 id="2-kubernetes的网络实现"><a href="#2-kubernetes的网络实现" class="headerlink" title="2. kubernetes的网络实现"></a>2. kubernetes的网络实现</h2><p>Service就是一个反向代理。</p><ol><li>同一pod内容器共享网络空间，可以通过localhost访问</li><li>同一node上的不同pod之间通信通过docker0网桥</li><li>不同node上的不同pod之间通信需要经过宿主机转发</li></ol><p><strong>不同Node上的Pod之间的通信要解决两个问题：</strong></p><ol><li>整个kubernetes集群中对pod的IP分配进行规划，不能有冲突；</li><li>找到一种办法，将pod的IP和所在node的IP关联起来，通过这个关联让pod可以互相访问。</li></ol><p>pod和service之间的通信通过kube-proxy的反向代理。</p><p>外部访问service通过NodePort或者LoadBalancer。NodePort模式会在集群的每个Node上打开一个主机上的真实端口号。</p><h2 id="3-使用网络组件"><a href="#3-使用网络组件" class="headerlink" title="3. 使用网络组件"></a>3. 使用网络组件</h2><ol><li><p>Flannel</p><ul><li>通过etcd分配不冲突的IP</li><li>建立叠加网络</li></ul></li><li><p>Open vSwitch</p><ul><li>docker0网桥的数据会发给ovs网桥</li><li>通过GRE/VxLAN隧道在Node之间传输</li></ul></li><li><p>直接路由<br>可以通过在两个Node之间添加静态路由规则来访问</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Node1(docker0: 10.1.10.0, eth0: 192.168.1.128)上添加规则</span></span><br><span class="line">route add -net 10.1.20.0 netmask 255.255.255.0 gw 192.168.1.129</span><br><span class="line"><span class="comment"># 在Node2(docker0: 10.1.120.1, eth0: 192.168.1.129)上添加规则</span></span><br><span class="line">route add -net 10.1.10.0 netmask 255.255.255.0 gw 192.168.1.128</span><br></pre></td></tr></table></figure><p>也可以通过Quagga、Zebra等配置动态路由规则，但是还是要提前规划好docker0的IP分配。</p><p><strong>DNS跟Monitor官网现在已经更新，这本书上的内容有点过时了。</strong> 可以参考下面文章。</p><ul><li><a href="https://jimmysong.io/posts/configuring-kubernetes-kube-dns/" target="_blank" rel="noopener">配置Kubernetes DNS服务kube-dns</a></li><li><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/" target="_blank" rel="noopener">Tools for Monitoring Resources</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-要点&quot;&gt;&lt;a href=&quot;#1-要点&quot; class=&quot;headerlink&quot; title=&quot;1. 要点&quot;&gt;&lt;/a&gt;1. 要点&lt;/h2&gt;&lt;p&gt;IP以Pod为单位分配，一个Pod内部的所有容器共享一个网络堆栈。&lt;/p&gt;
&lt;p&gt;一个Pod内部的应用程序看到的自己的I
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://chace.in/tags/Docker/"/>
    
      <category term="kubernetes" scheme="http://chace.in/tags/kubernetes/"/>
    
  </entry>
  
</feed>
